
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

00000000 <__start>:

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
   0:	00000297          	auipc	t0,0x0
   4:	03028293          	addi	t0,t0,48 # 30 <__irq_wrapper>
	csrw mtvec, t0
   8:	30529073          	csrw	mtvec,t0
	/*
	* To avoid having to hardcode the main clock frequency,
	* we read the actual value from register 0x8000103c
	* and store to z_clock_hw_cycles_per_sec
	*/
	li	t0, 0x80001000
   c:	800012b7          	lui	t0,0x80001
	lw	t1, 0x3c(t0)
  10:	03c2a303          	lw	t1,60(t0) # 8000103c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000103d>
	la	t0, z_clock_hw_cycles_per_sec
  14:	00006297          	auipc	t0,0x6
  18:	09428293          	addi	t0,t0,148 # 60a8 <z_clock_hw_cycles_per_sec>
	sw	t1, 0(t0)
  1c:	0062a023          	sw	t1,0(t0)

	/* Jump to __initialize */
	tail __initialize
  20:	0a80306f          	j	30c8 <__initialize>

Disassembly of section exceptions:

00000030 <__irq_wrapper>:
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	STORE_CALLER_SAVED()
  30:	fb010113          	addi	sp,sp,-80
  34:	00112023          	sw	ra,0(sp)
  38:	00412223          	sw	tp,4(sp)
  3c:	00512423          	sw	t0,8(sp)
  40:	00612623          	sw	t1,12(sp)
  44:	00712823          	sw	t2,16(sp)
  48:	01c12a23          	sw	t3,20(sp)
  4c:	01d12c23          	sw	t4,24(sp)
  50:	01e12e23          	sw	t5,28(sp)
  54:	03f12023          	sw	t6,32(sp)
  58:	02a12223          	sw	a0,36(sp)
  5c:	02b12423          	sw	a1,40(sp)
  60:	02c12623          	sw	a2,44(sp)
  64:	02d12823          	sw	a3,48(sp)
  68:	02e12a23          	sw	a4,52(sp)
  6c:	02f12c23          	sw	a5,56(sp)
  70:	03012e23          	sw	a6,60(sp)
  74:	05112023          	sw	a7,64(sp)

skip_store_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Save MEPC register */
	csrr t0, mepc
  78:	341022f3          	csrr	t0,mepc
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
  7c:	04512223          	sw	t0,68(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, mstatus
  80:	300022f3          	csrr	t0,mstatus
	RV_OP_STOREREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
  84:	04512423          	sw	t0,72(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
  88:	228000ef          	jal	ra,2b0 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
  8c:	00000313          	li	t1,0
	bnez a0, is_interrupt
  90:	02051e63          	bnez	a0,cc <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
  94:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
  98:	800003b7          	lui	t2,0x80000
  9c:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
  a0:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
  a4:	00b00313          	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	beq t0, t1, is_kernel_syscall
  a8:	00628a63          	beq	t0,t1,bc <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	addi a0, sp, 0
  ac:	00010513          	mv	a0,sp
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
	RV_OP_LOADREG t0, _thread_offset_to_priv_stack_start(t1)
	RV_OP_STOREREG sp, _thread_offset_to_user_sp(t1) /* Update user SP */
	addi sp, t0, CONFIG_PRIVILEGED_STACK_SIZE
#else
	la ra, no_reschedule
  b0:	00000097          	auipc	ra,0x0
  b4:	19408093          	addi	ra,ra,404 # 244 <no_reschedule>
#endif /* CONFIG_USERSPACE */

	tail _Fault
  b8:	7c90206f          	j	3080 <_Fault>

000000bc <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
  bc:	04412283          	lw	t0,68(sp)
	addi t0, t0, 4
  c0:	00428293          	addi	t0,t0,4
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
  c4:	04512223          	sw	t0,68(sp)
	j z_riscv_user_mode_enter_syscall
#endif /* CONFIG_USERSPACE */
	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
  c8:	0800006f          	j	148 <reschedule>

000000cc <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
  cc:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
  d0:	00005397          	auipc	t2,0x5
  d4:	19838393          	addi	t2,t2,408 # 5268 <_kernel>
	RV_OP_LOADREG sp, _kernel_offset_to_irq_stack(t2)
  d8:	0043a103          	lw	sp,4(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
  dc:	ff010113          	addi	sp,sp,-16
	RV_OP_STOREREG t0, 0x00(sp)
  e0:	00512023          	sw	t0,0(sp)

000000e4 <on_irq_stack>:
	la t2, _kernel
#endif /* !CONFIG_USERSPACE && !CONFIG_PMP_STACK_GUARD */

on_irq_stack:
	/* Increment _kernel.cpus[0].nested variable */
	lw t3, _kernel_offset_to_nested(t2)
  e4:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
  e8:	001e0e13          	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
  ec:	01c3a023          	sw	t3,0(t2)
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
  f0:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
  f4:	800002b7          	lui	t0,0x80000
  f8:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
  fc:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
 100:	1a0000ef          	jal	ra,2a0 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
 104:	00005297          	auipc	t0,0x5
 108:	a1028293          	addi	t0,t0,-1520 # 4b14 <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
 10c:	00351513          	slli	a0,a0,0x3
	add t0, t0, a0
 110:	00a282b3          	add	t0,t0,a0

	/* Load argument in a0 register */
	RV_OP_LOADREG a0, 0x00(t0)
 114:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	RV_OP_LOADREG t1, RV_REGSIZE(t0)
 118:	0042a303          	lw	t1,4(t0)

	/* Call ISR function */
	jalr ra, t1
 11c:	000300e7          	jalr	t1

00000120 <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
 120:	00005317          	auipc	t1,0x5
 124:	14830313          	addi	t1,t1,328 # 5268 <_kernel>

	/* Decrement _kernel.cpus[0].nested variable */
	lw t2, _kernel_offset_to_nested(t1)
 128:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
 12c:	fff38393          	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
 130:	00732023          	sw	t2,0(t1)

#if !defined(CONFIG_USERSPACE) && !defined(CONFIG_PMP_STACK_GUARD)
	/* Restore thread stack pointer */
	RV_OP_LOADREG t0, 0x00(sp)
 134:	00012283          	lw	t0,0(sp)
	addi sp, t0, 0
 138:	00028113          	mv	sp,t0
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t2, _kernel_offset_to_current(t1)
 13c:	00832383          	lw	t2,8(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t1)
 140:	01832e03          	lw	t3,24(t1)
	beq t3, t2, no_reschedule
 144:	107e0063          	beq	t3,t2,244 <no_reschedule>

00000148 <reschedule>:
	 * Note:
	 *   Sometimes this code is execute back-to-back before the target thread
	 *   has a chance to run. If this happens, the current thread and the
	 *   target thread will be the same.
	 */
	la t0, _kernel
 148:	00005297          	auipc	t0,0x5
 14c:	12028293          	addi	t0,t0,288 # 5268 <_kernel>
	RV_OP_LOADREG t2, _kernel_offset_to_current(t0)
 150:	0082a383          	lw	t2,8(t0)
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t0)
 154:	0182ae03          	lw	t3,24(t0)
	beq t2, t3, no_reschedule
 158:	0fc38663          	beq	t2,t3,244 <no_reschedule>

#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	call z_thread_mark_switched_out
#endif
	/* Get reference to _kernel */
	la t0, _kernel
 15c:	00005297          	auipc	t0,0x5
 160:	10c28293          	addi	t0,t0,268 # 5268 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
 164:	0082a303          	lw	t1,8(t0)

	/*
	 * Save callee-saved registers of current kernel thread
	 * prior to handle context-switching
	 */
	STORE_CALLEE_SAVED(t1)
 168:	02832a23          	sw	s0,52(t1)
 16c:	02932c23          	sw	s1,56(t1)
 170:	03232e23          	sw	s2,60(t1)
 174:	05332023          	sw	s3,64(t1)
 178:	05432223          	sw	s4,68(t1)
 17c:	05532423          	sw	s5,72(t1)
 180:	05632623          	sw	s6,76(t1)
 184:	05732823          	sw	s7,80(t1)
 188:	05832a23          	sw	s8,84(t1)
 18c:	05932c23          	sw	s9,88(t1)
 190:	05a32e23          	sw	s10,92(t1)
 194:	07b32023          	sw	s11,96(t1)

00000198 <skip_callee_saved_reg>:

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	RV_OP_STOREREG sp, _thread_offset_to_sp(t1)
 198:	02232823          	sw	sp,48(t1)
	la t2, _k_neg_eagain
 19c:	00005397          	auipc	t2,0x5
 1a0:	ba838393          	addi	t2,t2,-1112 # 4d44 <_k_neg_eagain>
	lw t3, 0x00(t2)
 1a4:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
 1a8:	07c32c23          	sw	t3,120(t1)

	/* Get next thread to schedule. */
	RV_OP_LOADREG t1, _kernel_offset_to_ready_q_cache(t0)
 1ac:	0182a303          	lw	t1,24(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	RV_OP_STOREREG t1, _kernel_offset_to_current(t0)
 1b0:	0062a423          	sw	t1,8(t0)

	/* Switch to new thread stack */
	RV_OP_LOADREG sp, _thread_offset_to_sp(t1)
 1b4:	03032103          	lw	sp,48(t1)

	/* Restore callee-saved registers of new thread */
	LOAD_CALLEE_SAVED(t1)
 1b8:	03432403          	lw	s0,52(t1)
 1bc:	03832483          	lw	s1,56(t1)
 1c0:	03c32903          	lw	s2,60(t1)
 1c4:	04032983          	lw	s3,64(t1)
 1c8:	04432a03          	lw	s4,68(t1)
 1cc:	04832a83          	lw	s5,72(t1)
 1d0:	04c32b03          	lw	s6,76(t1)
 1d4:	05032b83          	lw	s7,80(t1)
 1d8:	05432c03          	lw	s8,84(t1)
 1dc:	05832c83          	lw	s9,88(t1)
 1e0:	05c32d03          	lw	s10,92(t1)
 1e4:	06032d83          	lw	s11,96(t1)
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
 1e8:	04412283          	lw	t0,68(sp)
	csrw mepc, t0
 1ec:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
 1f0:	04812283          	lw	t0,72(sp)
	csrw mstatus, t0
 1f4:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved_resched:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
 1f8:	00012083          	lw	ra,0(sp)
 1fc:	00412203          	lw	tp,4(sp)
 200:	00812283          	lw	t0,8(sp)
 204:	00c12303          	lw	t1,12(sp)
 208:	01012383          	lw	t2,16(sp)
 20c:	01412e03          	lw	t3,20(sp)
 210:	01812e83          	lw	t4,24(sp)
 214:	01c12f03          	lw	t5,28(sp)
 218:	02012f83          	lw	t6,32(sp)
 21c:	02412503          	lw	a0,36(sp)
 220:	02812583          	lw	a1,40(sp)
 224:	02c12603          	lw	a2,44(sp)
 228:	03012683          	lw	a3,48(sp)
 22c:	03412703          	lw	a4,52(sp)
 230:	03812783          	lw	a5,56(sp)
 234:	03c12803          	lw	a6,60(sp)
 238:	04012883          	lw	a7,64(sp)
 23c:	05010113          	addi	sp,sp,80

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
 240:	30200073          	mret

00000244 <no_reschedule>:
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
 244:	04412283          	lw	t0,68(sp)
	csrw mepc, t0
 248:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
 24c:	04812283          	lw	t0,72(sp)
	csrw mstatus, t0
 250:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
 254:	00012083          	lw	ra,0(sp)
 258:	00412203          	lw	tp,4(sp)
 25c:	00812283          	lw	t0,8(sp)
 260:	00c12303          	lw	t1,12(sp)
 264:	01012383          	lw	t2,16(sp)
 268:	01412e03          	lw	t3,20(sp)
 26c:	01812e83          	lw	t4,24(sp)
 270:	01c12f03          	lw	t5,28(sp)
 274:	02012f83          	lw	t6,32(sp)
 278:	02412503          	lw	a0,36(sp)
 27c:	02812583          	lw	a1,40(sp)
 280:	02c12603          	lw	a2,44(sp)
 284:	03012683          	lw	a3,48(sp)
 288:	03412703          	lw	a4,52(sp)
 28c:	03812783          	lw	a5,56(sp)
 290:	03c12803          	lw	a6,60(sp)
 294:	04012883          	lw	a7,64(sp)
 298:	05010113          	addi	sp,sp,80

#ifdef CONFIG_PMP_STACK_GUARD
	csrrw sp, mscratch, sp
#endif /* CONFIG_PMP_STACK_GUARD */
	/* Call SOC_ERET to exit ISR */
	SOC_ERET
 29c:	30200073          	mret

000002a0 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
 2a0:	00100313          	li	t1,1
	sll t0, t1, a0
 2a4:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
 2a8:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
 2ac:	00008067          	ret

000002b0 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
 2b0:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
 2b4:	80000337          	lui	t1,0x80000
	and t0, t0, t1
 2b8:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
 2bc:	00000513          	li	a0,0
	beqz t0, not_interrupt
 2c0:	00028463          	beqz	t0,2c8 <not_interrupt>
	addi a0, a0, 1
 2c4:	00150513          	addi	a0,a0,1

000002c8 <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
 2c8:	00008067          	ret

000002cc <arch_swap>:
 * key is stored in a0 register
 */
SECTION_FUNC(exception.other, arch_swap)

	/* Make a system call to perform context switch */
	ecall
 2cc:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * arch_swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called arch_thread_return_value_set(..).
	 */
	la t0, _kernel
 2d0:	00005297          	auipc	t0,0x5
 2d4:	f9828293          	addi	t0,t0,-104 # 5268 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
 2d8:	0082a303          	lw	t1,8(t0)

	/* Load return value of arch_swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
 2dc:	07832383          	lw	t2,120(t1) # 80000078 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000079>

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, MSTATUS_IEN
 2e0:	00857513          	andi	a0,a0,8
	csrrs t0, mstatus, a0
 2e4:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
 2e8:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
 2ec:	00008067          	ret

Disassembly of section text:

000002f0 <__clzsi2>:
     2f0:	000107b7          	lui	a5,0x10
     2f4:	02f57a63          	bgeu	a0,a5,328 <__clzsi2+0x38>
     2f8:	0ff00793          	li	a5,255
     2fc:	00a7b7b3          	sltu	a5,a5,a0
     300:	00379793          	slli	a5,a5,0x3
     304:	00005737          	lui	a4,0x5
     308:	02000693          	li	a3,32
     30c:	40f686b3          	sub	a3,a3,a5
     310:	00f55533          	srl	a0,a0,a5
     314:	d4870793          	addi	a5,a4,-696 # 4d48 <__clz_tab>
     318:	00a78533          	add	a0,a5,a0
     31c:	00054503          	lbu	a0,0(a0)
     320:	40a68533          	sub	a0,a3,a0
     324:	00008067          	ret
     328:	01000737          	lui	a4,0x1000
     32c:	01000793          	li	a5,16
     330:	fce56ae3          	bltu	a0,a4,304 <__clzsi2+0x14>
     334:	01800793          	li	a5,24
     338:	fcdff06f          	j	304 <__clzsi2+0x14>

0000033c <__udivdi3>:
     33c:	00050893          	mv	a7,a0
     340:	00058793          	mv	a5,a1
     344:	00060813          	mv	a6,a2
     348:	00068513          	mv	a0,a3
     34c:	00088313          	mv	t1,a7
     350:	28069463          	bnez	a3,5d8 <CONFIG_MAIN_STACK_SIZE+0x1d8>
     354:	000056b7          	lui	a3,0x5
     358:	d4868693          	addi	a3,a3,-696 # 4d48 <__clz_tab>
     35c:	0ec5f663          	bgeu	a1,a2,448 <CONFIG_MAIN_STACK_SIZE+0x48>
     360:	00010737          	lui	a4,0x10
     364:	0ce67863          	bgeu	a2,a4,434 <CONFIG_MAIN_STACK_SIZE+0x34>
     368:	0ff00713          	li	a4,255
     36c:	00c73733          	sltu	a4,a4,a2
     370:	00371713          	slli	a4,a4,0x3
     374:	00e65533          	srl	a0,a2,a4
     378:	00a686b3          	add	a3,a3,a0
     37c:	0006c683          	lbu	a3,0(a3)
     380:	02000513          	li	a0,32
     384:	00e68733          	add	a4,a3,a4
     388:	40e506b3          	sub	a3,a0,a4
     38c:	00e50c63          	beq	a0,a4,3a4 <__udivdi3+0x68>
     390:	00d795b3          	sll	a1,a5,a3
     394:	00e8d733          	srl	a4,a7,a4
     398:	00d61833          	sll	a6,a2,a3
     39c:	00b765b3          	or	a1,a4,a1
     3a0:	00d89333          	sll	t1,a7,a3
     3a4:	01085893          	srli	a7,a6,0x10
     3a8:	0315d6b3          	divu	a3,a1,a7
     3ac:	01081613          	slli	a2,a6,0x10
     3b0:	01065613          	srli	a2,a2,0x10
     3b4:	01035793          	srli	a5,t1,0x10
     3b8:	0315f733          	remu	a4,a1,a7
     3bc:	00068513          	mv	a0,a3
     3c0:	02d605b3          	mul	a1,a2,a3
     3c4:	01071713          	slli	a4,a4,0x10
     3c8:	00f767b3          	or	a5,a4,a5
     3cc:	00b7fe63          	bgeu	a5,a1,3e8 <__udivdi3+0xac>
     3d0:	010787b3          	add	a5,a5,a6
     3d4:	fff68513          	addi	a0,a3,-1
     3d8:	0107e863          	bltu	a5,a6,3e8 <__udivdi3+0xac>
     3dc:	00b7f663          	bgeu	a5,a1,3e8 <__udivdi3+0xac>
     3e0:	ffe68513          	addi	a0,a3,-2
     3e4:	010787b3          	add	a5,a5,a6
     3e8:	40b787b3          	sub	a5,a5,a1
     3ec:	0317f733          	remu	a4,a5,a7
     3f0:	01031313          	slli	t1,t1,0x10
     3f4:	01035313          	srli	t1,t1,0x10
     3f8:	0317d7b3          	divu	a5,a5,a7
     3fc:	01071713          	slli	a4,a4,0x10
     400:	00676333          	or	t1,a4,t1
     404:	02f606b3          	mul	a3,a2,a5
     408:	00078613          	mv	a2,a5
     40c:	00d37c63          	bgeu	t1,a3,424 <CONFIG_MAIN_STACK_SIZE+0x24>
     410:	00680333          	add	t1,a6,t1
     414:	fff78613          	addi	a2,a5,-1 # ffff <__data_region_end+0x9f43>
     418:	01036663          	bltu	t1,a6,424 <CONFIG_MAIN_STACK_SIZE+0x24>
     41c:	00d37463          	bgeu	t1,a3,424 <CONFIG_MAIN_STACK_SIZE+0x24>
     420:	ffe78613          	addi	a2,a5,-2
     424:	01051513          	slli	a0,a0,0x10
     428:	00c56533          	or	a0,a0,a2
     42c:	00000593          	li	a1,0
     430:	0e40006f          	j	514 <CONFIG_MAIN_STACK_SIZE+0x114>
     434:	01000537          	lui	a0,0x1000
     438:	01000713          	li	a4,16
     43c:	f2a66ce3          	bltu	a2,a0,374 <__udivdi3+0x38>
     440:	01800713          	li	a4,24
     444:	f31ff06f          	j	374 <__udivdi3+0x38>
     448:	00061663          	bnez	a2,454 <CONFIG_MAIN_STACK_SIZE+0x54>
     44c:	00100713          	li	a4,1
     450:	02c75833          	divu	a6,a4,a2
     454:	00010737          	lui	a4,0x10
     458:	0ce87063          	bgeu	a6,a4,518 <CONFIG_MAIN_STACK_SIZE+0x118>
     45c:	0ff00713          	li	a4,255
     460:	01077463          	bgeu	a4,a6,468 <CONFIG_MAIN_STACK_SIZE+0x68>
     464:	00800513          	li	a0,8
     468:	00a85733          	srl	a4,a6,a0
     46c:	00e686b3          	add	a3,a3,a4
     470:	0006c703          	lbu	a4,0(a3)
     474:	02000613          	li	a2,32
     478:	00a70733          	add	a4,a4,a0
     47c:	40e606b3          	sub	a3,a2,a4
     480:	0ae61663          	bne	a2,a4,52c <CONFIG_MAIN_STACK_SIZE+0x12c>
     484:	410787b3          	sub	a5,a5,a6
     488:	00100593          	li	a1,1
     48c:	01085893          	srli	a7,a6,0x10
     490:	01081613          	slli	a2,a6,0x10
     494:	01065613          	srli	a2,a2,0x10
     498:	01035713          	srli	a4,t1,0x10
     49c:	0317f6b3          	remu	a3,a5,a7
     4a0:	0317d7b3          	divu	a5,a5,a7
     4a4:	01069693          	slli	a3,a3,0x10
     4a8:	00e6e733          	or	a4,a3,a4
     4ac:	02f60e33          	mul	t3,a2,a5
     4b0:	00078513          	mv	a0,a5
     4b4:	01c77e63          	bgeu	a4,t3,4d0 <CONFIG_MAIN_STACK_SIZE+0xd0>
     4b8:	01070733          	add	a4,a4,a6
     4bc:	fff78513          	addi	a0,a5,-1
     4c0:	01076863          	bltu	a4,a6,4d0 <CONFIG_MAIN_STACK_SIZE+0xd0>
     4c4:	01c77663          	bgeu	a4,t3,4d0 <CONFIG_MAIN_STACK_SIZE+0xd0>
     4c8:	ffe78513          	addi	a0,a5,-2
     4cc:	01070733          	add	a4,a4,a6
     4d0:	41c70733          	sub	a4,a4,t3
     4d4:	031777b3          	remu	a5,a4,a7
     4d8:	01031313          	slli	t1,t1,0x10
     4dc:	01035313          	srli	t1,t1,0x10
     4e0:	03175733          	divu	a4,a4,a7
     4e4:	01079793          	slli	a5,a5,0x10
     4e8:	0067e333          	or	t1,a5,t1
     4ec:	02e606b3          	mul	a3,a2,a4
     4f0:	00070613          	mv	a2,a4
     4f4:	00d37c63          	bgeu	t1,a3,50c <CONFIG_MAIN_STACK_SIZE+0x10c>
     4f8:	00680333          	add	t1,a6,t1
     4fc:	fff70613          	addi	a2,a4,-1 # ffff <__data_region_end+0x9f43>
     500:	01036663          	bltu	t1,a6,50c <CONFIG_MAIN_STACK_SIZE+0x10c>
     504:	00d37463          	bgeu	t1,a3,50c <CONFIG_MAIN_STACK_SIZE+0x10c>
     508:	ffe70613          	addi	a2,a4,-2
     50c:	01051513          	slli	a0,a0,0x10
     510:	00c56533          	or	a0,a0,a2
     514:	00008067          	ret
     518:	01000737          	lui	a4,0x1000
     51c:	01000513          	li	a0,16
     520:	f4e864e3          	bltu	a6,a4,468 <CONFIG_MAIN_STACK_SIZE+0x68>
     524:	01800513          	li	a0,24
     528:	f41ff06f          	j	468 <CONFIG_MAIN_STACK_SIZE+0x68>
     52c:	00d81833          	sll	a6,a6,a3
     530:	00e7d533          	srl	a0,a5,a4
     534:	00d89333          	sll	t1,a7,a3
     538:	00d797b3          	sll	a5,a5,a3
     53c:	00e8d733          	srl	a4,a7,a4
     540:	01085893          	srli	a7,a6,0x10
     544:	00f76633          	or	a2,a4,a5
     548:	03157733          	remu	a4,a0,a7
     54c:	01081793          	slli	a5,a6,0x10
     550:	0107d793          	srli	a5,a5,0x10
     554:	01065593          	srli	a1,a2,0x10
     558:	03155533          	divu	a0,a0,a7
     55c:	01071713          	slli	a4,a4,0x10
     560:	00b76733          	or	a4,a4,a1
     564:	02a786b3          	mul	a3,a5,a0
     568:	00050593          	mv	a1,a0
     56c:	00d77e63          	bgeu	a4,a3,588 <CONFIG_MAIN_STACK_SIZE+0x188>
     570:	01070733          	add	a4,a4,a6
     574:	fff50593          	addi	a1,a0,-1 # ffffff <__data_region_end+0xff9f43>
     578:	01076863          	bltu	a4,a6,588 <CONFIG_MAIN_STACK_SIZE+0x188>
     57c:	00d77663          	bgeu	a4,a3,588 <CONFIG_MAIN_STACK_SIZE+0x188>
     580:	ffe50593          	addi	a1,a0,-2
     584:	01070733          	add	a4,a4,a6
     588:	40d706b3          	sub	a3,a4,a3
     58c:	0316f733          	remu	a4,a3,a7
     590:	01061613          	slli	a2,a2,0x10
     594:	01065613          	srli	a2,a2,0x10
     598:	0316d6b3          	divu	a3,a3,a7
     59c:	01071713          	slli	a4,a4,0x10
     5a0:	02d78533          	mul	a0,a5,a3
     5a4:	00c767b3          	or	a5,a4,a2
     5a8:	00068713          	mv	a4,a3
     5ac:	00a7fe63          	bgeu	a5,a0,5c8 <CONFIG_MAIN_STACK_SIZE+0x1c8>
     5b0:	010787b3          	add	a5,a5,a6
     5b4:	fff68713          	addi	a4,a3,-1
     5b8:	0107e863          	bltu	a5,a6,5c8 <CONFIG_MAIN_STACK_SIZE+0x1c8>
     5bc:	00a7f663          	bgeu	a5,a0,5c8 <CONFIG_MAIN_STACK_SIZE+0x1c8>
     5c0:	ffe68713          	addi	a4,a3,-2
     5c4:	010787b3          	add	a5,a5,a6
     5c8:	01059593          	slli	a1,a1,0x10
     5cc:	40a787b3          	sub	a5,a5,a0
     5d0:	00e5e5b3          	or	a1,a1,a4
     5d4:	eb9ff06f          	j	48c <CONFIG_MAIN_STACK_SIZE+0x8c>
     5d8:	18d5e663          	bltu	a1,a3,764 <CONFIG_MAIN_STACK_SIZE+0x364>
     5dc:	00010737          	lui	a4,0x10
     5e0:	04e6f463          	bgeu	a3,a4,628 <CONFIG_MAIN_STACK_SIZE+0x228>
     5e4:	0ff00713          	li	a4,255
     5e8:	00d735b3          	sltu	a1,a4,a3
     5ec:	00359593          	slli	a1,a1,0x3
     5f0:	00005737          	lui	a4,0x5
     5f4:	00b6d533          	srl	a0,a3,a1
     5f8:	d4870713          	addi	a4,a4,-696 # 4d48 <__clz_tab>
     5fc:	00a70733          	add	a4,a4,a0
     600:	00074703          	lbu	a4,0(a4)
     604:	02000513          	li	a0,32
     608:	00b70733          	add	a4,a4,a1
     60c:	40e505b3          	sub	a1,a0,a4
     610:	02e51663          	bne	a0,a4,63c <CONFIG_MAIN_STACK_SIZE+0x23c>
     614:	00100513          	li	a0,1
     618:	eef6eee3          	bltu	a3,a5,514 <CONFIG_MAIN_STACK_SIZE+0x114>
     61c:	00c8b533          	sltu	a0,a7,a2
     620:	00154513          	xori	a0,a0,1
     624:	ef1ff06f          	j	514 <CONFIG_MAIN_STACK_SIZE+0x114>
     628:	01000737          	lui	a4,0x1000
     62c:	01000593          	li	a1,16
     630:	fce6e0e3          	bltu	a3,a4,5f0 <CONFIG_MAIN_STACK_SIZE+0x1f0>
     634:	01800593          	li	a1,24
     638:	fb9ff06f          	j	5f0 <CONFIG_MAIN_STACK_SIZE+0x1f0>
     63c:	00e65833          	srl	a6,a2,a4
     640:	00b696b3          	sll	a3,a3,a1
     644:	00d86833          	or	a6,a6,a3
     648:	00e7de33          	srl	t3,a5,a4
     64c:	01085e93          	srli	t4,a6,0x10
     650:	03de76b3          	remu	a3,t3,t4
     654:	00b797b3          	sll	a5,a5,a1
     658:	00e8d733          	srl	a4,a7,a4
     65c:	00b61333          	sll	t1,a2,a1
     660:	00f76633          	or	a2,a4,a5
     664:	01081793          	slli	a5,a6,0x10
     668:	0107d793          	srli	a5,a5,0x10
     66c:	01065713          	srli	a4,a2,0x10
     670:	03de5e33          	divu	t3,t3,t4
     674:	01069693          	slli	a3,a3,0x10
     678:	00e6e733          	or	a4,a3,a4
     67c:	03c78f33          	mul	t5,a5,t3
     680:	000e0513          	mv	a0,t3
     684:	01e77e63          	bgeu	a4,t5,6a0 <CONFIG_MAIN_STACK_SIZE+0x2a0>
     688:	01070733          	add	a4,a4,a6
     68c:	fffe0513          	addi	a0,t3,-1
     690:	01076863          	bltu	a4,a6,6a0 <CONFIG_MAIN_STACK_SIZE+0x2a0>
     694:	01e77663          	bgeu	a4,t5,6a0 <CONFIG_MAIN_STACK_SIZE+0x2a0>
     698:	ffee0513          	addi	a0,t3,-2
     69c:	01070733          	add	a4,a4,a6
     6a0:	41e70733          	sub	a4,a4,t5
     6a4:	03d776b3          	remu	a3,a4,t4
     6a8:	03d75733          	divu	a4,a4,t4
     6ac:	01069693          	slli	a3,a3,0x10
     6b0:	02e78e33          	mul	t3,a5,a4
     6b4:	01061793          	slli	a5,a2,0x10
     6b8:	0107d793          	srli	a5,a5,0x10
     6bc:	00f6e7b3          	or	a5,a3,a5
     6c0:	00070613          	mv	a2,a4
     6c4:	01c7fe63          	bgeu	a5,t3,6e0 <CONFIG_MAIN_STACK_SIZE+0x2e0>
     6c8:	010787b3          	add	a5,a5,a6
     6cc:	fff70613          	addi	a2,a4,-1 # ffffff <__data_region_end+0xff9f43>
     6d0:	0107e863          	bltu	a5,a6,6e0 <CONFIG_MAIN_STACK_SIZE+0x2e0>
     6d4:	01c7f663          	bgeu	a5,t3,6e0 <CONFIG_MAIN_STACK_SIZE+0x2e0>
     6d8:	ffe70613          	addi	a2,a4,-2
     6dc:	010787b3          	add	a5,a5,a6
     6e0:	01051513          	slli	a0,a0,0x10
     6e4:	00010eb7          	lui	t4,0x10
     6e8:	00c56533          	or	a0,a0,a2
     6ec:	fffe8693          	addi	a3,t4,-1 # ffff <__data_region_end+0x9f43>
     6f0:	00d57833          	and	a6,a0,a3
     6f4:	01055613          	srli	a2,a0,0x10
     6f8:	00d376b3          	and	a3,t1,a3
     6fc:	01035313          	srli	t1,t1,0x10
     700:	41c787b3          	sub	a5,a5,t3
     704:	02d80e33          	mul	t3,a6,a3
     708:	02d606b3          	mul	a3,a2,a3
     70c:	010e5713          	srli	a4,t3,0x10
     710:	02680833          	mul	a6,a6,t1
     714:	00d80833          	add	a6,a6,a3
     718:	01070733          	add	a4,a4,a6
     71c:	02660633          	mul	a2,a2,t1
     720:	00d77463          	bgeu	a4,a3,728 <CONFIG_MAIN_STACK_SIZE+0x328>
     724:	01d60633          	add	a2,a2,t4
     728:	01075693          	srli	a3,a4,0x10
     72c:	00c68633          	add	a2,a3,a2
     730:	02c7e663          	bltu	a5,a2,75c <CONFIG_MAIN_STACK_SIZE+0x35c>
     734:	cec79ce3          	bne	a5,a2,42c <CONFIG_MAIN_STACK_SIZE+0x2c>
     738:	000107b7          	lui	a5,0x10
     73c:	fff78793          	addi	a5,a5,-1 # ffff <__data_region_end+0x9f43>
     740:	00f77733          	and	a4,a4,a5
     744:	01071713          	slli	a4,a4,0x10
     748:	00fe7e33          	and	t3,t3,a5
     74c:	00b898b3          	sll	a7,a7,a1
     750:	01c70733          	add	a4,a4,t3
     754:	00000593          	li	a1,0
     758:	dae8fee3          	bgeu	a7,a4,514 <CONFIG_MAIN_STACK_SIZE+0x114>
     75c:	fff50513          	addi	a0,a0,-1
     760:	ccdff06f          	j	42c <CONFIG_MAIN_STACK_SIZE+0x2c>
     764:	00000593          	li	a1,0
     768:	00000513          	li	a0,0
     76c:	da9ff06f          	j	514 <CONFIG_MAIN_STACK_SIZE+0x114>

00000770 <__umoddi3>:
     770:	00050e93          	mv	t4,a0
     774:	00058313          	mv	t1,a1
     778:	00060813          	mv	a6,a2
     77c:	00068793          	mv	a5,a3
     780:	22069a63          	bnez	a3,9b4 <CONFIG_ISR_STACK_SIZE+0x1b4>
     784:	00005737          	lui	a4,0x5
     788:	d4870713          	addi	a4,a4,-696 # 4d48 <__clz_tab>
     78c:	0cc5fc63          	bgeu	a1,a2,864 <CONFIG_ISR_STACK_SIZE+0x64>
     790:	000106b7          	lui	a3,0x10
     794:	0ad67e63          	bgeu	a2,a3,850 <CONFIG_ISR_STACK_SIZE+0x50>
     798:	0ff00693          	li	a3,255
     79c:	00c6f463          	bgeu	a3,a2,7a4 <__umoddi3+0x34>
     7a0:	00800793          	li	a5,8
     7a4:	00f656b3          	srl	a3,a2,a5
     7a8:	00d70733          	add	a4,a4,a3
     7ac:	00074703          	lbu	a4,0(a4)
     7b0:	00f707b3          	add	a5,a4,a5
     7b4:	02000713          	li	a4,32
     7b8:	40f708b3          	sub	a7,a4,a5
     7bc:	00f70c63          	beq	a4,a5,7d4 <__umoddi3+0x64>
     7c0:	011315b3          	sll	a1,t1,a7
     7c4:	00fed7b3          	srl	a5,t4,a5
     7c8:	01161833          	sll	a6,a2,a7
     7cc:	00b7e5b3          	or	a1,a5,a1
     7d0:	011e9533          	sll	a0,t4,a7
     7d4:	01085693          	srli	a3,a6,0x10
     7d8:	02d5f7b3          	remu	a5,a1,a3
     7dc:	01081613          	slli	a2,a6,0x10
     7e0:	01065613          	srli	a2,a2,0x10
     7e4:	01055713          	srli	a4,a0,0x10
     7e8:	02d5d5b3          	divu	a1,a1,a3
     7ec:	01079793          	slli	a5,a5,0x10
     7f0:	00e7e733          	or	a4,a5,a4
     7f4:	02b605b3          	mul	a1,a2,a1
     7f8:	00b77a63          	bgeu	a4,a1,80c <CONFIG_ISR_STACK_SIZE+0xc>
     7fc:	01070733          	add	a4,a4,a6
     800:	01076663          	bltu	a4,a6,80c <CONFIG_ISR_STACK_SIZE+0xc>
     804:	00b77463          	bgeu	a4,a1,80c <CONFIG_ISR_STACK_SIZE+0xc>
     808:	01070733          	add	a4,a4,a6
     80c:	40b70733          	sub	a4,a4,a1
     810:	02d777b3          	remu	a5,a4,a3
     814:	01051513          	slli	a0,a0,0x10
     818:	01055513          	srli	a0,a0,0x10
     81c:	02d75733          	divu	a4,a4,a3
     820:	01079793          	slli	a5,a5,0x10
     824:	00a7e533          	or	a0,a5,a0
     828:	02e60733          	mul	a4,a2,a4
     82c:	00e57a63          	bgeu	a0,a4,840 <CONFIG_ISR_STACK_SIZE+0x40>
     830:	01050533          	add	a0,a0,a6
     834:	01056663          	bltu	a0,a6,840 <CONFIG_ISR_STACK_SIZE+0x40>
     838:	00e57463          	bgeu	a0,a4,840 <CONFIG_ISR_STACK_SIZE+0x40>
     83c:	01050533          	add	a0,a0,a6
     840:	40e50533          	sub	a0,a0,a4
     844:	01155533          	srl	a0,a0,a7
     848:	00000593          	li	a1,0
     84c:	00008067          	ret
     850:	010006b7          	lui	a3,0x1000
     854:	01000793          	li	a5,16
     858:	f4d666e3          	bltu	a2,a3,7a4 <__umoddi3+0x34>
     85c:	01800793          	li	a5,24
     860:	f45ff06f          	j	7a4 <__umoddi3+0x34>
     864:	00061663          	bnez	a2,870 <CONFIG_ISR_STACK_SIZE+0x70>
     868:	00100693          	li	a3,1
     86c:	02c6d833          	divu	a6,a3,a2
     870:	000106b7          	lui	a3,0x10
     874:	12d87663          	bgeu	a6,a3,9a0 <CONFIG_ISR_STACK_SIZE+0x1a0>
     878:	0ff00693          	li	a3,255
     87c:	0106f463          	bgeu	a3,a6,884 <CONFIG_ISR_STACK_SIZE+0x84>
     880:	00800793          	li	a5,8
     884:	00f856b3          	srl	a3,a6,a5
     888:	00d70733          	add	a4,a4,a3
     88c:	00074603          	lbu	a2,0(a4)
     890:	410305b3          	sub	a1,t1,a6
     894:	00f60633          	add	a2,a2,a5
     898:	02000793          	li	a5,32
     89c:	40c788b3          	sub	a7,a5,a2
     8a0:	08c78663          	beq	a5,a2,92c <CONFIG_ISR_STACK_SIZE+0x12c>
     8a4:	01181833          	sll	a6,a6,a7
     8a8:	00c357b3          	srl	a5,t1,a2
     8ac:	011315b3          	sll	a1,t1,a7
     8b0:	01085313          	srli	t1,a6,0x10
     8b4:	00ced633          	srl	a2,t4,a2
     8b8:	00b66633          	or	a2,a2,a1
     8bc:	01081593          	slli	a1,a6,0x10
     8c0:	0105d593          	srli	a1,a1,0x10
     8c4:	011e9533          	sll	a0,t4,a7
     8c8:	0267d6b3          	divu	a3,a5,t1
     8cc:	0267f733          	remu	a4,a5,t1
     8d0:	01065793          	srli	a5,a2,0x10
     8d4:	02d586b3          	mul	a3,a1,a3
     8d8:	01071713          	slli	a4,a4,0x10
     8dc:	00f76733          	or	a4,a4,a5
     8e0:	00d77a63          	bgeu	a4,a3,8f4 <CONFIG_ISR_STACK_SIZE+0xf4>
     8e4:	01070733          	add	a4,a4,a6
     8e8:	01076663          	bltu	a4,a6,8f4 <CONFIG_ISR_STACK_SIZE+0xf4>
     8ec:	00d77463          	bgeu	a4,a3,8f4 <CONFIG_ISR_STACK_SIZE+0xf4>
     8f0:	01070733          	add	a4,a4,a6
     8f4:	40d706b3          	sub	a3,a4,a3
     8f8:	0266f733          	remu	a4,a3,t1
     8fc:	01061613          	slli	a2,a2,0x10
     900:	01065613          	srli	a2,a2,0x10
     904:	0266d6b3          	divu	a3,a3,t1
     908:	01071713          	slli	a4,a4,0x10
     90c:	02d586b3          	mul	a3,a1,a3
     910:	00c765b3          	or	a1,a4,a2
     914:	00d5fa63          	bgeu	a1,a3,928 <CONFIG_ISR_STACK_SIZE+0x128>
     918:	010585b3          	add	a1,a1,a6
     91c:	0105e663          	bltu	a1,a6,928 <CONFIG_ISR_STACK_SIZE+0x128>
     920:	00d5f463          	bgeu	a1,a3,928 <CONFIG_ISR_STACK_SIZE+0x128>
     924:	010585b3          	add	a1,a1,a6
     928:	40d585b3          	sub	a1,a1,a3
     92c:	01085693          	srli	a3,a6,0x10
     930:	02d5f733          	remu	a4,a1,a3
     934:	01081793          	slli	a5,a6,0x10
     938:	0107d793          	srli	a5,a5,0x10
     93c:	01055613          	srli	a2,a0,0x10
     940:	02d5d5b3          	divu	a1,a1,a3
     944:	01071713          	slli	a4,a4,0x10
     948:	00c76733          	or	a4,a4,a2
     94c:	02b785b3          	mul	a1,a5,a1
     950:	00b77a63          	bgeu	a4,a1,964 <CONFIG_ISR_STACK_SIZE+0x164>
     954:	01070733          	add	a4,a4,a6
     958:	01076663          	bltu	a4,a6,964 <CONFIG_ISR_STACK_SIZE+0x164>
     95c:	00b77463          	bgeu	a4,a1,964 <CONFIG_ISR_STACK_SIZE+0x164>
     960:	01070733          	add	a4,a4,a6
     964:	40b705b3          	sub	a1,a4,a1
     968:	02d5f733          	remu	a4,a1,a3
     96c:	01051513          	slli	a0,a0,0x10
     970:	01055513          	srli	a0,a0,0x10
     974:	02d5d5b3          	divu	a1,a1,a3
     978:	02b785b3          	mul	a1,a5,a1
     97c:	01071793          	slli	a5,a4,0x10
     980:	00a7e533          	or	a0,a5,a0
     984:	00b57a63          	bgeu	a0,a1,998 <CONFIG_ISR_STACK_SIZE+0x198>
     988:	01050533          	add	a0,a0,a6
     98c:	01056663          	bltu	a0,a6,998 <CONFIG_ISR_STACK_SIZE+0x198>
     990:	00b57463          	bgeu	a0,a1,998 <CONFIG_ISR_STACK_SIZE+0x198>
     994:	01050533          	add	a0,a0,a6
     998:	40b50533          	sub	a0,a0,a1
     99c:	ea9ff06f          	j	844 <CONFIG_ISR_STACK_SIZE+0x44>
     9a0:	010006b7          	lui	a3,0x1000
     9a4:	01000793          	li	a5,16
     9a8:	ecd86ee3          	bltu	a6,a3,884 <CONFIG_ISR_STACK_SIZE+0x84>
     9ac:	01800793          	li	a5,24
     9b0:	ed5ff06f          	j	884 <CONFIG_ISR_STACK_SIZE+0x84>
     9b4:	e8d5ece3          	bltu	a1,a3,84c <CONFIG_ISR_STACK_SIZE+0x4c>
     9b8:	000107b7          	lui	a5,0x10
     9bc:	04f6f863          	bgeu	a3,a5,a0c <CONFIG_ISR_STACK_SIZE+0x20c>
     9c0:	0ff00893          	li	a7,255
     9c4:	00d8b7b3          	sltu	a5,a7,a3
     9c8:	00379793          	slli	a5,a5,0x3
     9cc:	00005737          	lui	a4,0x5
     9d0:	00f6d833          	srl	a6,a3,a5
     9d4:	d4870713          	addi	a4,a4,-696 # 4d48 <__clz_tab>
     9d8:	01070733          	add	a4,a4,a6
     9dc:	00074883          	lbu	a7,0(a4)
     9e0:	00f888b3          	add	a7,a7,a5
     9e4:	02000793          	li	a5,32
     9e8:	41178833          	sub	a6,a5,a7
     9ec:	03179a63          	bne	a5,a7,a20 <CONFIG_ISR_STACK_SIZE+0x220>
     9f0:	0066e463          	bltu	a3,t1,9f8 <CONFIG_ISR_STACK_SIZE+0x1f8>
     9f4:	e4ceece3          	bltu	t4,a2,84c <CONFIG_ISR_STACK_SIZE+0x4c>
     9f8:	40ce8533          	sub	a0,t4,a2
     9fc:	40d305b3          	sub	a1,t1,a3
     a00:	00aebeb3          	sltu	t4,t4,a0
     a04:	41d585b3          	sub	a1,a1,t4
     a08:	e45ff06f          	j	84c <CONFIG_ISR_STACK_SIZE+0x4c>
     a0c:	01000737          	lui	a4,0x1000
     a10:	01000793          	li	a5,16
     a14:	fae6ece3          	bltu	a3,a4,9cc <CONFIG_ISR_STACK_SIZE+0x1cc>
     a18:	01800793          	li	a5,24
     a1c:	fb1ff06f          	j	9cc <CONFIG_ISR_STACK_SIZE+0x1cc>
     a20:	011657b3          	srl	a5,a2,a7
     a24:	010696b3          	sll	a3,a3,a6
     a28:	00d7ee33          	or	t3,a5,a3
     a2c:	01135f33          	srl	t5,t1,a7
     a30:	011ed7b3          	srl	a5,t4,a7
     a34:	010e9533          	sll	a0,t4,a6
     a38:	010e5e93          	srli	t4,t3,0x10
     a3c:	010315b3          	sll	a1,t1,a6
     a40:	03df5333          	divu	t1,t5,t4
     a44:	00b7e7b3          	or	a5,a5,a1
     a48:	010e1593          	slli	a1,t3,0x10
     a4c:	0105d593          	srli	a1,a1,0x10
     a50:	0107d713          	srli	a4,a5,0x10
     a54:	01061633          	sll	a2,a2,a6
     a58:	03df76b3          	remu	a3,t5,t4
     a5c:	02658f33          	mul	t5,a1,t1
     a60:	01069693          	slli	a3,a3,0x10
     a64:	00e6e733          	or	a4,a3,a4
     a68:	00030693          	mv	a3,t1
     a6c:	01e77e63          	bgeu	a4,t5,a88 <CONFIG_ISR_STACK_SIZE+0x288>
     a70:	01c70733          	add	a4,a4,t3
     a74:	fff30693          	addi	a3,t1,-1
     a78:	01c76863          	bltu	a4,t3,a88 <CONFIG_ISR_STACK_SIZE+0x288>
     a7c:	01e77663          	bgeu	a4,t5,a88 <CONFIG_ISR_STACK_SIZE+0x288>
     a80:	ffe30693          	addi	a3,t1,-2
     a84:	01c70733          	add	a4,a4,t3
     a88:	41e70733          	sub	a4,a4,t5
     a8c:	03d77333          	remu	t1,a4,t4
     a90:	01079793          	slli	a5,a5,0x10
     a94:	0107d793          	srli	a5,a5,0x10
     a98:	03d75733          	divu	a4,a4,t4
     a9c:	01031313          	slli	t1,t1,0x10
     aa0:	00f36333          	or	t1,t1,a5
     aa4:	02e585b3          	mul	a1,a1,a4
     aa8:	00070793          	mv	a5,a4
     aac:	00b37e63          	bgeu	t1,a1,ac8 <CONFIG_ISR_STACK_SIZE+0x2c8>
     ab0:	01c30333          	add	t1,t1,t3
     ab4:	fff70793          	addi	a5,a4,-1 # ffffff <__data_region_end+0xff9f43>
     ab8:	01c36863          	bltu	t1,t3,ac8 <CONFIG_ISR_STACK_SIZE+0x2c8>
     abc:	00b37663          	bgeu	t1,a1,ac8 <CONFIG_ISR_STACK_SIZE+0x2c8>
     ac0:	ffe70793          	addi	a5,a4,-2
     ac4:	01c30333          	add	t1,t1,t3
     ac8:	01069693          	slli	a3,a3,0x10
     acc:	00010f37          	lui	t5,0x10
     ad0:	00f6e6b3          	or	a3,a3,a5
     ad4:	40b305b3          	sub	a1,t1,a1
     ad8:	ffff0313          	addi	t1,t5,-1 # ffff <__data_region_end+0x9f43>
     adc:	0066feb3          	and	t4,a3,t1
     ae0:	01065713          	srli	a4,a2,0x10
     ae4:	0106d693          	srli	a3,a3,0x10
     ae8:	00667333          	and	t1,a2,t1
     aec:	026e87b3          	mul	a5,t4,t1
     af0:	02668333          	mul	t1,a3,t1
     af4:	02ee8eb3          	mul	t4,t4,a4
     af8:	02e686b3          	mul	a3,a3,a4
     afc:	006e8eb3          	add	t4,t4,t1
     b00:	0107d713          	srli	a4,a5,0x10
     b04:	01d70733          	add	a4,a4,t4
     b08:	00677463          	bgeu	a4,t1,b10 <CONFIG_ISR_STACK_SIZE+0x310>
     b0c:	01e686b3          	add	a3,a3,t5
     b10:	01075313          	srli	t1,a4,0x10
     b14:	00d306b3          	add	a3,t1,a3
     b18:	00010337          	lui	t1,0x10
     b1c:	fff30313          	addi	t1,t1,-1 # ffff <__data_region_end+0x9f43>
     b20:	00677733          	and	a4,a4,t1
     b24:	01071713          	slli	a4,a4,0x10
     b28:	0067f7b3          	and	a5,a5,t1
     b2c:	00f707b3          	add	a5,a4,a5
     b30:	00d5e663          	bltu	a1,a3,b3c <CONFIG_ISR_STACK_SIZE+0x33c>
     b34:	00d59e63          	bne	a1,a3,b50 <CONFIG_ISR_STACK_SIZE+0x350>
     b38:	00f57c63          	bgeu	a0,a5,b50 <CONFIG_ISR_STACK_SIZE+0x350>
     b3c:	40c78633          	sub	a2,a5,a2
     b40:	00c7b7b3          	sltu	a5,a5,a2
     b44:	01c787b3          	add	a5,a5,t3
     b48:	40f686b3          	sub	a3,a3,a5
     b4c:	00060793          	mv	a5,a2
     b50:	40f507b3          	sub	a5,a0,a5
     b54:	00f53533          	sltu	a0,a0,a5
     b58:	40d585b3          	sub	a1,a1,a3
     b5c:	40a585b3          	sub	a1,a1,a0
     b60:	011598b3          	sll	a7,a1,a7
     b64:	0107d533          	srl	a0,a5,a6
     b68:	00a8e533          	or	a0,a7,a0
     b6c:	0105d5b3          	srl	a1,a1,a6
     b70:	cddff06f          	j	84c <CONFIG_ISR_STACK_SIZE+0x4c>

00000b74 <__gedf2>:
     b74:	00100737          	lui	a4,0x100
     b78:	fff70713          	addi	a4,a4,-1 # fffff <__data_region_end+0xf9f43>
     b7c:	0145d813          	srli	a6,a1,0x14
     b80:	00b778b3          	and	a7,a4,a1
     b84:	00050793          	mv	a5,a0
     b88:	00050313          	mv	t1,a0
     b8c:	7ff87813          	andi	a6,a6,2047
     b90:	01f5d513          	srli	a0,a1,0x1f
     b94:	7ff00e93          	li	t4,2047
     b98:	0146d593          	srli	a1,a3,0x14
     b9c:	00d77733          	and	a4,a4,a3
     ba0:	00060e13          	mv	t3,a2
     ba4:	7ff5f593          	andi	a1,a1,2047
     ba8:	01f6d693          	srli	a3,a3,0x1f
     bac:	01d81a63          	bne	a6,t4,bc0 <__gedf2+0x4c>
     bb0:	00f8eeb3          	or	t4,a7,a5
     bb4:	080e8a63          	beqz	t4,c48 <__gedf2+0xd4>
     bb8:	ffe00513          	li	a0,-2
     bbc:	00008067          	ret
     bc0:	01d59663          	bne	a1,t4,bcc <__gedf2+0x58>
     bc4:	00c76eb3          	or	t4,a4,a2
     bc8:	fe0e98e3          	bnez	t4,bb8 <__gedf2+0x44>
     bcc:	08081063          	bnez	a6,c4c <__gedf2+0xd8>
     bd0:	00f8e7b3          	or	a5,a7,a5
     bd4:	0017b793          	seqz	a5,a5
     bd8:	00059663          	bnez	a1,be4 <__gedf2+0x70>
     bdc:	00c76633          	or	a2,a4,a2
     be0:	04060c63          	beqz	a2,c38 <__gedf2+0xc4>
     be4:	00079c63          	bnez	a5,bfc <__gedf2+0x88>
     be8:	00d51463          	bne	a0,a3,bf0 <__gedf2+0x7c>
     bec:	0305d063          	bge	a1,a6,c0c <__gedf2+0x98>
     bf0:	04050063          	beqz	a0,c30 <__gedf2+0xbc>
     bf4:	fff00513          	li	a0,-1
     bf8:	00008067          	ret
     bfc:	fff00513          	li	a0,-1
     c00:	00068a63          	beqz	a3,c14 <__gedf2+0xa0>
     c04:	00068513          	mv	a0,a3
     c08:	00008067          	ret
     c0c:	00b85663          	bge	a6,a1,c18 <__gedf2+0xa4>
     c10:	fe0502e3          	beqz	a0,bf4 <__gedf2+0x80>
     c14:	00008067          	ret
     c18:	fd176ce3          	bltu	a4,a7,bf0 <__gedf2+0x7c>
     c1c:	02e89263          	bne	a7,a4,c40 <__gedf2+0xcc>
     c20:	fc6e68e3          	bltu	t3,t1,bf0 <__gedf2+0x7c>
     c24:	ffc366e3          	bltu	t1,t3,c10 <__gedf2+0x9c>
     c28:	00000513          	li	a0,0
     c2c:	00008067          	ret
     c30:	00100513          	li	a0,1
     c34:	00008067          	ret
     c38:	fe0798e3          	bnez	a5,c28 <__gedf2+0xb4>
     c3c:	fb5ff06f          	j	bf0 <__gedf2+0x7c>
     c40:	fce8e8e3          	bltu	a7,a4,c10 <__gedf2+0x9c>
     c44:	fe5ff06f          	j	c28 <__gedf2+0xb4>
     c48:	f7058ee3          	beq	a1,a6,bc4 <__gedf2+0x50>
     c4c:	f8059ee3          	bnez	a1,be8 <__gedf2+0x74>
     c50:	00000793          	li	a5,0
     c54:	f89ff06f          	j	bdc <__gedf2+0x68>

00000c58 <__addsf3>:
     c58:	00800737          	lui	a4,0x800
     c5c:	ff010113          	addi	sp,sp,-16
     c60:	fff70713          	addi	a4,a4,-1 # 7fffff <__data_region_end+0x7f9f43>
     c64:	00a777b3          	and	a5,a4,a0
     c68:	00812423          	sw	s0,8(sp)
     c6c:	00912223          	sw	s1,4(sp)
     c70:	01755413          	srli	s0,a0,0x17
     c74:	01f55493          	srli	s1,a0,0x1f
     c78:	0175d513          	srli	a0,a1,0x17
     c7c:	00b77733          	and	a4,a4,a1
     c80:	0ff47413          	andi	s0,s0,255
     c84:	0ff57513          	andi	a0,a0,255
     c88:	00112623          	sw	ra,12(sp)
     c8c:	01212023          	sw	s2,0(sp)
     c90:	01f5d593          	srli	a1,a1,0x1f
     c94:	00379793          	slli	a5,a5,0x3
     c98:	00371713          	slli	a4,a4,0x3
     c9c:	40a406b3          	sub	a3,s0,a0
     ca0:	18b49a63          	bne	s1,a1,e34 <__addsf3+0x1dc>
     ca4:	0ad05063          	blez	a3,d44 <__addsf3+0xec>
     ca8:	02051663          	bnez	a0,cd4 <__addsf3+0x7c>
     cac:	18070063          	beqz	a4,e2c <__addsf3+0x1d4>
     cb0:	fff68613          	addi	a2,a3,-1 # ffffff <__data_region_end+0xff9f43>
     cb4:	00061863          	bnez	a2,cc4 <__addsf3+0x6c>
     cb8:	00e787b3          	add	a5,a5,a4
     cbc:	00100413          	li	s0,1
     cc0:	0500006f          	j	d10 <__addsf3+0xb8>
     cc4:	0ff00593          	li	a1,255
     cc8:	02b69063          	bne	a3,a1,ce8 <__addsf3+0x90>
     ccc:	0ff00413          	li	s0,255
     cd0:	1180006f          	j	de8 <__addsf3+0x190>
     cd4:	0ff00613          	li	a2,255
     cd8:	10c40863          	beq	s0,a2,de8 <__addsf3+0x190>
     cdc:	04000637          	lui	a2,0x4000
     ce0:	00c76733          	or	a4,a4,a2
     ce4:	00068613          	mv	a2,a3
     ce8:	01b00593          	li	a1,27
     cec:	00100693          	li	a3,1
     cf0:	00c5ce63          	blt	a1,a2,d0c <__addsf3+0xb4>
     cf4:	02000693          	li	a3,32
     cf8:	40c686b3          	sub	a3,a3,a2
     cfc:	00c755b3          	srl	a1,a4,a2
     d00:	00d71733          	sll	a4,a4,a3
     d04:	00e03733          	snez	a4,a4
     d08:	00e5e6b3          	or	a3,a1,a4
     d0c:	00d787b3          	add	a5,a5,a3
     d10:	04000737          	lui	a4,0x4000
     d14:	00e7f733          	and	a4,a5,a4
     d18:	0c070863          	beqz	a4,de8 <__addsf3+0x190>
     d1c:	00140413          	addi	s0,s0,1
     d20:	0ff00713          	li	a4,255
     d24:	30e40263          	beq	s0,a4,1028 <__kernel_ram_size+0x9c>
     d28:	7e000737          	lui	a4,0x7e000
     d2c:	0017f693          	andi	a3,a5,1
     d30:	fff70713          	addi	a4,a4,-1 # 7dffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7b050f7f>
     d34:	0017d793          	srli	a5,a5,0x1
     d38:	00e7f7b3          	and	a5,a5,a4
     d3c:	00d7e7b3          	or	a5,a5,a3
     d40:	0a80006f          	j	de8 <__addsf3+0x190>
     d44:	06068663          	beqz	a3,db0 <__addsf3+0x158>
     d48:	408506b3          	sub	a3,a0,s0
     d4c:	02041063          	bnez	s0,d6c <__addsf3+0x114>
     d50:	2c078263          	beqz	a5,1014 <__kernel_ram_size+0x88>
     d54:	fff68613          	addi	a2,a3,-1
     d58:	f60600e3          	beqz	a2,cb8 <__addsf3+0x60>
     d5c:	0ff00593          	li	a1,255
     d60:	02b69063          	bne	a3,a1,d80 <__addsf3+0x128>
     d64:	00070793          	mv	a5,a4
     d68:	f65ff06f          	j	ccc <__addsf3+0x74>
     d6c:	0ff00613          	li	a2,255
     d70:	fec50ae3          	beq	a0,a2,d64 <__addsf3+0x10c>
     d74:	04000637          	lui	a2,0x4000
     d78:	00c7e7b3          	or	a5,a5,a2
     d7c:	00068613          	mv	a2,a3
     d80:	01b00593          	li	a1,27
     d84:	00100693          	li	a3,1
     d88:	00c5ce63          	blt	a1,a2,da4 <__addsf3+0x14c>
     d8c:	02000693          	li	a3,32
     d90:	40c686b3          	sub	a3,a3,a2
     d94:	00c7d5b3          	srl	a1,a5,a2
     d98:	00d797b3          	sll	a5,a5,a3
     d9c:	00f037b3          	snez	a5,a5
     da0:	00f5e6b3          	or	a3,a1,a5
     da4:	00e687b3          	add	a5,a3,a4
     da8:	00050413          	mv	s0,a0
     dac:	f65ff06f          	j	d10 <__addsf3+0xb8>
     db0:	00140693          	addi	a3,s0,1
     db4:	0fe6f613          	andi	a2,a3,254
     db8:	06061263          	bnez	a2,e1c <__addsf3+0x1c4>
     dbc:	04041463          	bnez	s0,e04 <__addsf3+0x1ac>
     dc0:	24078e63          	beqz	a5,101c <__kernel_ram_size+0x90>
     dc4:	02070263          	beqz	a4,de8 <__addsf3+0x190>
     dc8:	00e787b3          	add	a5,a5,a4
     dcc:	04000737          	lui	a4,0x4000
     dd0:	00e7f733          	and	a4,a5,a4
     dd4:	00070a63          	beqz	a4,de8 <__addsf3+0x190>
     dd8:	fc000737          	lui	a4,0xfc000
     ddc:	fff70713          	addi	a4,a4,-1 # fbffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc000000>
     de0:	00e7f7b3          	and	a5,a5,a4
     de4:	00100413          	li	s0,1
     de8:	0077f713          	andi	a4,a5,7
     dec:	24070063          	beqz	a4,102c <__kernel_ram_size+0xa0>
     df0:	00f7f713          	andi	a4,a5,15
     df4:	00400693          	li	a3,4
     df8:	22d70a63          	beq	a4,a3,102c <__kernel_ram_size+0xa0>
     dfc:	00478793          	addi	a5,a5,4 # 10004 <__data_region_end+0x9f48>
     e00:	22c0006f          	j	102c <__kernel_ram_size+0xa0>
     e04:	f60780e3          	beqz	a5,d64 <__addsf3+0x10c>
     e08:	ec0702e3          	beqz	a4,ccc <__addsf3+0x74>
     e0c:	00000493          	li	s1,0
     e10:	020007b7          	lui	a5,0x2000
     e14:	0ff00413          	li	s0,255
     e18:	2140006f          	j	102c <__kernel_ram_size+0xa0>
     e1c:	0ff00613          	li	a2,255
     e20:	20c68263          	beq	a3,a2,1024 <__kernel_ram_size+0x98>
     e24:	00e787b3          	add	a5,a5,a4
     e28:	0017d793          	srli	a5,a5,0x1
     e2c:	00068413          	mv	s0,a3
     e30:	fb9ff06f          	j	de8 <__addsf3+0x190>
     e34:	08d05063          	blez	a3,eb4 <__addsf3+0x25c>
     e38:	06051263          	bnez	a0,e9c <__addsf3+0x244>
     e3c:	fe0708e3          	beqz	a4,e2c <__addsf3+0x1d4>
     e40:	fff68613          	addi	a2,a3,-1
     e44:	00061863          	bnez	a2,e54 <__addsf3+0x1fc>
     e48:	40e787b3          	sub	a5,a5,a4
     e4c:	00100413          	li	s0,1
     e50:	0340006f          	j	e84 <__addsf3+0x22c>
     e54:	0ff00593          	li	a1,255
     e58:	e6b68ae3          	beq	a3,a1,ccc <__addsf3+0x74>
     e5c:	01b00593          	li	a1,27
     e60:	00100693          	li	a3,1
     e64:	00c5ce63          	blt	a1,a2,e80 <__addsf3+0x228>
     e68:	02000693          	li	a3,32
     e6c:	40c686b3          	sub	a3,a3,a2
     e70:	00c755b3          	srl	a1,a4,a2
     e74:	00d71733          	sll	a4,a4,a3
     e78:	00e03733          	snez	a4,a4
     e7c:	00e5e6b3          	or	a3,a1,a4
     e80:	40d787b3          	sub	a5,a5,a3
     e84:	04000937          	lui	s2,0x4000
     e88:	0127f733          	and	a4,a5,s2
     e8c:	f4070ee3          	beqz	a4,de8 <__addsf3+0x190>
     e90:	fff90913          	addi	s2,s2,-1 # 3ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1050f7f>
     e94:	0127f933          	and	s2,a5,s2
     e98:	1180006f          	j	fb0 <__kernel_ram_size+0x24>
     e9c:	0ff00613          	li	a2,255
     ea0:	f4c404e3          	beq	s0,a2,de8 <__addsf3+0x190>
     ea4:	04000637          	lui	a2,0x4000
     ea8:	00c76733          	or	a4,a4,a2
     eac:	00068613          	mv	a2,a3
     eb0:	fadff06f          	j	e5c <__addsf3+0x204>
     eb4:	08068063          	beqz	a3,f34 <__addsf3+0x2dc>
     eb8:	408506b3          	sub	a3,a0,s0
     ebc:	02041863          	bnez	s0,eec <__addsf3+0x294>
     ec0:	1e078063          	beqz	a5,10a0 <__kernel_ram_size+0x114>
     ec4:	fff68613          	addi	a2,a3,-1
     ec8:	00061863          	bnez	a2,ed8 <__addsf3+0x280>
     ecc:	40f707b3          	sub	a5,a4,a5
     ed0:	00058493          	mv	s1,a1
     ed4:	f79ff06f          	j	e4c <__addsf3+0x1f4>
     ed8:	0ff00813          	li	a6,255
     edc:	03069263          	bne	a3,a6,f00 <__addsf3+0x2a8>
     ee0:	00070793          	mv	a5,a4
     ee4:	0ff00413          	li	s0,255
     ee8:	06c0006f          	j	f54 <__addsf3+0x2fc>
     eec:	0ff00613          	li	a2,255
     ef0:	fec508e3          	beq	a0,a2,ee0 <__addsf3+0x288>
     ef4:	04000637          	lui	a2,0x4000
     ef8:	00c7e7b3          	or	a5,a5,a2
     efc:	00068613          	mv	a2,a3
     f00:	01b00813          	li	a6,27
     f04:	00100693          	li	a3,1
     f08:	00c84e63          	blt	a6,a2,f24 <__addsf3+0x2cc>
     f0c:	02000693          	li	a3,32
     f10:	40c686b3          	sub	a3,a3,a2
     f14:	00c7d833          	srl	a6,a5,a2
     f18:	00d797b3          	sll	a5,a5,a3
     f1c:	00f037b3          	snez	a5,a5
     f20:	00f866b3          	or	a3,a6,a5
     f24:	40d707b3          	sub	a5,a4,a3
     f28:	00050413          	mv	s0,a0
     f2c:	00058493          	mv	s1,a1
     f30:	f55ff06f          	j	e84 <__addsf3+0x22c>
     f34:	00140693          	addi	a3,s0,1
     f38:	0fe6f693          	andi	a3,a3,254
     f3c:	04069e63          	bnez	a3,f98 <__kernel_ram_size+0xc>
     f40:	04041263          	bnez	s0,f84 <__addsf3+0x32c>
     f44:	00079c63          	bnez	a5,f5c <__addsf3+0x304>
     f48:	00000493          	li	s1,0
     f4c:	0e070063          	beqz	a4,102c <__kernel_ram_size+0xa0>
     f50:	00070793          	mv	a5,a4
     f54:	00058493          	mv	s1,a1
     f58:	e91ff06f          	j	de8 <__addsf3+0x190>
     f5c:	e80706e3          	beqz	a4,de8 <__addsf3+0x190>
     f60:	40e786b3          	sub	a3,a5,a4
     f64:	04000637          	lui	a2,0x4000
     f68:	00c6f633          	and	a2,a3,a2
     f6c:	40f707b3          	sub	a5,a4,a5
     f70:	fe0612e3          	bnez	a2,f54 <__addsf3+0x2fc>
     f74:	00000793          	li	a5,0
     f78:	08068063          	beqz	a3,ff8 <__kernel_ram_size+0x6c>
     f7c:	00068793          	mv	a5,a3
     f80:	e69ff06f          	j	de8 <__addsf3+0x190>
     f84:	e80792e3          	bnez	a5,e08 <__addsf3+0x1b0>
     f88:	e80702e3          	beqz	a4,e0c <__addsf3+0x1b4>
     f8c:	00070793          	mv	a5,a4
     f90:	00058493          	mv	s1,a1
     f94:	d39ff06f          	j	ccc <__addsf3+0x74>
     f98:	40e78933          	sub	s2,a5,a4
     f9c:	040006b7          	lui	a3,0x4000
     fa0:	00d976b3          	and	a3,s2,a3
     fa4:	04068463          	beqz	a3,fec <__kernel_ram_size+0x60>
     fa8:	40f70933          	sub	s2,a4,a5
     fac:	00058493          	mv	s1,a1
     fb0:	00090513          	mv	a0,s2
     fb4:	b3cff0ef          	jal	ra,2f0 <__clzsi2>
     fb8:	ffb50513          	addi	a0,a0,-5
     fbc:	00a91933          	sll	s2,s2,a0
     fc0:	04854063          	blt	a0,s0,1000 <__kernel_ram_size+0x74>
     fc4:	40850533          	sub	a0,a0,s0
     fc8:	00150513          	addi	a0,a0,1
     fcc:	02000413          	li	s0,32
     fd0:	00a957b3          	srl	a5,s2,a0
     fd4:	40a40533          	sub	a0,s0,a0
     fd8:	00a91933          	sll	s2,s2,a0
     fdc:	01203933          	snez	s2,s2
     fe0:	0127e7b3          	or	a5,a5,s2
     fe4:	00000413          	li	s0,0
     fe8:	e01ff06f          	j	de8 <__addsf3+0x190>
     fec:	fc0912e3          	bnez	s2,fb0 <__kernel_ram_size+0x24>
     ff0:	00000793          	li	a5,0
     ff4:	00000413          	li	s0,0
     ff8:	00000493          	li	s1,0
     ffc:	0300006f          	j	102c <__kernel_ram_size+0xa0>
    1000:	fc0007b7          	lui	a5,0xfc000
    1004:	fff78793          	addi	a5,a5,-1 # fbffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc000000>
    1008:	40a40433          	sub	s0,s0,a0
    100c:	00f977b3          	and	a5,s2,a5
    1010:	dd9ff06f          	j	de8 <__addsf3+0x190>
    1014:	00070793          	mv	a5,a4
    1018:	e15ff06f          	j	e2c <__addsf3+0x1d4>
    101c:	00070793          	mv	a5,a4
    1020:	dc9ff06f          	j	de8 <__addsf3+0x190>
    1024:	0ff00413          	li	s0,255
    1028:	00000793          	li	a5,0
    102c:	04000737          	lui	a4,0x4000
    1030:	00e7f733          	and	a4,a5,a4
    1034:	00070e63          	beqz	a4,1050 <__kernel_ram_size+0xc4>
    1038:	00140413          	addi	s0,s0,1
    103c:	0ff00713          	li	a4,255
    1040:	06e40663          	beq	s0,a4,10ac <__kernel_ram_size+0x120>
    1044:	fc000737          	lui	a4,0xfc000
    1048:	fff70713          	addi	a4,a4,-1 # fbffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc000000>
    104c:	00e7f7b3          	and	a5,a5,a4
    1050:	0ff00713          	li	a4,255
    1054:	0037d793          	srli	a5,a5,0x3
    1058:	00e41863          	bne	s0,a4,1068 <__kernel_ram_size+0xdc>
    105c:	00078663          	beqz	a5,1068 <__kernel_ram_size+0xdc>
    1060:	004007b7          	lui	a5,0x400
    1064:	00000493          	li	s1,0
    1068:	7f800537          	lui	a0,0x7f800
    106c:	01741413          	slli	s0,s0,0x17
    1070:	00979793          	slli	a5,a5,0x9
    1074:	00a47433          	and	s0,s0,a0
    1078:	0097d793          	srli	a5,a5,0x9
    107c:	00c12083          	lw	ra,12(sp)
    1080:	00f467b3          	or	a5,s0,a5
    1084:	00812403          	lw	s0,8(sp)
    1088:	01f49513          	slli	a0,s1,0x1f
    108c:	00012903          	lw	s2,0(sp)
    1090:	00412483          	lw	s1,4(sp)
    1094:	00a7e533          	or	a0,a5,a0
    1098:	01010113          	addi	sp,sp,16
    109c:	00008067          	ret
    10a0:	00070793          	mv	a5,a4
    10a4:	00068413          	mv	s0,a3
    10a8:	eadff06f          	j	f54 <__addsf3+0x2fc>
    10ac:	00000793          	li	a5,0
    10b0:	fa1ff06f          	j	1050 <__kernel_ram_size+0xc4>

000010b4 <__divsf3>:
    10b4:	fe010113          	addi	sp,sp,-32
    10b8:	00912a23          	sw	s1,20(sp)
    10bc:	01755493          	srli	s1,a0,0x17
    10c0:	01212823          	sw	s2,16(sp)
    10c4:	01312623          	sw	s3,12(sp)
    10c8:	01412423          	sw	s4,8(sp)
    10cc:	00951993          	slli	s3,a0,0x9
    10d0:	00112e23          	sw	ra,28(sp)
    10d4:	00812c23          	sw	s0,24(sp)
    10d8:	01512223          	sw	s5,4(sp)
    10dc:	0ff4f493          	andi	s1,s1,255
    10e0:	00058a13          	mv	s4,a1
    10e4:	0099d993          	srli	s3,s3,0x9
    10e8:	01f55913          	srli	s2,a0,0x1f
    10ec:	08048463          	beqz	s1,1174 <__divsf3+0xc0>
    10f0:	0ff00793          	li	a5,255
    10f4:	0af48063          	beq	s1,a5,1194 <__divsf3+0xe0>
    10f8:	00399993          	slli	s3,s3,0x3
    10fc:	040007b7          	lui	a5,0x4000
    1100:	00f9e9b3          	or	s3,s3,a5
    1104:	f8148493          	addi	s1,s1,-127
    1108:	00000a93          	li	s5,0
    110c:	017a5513          	srli	a0,s4,0x17
    1110:	009a1413          	slli	s0,s4,0x9
    1114:	0ff57513          	andi	a0,a0,255
    1118:	00945413          	srli	s0,s0,0x9
    111c:	01fa5a13          	srli	s4,s4,0x1f
    1120:	08050a63          	beqz	a0,11b4 <__divsf3+0x100>
    1124:	0ff00793          	li	a5,255
    1128:	0af50663          	beq	a0,a5,11d4 <__divsf3+0x120>
    112c:	00341413          	slli	s0,s0,0x3
    1130:	040007b7          	lui	a5,0x4000
    1134:	00f46433          	or	s0,s0,a5
    1138:	f8150513          	addi	a0,a0,-127 # 7f7fff81 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7c850f01>
    113c:	00000793          	li	a5,0
    1140:	002a9693          	slli	a3,s5,0x2
    1144:	00f6e6b3          	or	a3,a3,a5
    1148:	fff68693          	addi	a3,a3,-1 # 3ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1050f7f>
    114c:	00e00713          	li	a4,14
    1150:	01494633          	xor	a2,s2,s4
    1154:	40a48533          	sub	a0,s1,a0
    1158:	08d76e63          	bltu	a4,a3,11f4 <__divsf3+0x140>
    115c:	00005737          	lui	a4,0x5
    1160:	e4870713          	addi	a4,a4,-440 # 4e48 <__clz_tab+0x100>
    1164:	00269693          	slli	a3,a3,0x2
    1168:	00e686b3          	add	a3,a3,a4
    116c:	0006a703          	lw	a4,0(a3)
    1170:	00070067          	jr	a4
    1174:	02098a63          	beqz	s3,11a8 <__divsf3+0xf4>
    1178:	00098513          	mv	a0,s3
    117c:	974ff0ef          	jal	ra,2f0 <__clzsi2>
    1180:	ffb50793          	addi	a5,a0,-5
    1184:	f8a00493          	li	s1,-118
    1188:	00f999b3          	sll	s3,s3,a5
    118c:	40a484b3          	sub	s1,s1,a0
    1190:	f79ff06f          	j	1108 <__divsf3+0x54>
    1194:	0ff00493          	li	s1,255
    1198:	00200a93          	li	s5,2
    119c:	f60988e3          	beqz	s3,110c <__divsf3+0x58>
    11a0:	00300a93          	li	s5,3
    11a4:	f69ff06f          	j	110c <__divsf3+0x58>
    11a8:	00000493          	li	s1,0
    11ac:	00100a93          	li	s5,1
    11b0:	f5dff06f          	j	110c <__divsf3+0x58>
    11b4:	02040a63          	beqz	s0,11e8 <__divsf3+0x134>
    11b8:	00040513          	mv	a0,s0
    11bc:	934ff0ef          	jal	ra,2f0 <__clzsi2>
    11c0:	ffb50793          	addi	a5,a0,-5
    11c4:	00f41433          	sll	s0,s0,a5
    11c8:	f8a00793          	li	a5,-118
    11cc:	40a78533          	sub	a0,a5,a0
    11d0:	f6dff06f          	j	113c <__divsf3+0x88>
    11d4:	0ff00513          	li	a0,255
    11d8:	00200793          	li	a5,2
    11dc:	f60402e3          	beqz	s0,1140 <__divsf3+0x8c>
    11e0:	00300793          	li	a5,3
    11e4:	f5dff06f          	j	1140 <__divsf3+0x8c>
    11e8:	00000513          	li	a0,0
    11ec:	00100793          	li	a5,1
    11f0:	f51ff06f          	j	1140 <__divsf3+0x8c>
    11f4:	00541813          	slli	a6,s0,0x5
    11f8:	1289f463          	bgeu	s3,s0,1320 <__divsf3+0x26c>
    11fc:	fff50513          	addi	a0,a0,-1
    1200:	00000693          	li	a3,0
    1204:	01085413          	srli	s0,a6,0x10
    1208:	0289d333          	divu	t1,s3,s0
    120c:	000107b7          	lui	a5,0x10
    1210:	fff78793          	addi	a5,a5,-1 # ffff <__data_region_end+0x9f43>
    1214:	00f877b3          	and	a5,a6,a5
    1218:	0106d693          	srli	a3,a3,0x10
    121c:	0289f733          	remu	a4,s3,s0
    1220:	00030593          	mv	a1,t1
    1224:	026788b3          	mul	a7,a5,t1
    1228:	01071713          	slli	a4,a4,0x10
    122c:	00e6e733          	or	a4,a3,a4
    1230:	01177e63          	bgeu	a4,a7,124c <__divsf3+0x198>
    1234:	01070733          	add	a4,a4,a6
    1238:	fff30593          	addi	a1,t1,-1
    123c:	01076863          	bltu	a4,a6,124c <__divsf3+0x198>
    1240:	01177663          	bgeu	a4,a7,124c <__divsf3+0x198>
    1244:	ffe30593          	addi	a1,t1,-2
    1248:	01070733          	add	a4,a4,a6
    124c:	41170733          	sub	a4,a4,a7
    1250:	028758b3          	divu	a7,a4,s0
    1254:	02877733          	remu	a4,a4,s0
    1258:	031786b3          	mul	a3,a5,a7
    125c:	01071793          	slli	a5,a4,0x10
    1260:	00088713          	mv	a4,a7
    1264:	00d7fe63          	bgeu	a5,a3,1280 <__divsf3+0x1cc>
    1268:	010787b3          	add	a5,a5,a6
    126c:	fff88713          	addi	a4,a7,-1
    1270:	0107e863          	bltu	a5,a6,1280 <__divsf3+0x1cc>
    1274:	00d7f663          	bgeu	a5,a3,1280 <__divsf3+0x1cc>
    1278:	ffe88713          	addi	a4,a7,-2
    127c:	010787b3          	add	a5,a5,a6
    1280:	01059413          	slli	s0,a1,0x10
    1284:	40d787b3          	sub	a5,a5,a3
    1288:	00e46433          	or	s0,s0,a4
    128c:	00f037b3          	snez	a5,a5
    1290:	00f46433          	or	s0,s0,a5
    1294:	07f50713          	addi	a4,a0,127
    1298:	0ce05e63          	blez	a4,1374 <__divsf3+0x2c0>
    129c:	00747793          	andi	a5,s0,7
    12a0:	00078a63          	beqz	a5,12b4 <__divsf3+0x200>
    12a4:	00f47793          	andi	a5,s0,15
    12a8:	00400693          	li	a3,4
    12ac:	00d78463          	beq	a5,a3,12b4 <__divsf3+0x200>
    12b0:	00440413          	addi	s0,s0,4
    12b4:	080007b7          	lui	a5,0x8000
    12b8:	00f477b3          	and	a5,s0,a5
    12bc:	00078a63          	beqz	a5,12d0 <__divsf3+0x21c>
    12c0:	f80007b7          	lui	a5,0xf8000
    12c4:	fff78793          	addi	a5,a5,-1 # f7ffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf8000000>
    12c8:	00f47433          	and	s0,s0,a5
    12cc:	08050713          	addi	a4,a0,128
    12d0:	0fe00793          	li	a5,254
    12d4:	00345413          	srli	s0,s0,0x3
    12d8:	06e7cc63          	blt	a5,a4,1350 <__divsf3+0x29c>
    12dc:	01771793          	slli	a5,a4,0x17
    12e0:	00941413          	slli	s0,s0,0x9
    12e4:	7f800737          	lui	a4,0x7f800
    12e8:	00e7f7b3          	and	a5,a5,a4
    12ec:	00945413          	srli	s0,s0,0x9
    12f0:	0087e433          	or	s0,a5,s0
    12f4:	01f61513          	slli	a0,a2,0x1f
    12f8:	01c12083          	lw	ra,28(sp)
    12fc:	00a46533          	or	a0,s0,a0
    1300:	01812403          	lw	s0,24(sp)
    1304:	01412483          	lw	s1,20(sp)
    1308:	01012903          	lw	s2,16(sp)
    130c:	00c12983          	lw	s3,12(sp)
    1310:	00812a03          	lw	s4,8(sp)
    1314:	00412a83          	lw	s5,4(sp)
    1318:	02010113          	addi	sp,sp,32
    131c:	00008067          	ret
    1320:	01f99693          	slli	a3,s3,0x1f
    1324:	0019d993          	srli	s3,s3,0x1
    1328:	eddff06f          	j	1204 <__divsf3+0x150>
    132c:	00090613          	mv	a2,s2
    1330:	00098413          	mv	s0,s3
    1334:	000a8793          	mv	a5,s5
    1338:	00300713          	li	a4,3
    133c:	08e78863          	beq	a5,a4,13cc <__divsf3+0x318>
    1340:	00100713          	li	a4,1
    1344:	08e78c63          	beq	a5,a4,13dc <__divsf3+0x328>
    1348:	00200713          	li	a4,2
    134c:	f4e794e3          	bne	a5,a4,1294 <__divsf3+0x1e0>
    1350:	00000413          	li	s0,0
    1354:	0ff00713          	li	a4,255
    1358:	f85ff06f          	j	12dc <__divsf3+0x228>
    135c:	000a0613          	mv	a2,s4
    1360:	fd9ff06f          	j	1338 <__divsf3+0x284>
    1364:	00400437          	lui	s0,0x400
    1368:	00000613          	li	a2,0
    136c:	00300793          	li	a5,3
    1370:	fc9ff06f          	j	1338 <__divsf3+0x284>
    1374:	00100793          	li	a5,1
    1378:	40e787b3          	sub	a5,a5,a4
    137c:	01b00713          	li	a4,27
    1380:	04f74e63          	blt	a4,a5,13dc <__divsf3+0x328>
    1384:	09e50513          	addi	a0,a0,158
    1388:	00f457b3          	srl	a5,s0,a5
    138c:	00a41433          	sll	s0,s0,a0
    1390:	00803433          	snez	s0,s0
    1394:	0087e433          	or	s0,a5,s0
    1398:	00747793          	andi	a5,s0,7
    139c:	00078a63          	beqz	a5,13b0 <__divsf3+0x2fc>
    13a0:	00f47793          	andi	a5,s0,15
    13a4:	00400713          	li	a4,4
    13a8:	00e78463          	beq	a5,a4,13b0 <__divsf3+0x2fc>
    13ac:	00440413          	addi	s0,s0,4 # 400004 <__data_region_end+0x3f9f48>
    13b0:	040007b7          	lui	a5,0x4000
    13b4:	00f477b3          	and	a5,s0,a5
    13b8:	00345413          	srli	s0,s0,0x3
    13bc:	02078263          	beqz	a5,13e0 <__divsf3+0x32c>
    13c0:	00000413          	li	s0,0
    13c4:	00100713          	li	a4,1
    13c8:	f15ff06f          	j	12dc <__divsf3+0x228>
    13cc:	00400437          	lui	s0,0x400
    13d0:	0ff00713          	li	a4,255
    13d4:	00000613          	li	a2,0
    13d8:	f05ff06f          	j	12dc <__divsf3+0x228>
    13dc:	00000413          	li	s0,0
    13e0:	00000713          	li	a4,0
    13e4:	ef9ff06f          	j	12dc <__divsf3+0x228>

000013e8 <__mulsf3>:
    13e8:	fe010113          	addi	sp,sp,-32
    13ec:	01212823          	sw	s2,16(sp)
    13f0:	01755913          	srli	s2,a0,0x17
    13f4:	00912a23          	sw	s1,20(sp)
    13f8:	01312623          	sw	s3,12(sp)
    13fc:	01412423          	sw	s4,8(sp)
    1400:	00951493          	slli	s1,a0,0x9
    1404:	00112e23          	sw	ra,28(sp)
    1408:	00812c23          	sw	s0,24(sp)
    140c:	01512223          	sw	s5,4(sp)
    1410:	0ff97913          	andi	s2,s2,255
    1414:	00058a13          	mv	s4,a1
    1418:	0094d493          	srli	s1,s1,0x9
    141c:	01f55993          	srli	s3,a0,0x1f
    1420:	08090663          	beqz	s2,14ac <__mulsf3+0xc4>
    1424:	0ff00793          	li	a5,255
    1428:	0af90263          	beq	s2,a5,14cc <__mulsf3+0xe4>
    142c:	00349493          	slli	s1,s1,0x3
    1430:	040007b7          	lui	a5,0x4000
    1434:	00f4e4b3          	or	s1,s1,a5
    1438:	f8190913          	addi	s2,s2,-127
    143c:	00000a93          	li	s5,0
    1440:	017a5513          	srli	a0,s4,0x17
    1444:	009a1413          	slli	s0,s4,0x9
    1448:	0ff57513          	andi	a0,a0,255
    144c:	00945413          	srli	s0,s0,0x9
    1450:	01fa5a13          	srli	s4,s4,0x1f
    1454:	08050c63          	beqz	a0,14ec <__mulsf3+0x104>
    1458:	0ff00793          	li	a5,255
    145c:	0af50863          	beq	a0,a5,150c <__mulsf3+0x124>
    1460:	00341413          	slli	s0,s0,0x3
    1464:	040007b7          	lui	a5,0x4000
    1468:	00f46433          	or	s0,s0,a5
    146c:	f8150513          	addi	a0,a0,-127
    1470:	00000793          	li	a5,0
    1474:	002a9713          	slli	a4,s5,0x2
    1478:	00f76733          	or	a4,a4,a5
    147c:	00a90533          	add	a0,s2,a0
    1480:	fff70713          	addi	a4,a4,-1 # 7f7fffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7c850f7f>
    1484:	00e00593          	li	a1,14
    1488:	0149c6b3          	xor	a3,s3,s4
    148c:	00150613          	addi	a2,a0,1
    1490:	08e5ee63          	bltu	a1,a4,152c <__mulsf3+0x144>
    1494:	000055b7          	lui	a1,0x5
    1498:	00271713          	slli	a4,a4,0x2
    149c:	e8458593          	addi	a1,a1,-380 # 4e84 <__clz_tab+0x13c>
    14a0:	00b70733          	add	a4,a4,a1
    14a4:	00072703          	lw	a4,0(a4)
    14a8:	00070067          	jr	a4
    14ac:	02048a63          	beqz	s1,14e0 <__mulsf3+0xf8>
    14b0:	00048513          	mv	a0,s1
    14b4:	e3dfe0ef          	jal	ra,2f0 <__clzsi2>
    14b8:	ffb50793          	addi	a5,a0,-5
    14bc:	f8a00913          	li	s2,-118
    14c0:	00f494b3          	sll	s1,s1,a5
    14c4:	40a90933          	sub	s2,s2,a0
    14c8:	f75ff06f          	j	143c <__mulsf3+0x54>
    14cc:	0ff00913          	li	s2,255
    14d0:	00200a93          	li	s5,2
    14d4:	f60486e3          	beqz	s1,1440 <__mulsf3+0x58>
    14d8:	00300a93          	li	s5,3
    14dc:	f65ff06f          	j	1440 <__mulsf3+0x58>
    14e0:	00000913          	li	s2,0
    14e4:	00100a93          	li	s5,1
    14e8:	f59ff06f          	j	1440 <__mulsf3+0x58>
    14ec:	02040a63          	beqz	s0,1520 <__mulsf3+0x138>
    14f0:	00040513          	mv	a0,s0
    14f4:	dfdfe0ef          	jal	ra,2f0 <__clzsi2>
    14f8:	ffb50793          	addi	a5,a0,-5
    14fc:	00f41433          	sll	s0,s0,a5
    1500:	f8a00793          	li	a5,-118
    1504:	40a78533          	sub	a0,a5,a0
    1508:	f69ff06f          	j	1470 <__mulsf3+0x88>
    150c:	0ff00513          	li	a0,255
    1510:	00200793          	li	a5,2
    1514:	f60400e3          	beqz	s0,1474 <__mulsf3+0x8c>
    1518:	00300793          	li	a5,3
    151c:	f59ff06f          	j	1474 <__mulsf3+0x8c>
    1520:	00000513          	li	a0,0
    1524:	00100793          	li	a5,1
    1528:	f4dff06f          	j	1474 <__mulsf3+0x8c>
    152c:	000107b7          	lui	a5,0x10
    1530:	fff78313          	addi	t1,a5,-1 # ffff <__data_region_end+0x9f43>
    1534:	0104d713          	srli	a4,s1,0x10
    1538:	01045593          	srli	a1,s0,0x10
    153c:	0064f4b3          	and	s1,s1,t1
    1540:	00647433          	and	s0,s0,t1
    1544:	029408b3          	mul	a7,s0,s1
    1548:	02870833          	mul	a6,a4,s0
    154c:	02b70433          	mul	s0,a4,a1
    1550:	029585b3          	mul	a1,a1,s1
    1554:	0108d493          	srli	s1,a7,0x10
    1558:	010585b3          	add	a1,a1,a6
    155c:	00b484b3          	add	s1,s1,a1
    1560:	0104f463          	bgeu	s1,a6,1568 <__mulsf3+0x180>
    1564:	00f40433          	add	s0,s0,a5
    1568:	0064f7b3          	and	a5,s1,t1
    156c:	01079793          	slli	a5,a5,0x10
    1570:	0068f8b3          	and	a7,a7,t1
    1574:	011787b3          	add	a5,a5,a7
    1578:	00679713          	slli	a4,a5,0x6
    157c:	0104d493          	srli	s1,s1,0x10
    1580:	00e03733          	snez	a4,a4
    1584:	01a7d793          	srli	a5,a5,0x1a
    1588:	00848433          	add	s0,s1,s0
    158c:	00f767b3          	or	a5,a4,a5
    1590:	00641413          	slli	s0,s0,0x6
    1594:	00f46433          	or	s0,s0,a5
    1598:	080007b7          	lui	a5,0x8000
    159c:	00f477b3          	and	a5,s0,a5
    15a0:	08078e63          	beqz	a5,163c <__mulsf3+0x254>
    15a4:	00145793          	srli	a5,s0,0x1
    15a8:	00147413          	andi	s0,s0,1
    15ac:	0087e433          	or	s0,a5,s0
    15b0:	07f60713          	addi	a4,a2,127 # 400007f <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1050fff>
    15b4:	08e05863          	blez	a4,1644 <__mulsf3+0x25c>
    15b8:	00747793          	andi	a5,s0,7
    15bc:	00078a63          	beqz	a5,15d0 <__mulsf3+0x1e8>
    15c0:	00f47793          	andi	a5,s0,15
    15c4:	00400593          	li	a1,4
    15c8:	00b78463          	beq	a5,a1,15d0 <__mulsf3+0x1e8>
    15cc:	00440413          	addi	s0,s0,4 # 400004 <__data_region_end+0x3f9f48>
    15d0:	080007b7          	lui	a5,0x8000
    15d4:	00f477b3          	and	a5,s0,a5
    15d8:	00078a63          	beqz	a5,15ec <__mulsf3+0x204>
    15dc:	f80007b7          	lui	a5,0xf8000
    15e0:	fff78793          	addi	a5,a5,-1 # f7ffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf8000000>
    15e4:	00f47433          	and	s0,s0,a5
    15e8:	08060713          	addi	a4,a2,128
    15ec:	0fe00793          	li	a5,254
    15f0:	00345413          	srli	s0,s0,0x3
    15f4:	0ae7da63          	bge	a5,a4,16a8 <__mulsf3+0x2c0>
    15f8:	00000413          	li	s0,0
    15fc:	0ff00713          	li	a4,255
    1600:	0a80006f          	j	16a8 <__mulsf3+0x2c0>
    1604:	00098693          	mv	a3,s3
    1608:	00048413          	mv	s0,s1
    160c:	000a8793          	mv	a5,s5
    1610:	00200713          	li	a4,2
    1614:	fee782e3          	beq	a5,a4,15f8 <__mulsf3+0x210>
    1618:	00300713          	li	a4,3
    161c:	08e78063          	beq	a5,a4,169c <__mulsf3+0x2b4>
    1620:	00100713          	li	a4,1
    1624:	f8e796e3          	bne	a5,a4,15b0 <__mulsf3+0x1c8>
    1628:	00000413          	li	s0,0
    162c:	00000713          	li	a4,0
    1630:	0780006f          	j	16a8 <__mulsf3+0x2c0>
    1634:	000a0693          	mv	a3,s4
    1638:	fd9ff06f          	j	1610 <__mulsf3+0x228>
    163c:	00050613          	mv	a2,a0
    1640:	f71ff06f          	j	15b0 <__mulsf3+0x1c8>
    1644:	00100793          	li	a5,1
    1648:	40e787b3          	sub	a5,a5,a4
    164c:	01b00713          	li	a4,27
    1650:	fcf74ce3          	blt	a4,a5,1628 <__mulsf3+0x240>
    1654:	09e60613          	addi	a2,a2,158
    1658:	00f457b3          	srl	a5,s0,a5
    165c:	00c41433          	sll	s0,s0,a2
    1660:	00803433          	snez	s0,s0
    1664:	0087e433          	or	s0,a5,s0
    1668:	00747793          	andi	a5,s0,7
    166c:	00078a63          	beqz	a5,1680 <__mulsf3+0x298>
    1670:	00f47793          	andi	a5,s0,15
    1674:	00400713          	li	a4,4
    1678:	00e78463          	beq	a5,a4,1680 <__mulsf3+0x298>
    167c:	00440413          	addi	s0,s0,4
    1680:	040007b7          	lui	a5,0x4000
    1684:	00f477b3          	and	a5,s0,a5
    1688:	00345413          	srli	s0,s0,0x3
    168c:	fa0780e3          	beqz	a5,162c <__mulsf3+0x244>
    1690:	00000413          	li	s0,0
    1694:	00100713          	li	a4,1
    1698:	0100006f          	j	16a8 <__mulsf3+0x2c0>
    169c:	00400437          	lui	s0,0x400
    16a0:	0ff00713          	li	a4,255
    16a4:	00000693          	li	a3,0
    16a8:	01771793          	slli	a5,a4,0x17
    16ac:	00941413          	slli	s0,s0,0x9
    16b0:	7f800737          	lui	a4,0x7f800
    16b4:	00e7f7b3          	and	a5,a5,a4
    16b8:	00945413          	srli	s0,s0,0x9
    16bc:	0087e433          	or	s0,a5,s0
    16c0:	01f69513          	slli	a0,a3,0x1f
    16c4:	01c12083          	lw	ra,28(sp)
    16c8:	00a46533          	or	a0,s0,a0
    16cc:	01812403          	lw	s0,24(sp)
    16d0:	01412483          	lw	s1,20(sp)
    16d4:	01012903          	lw	s2,16(sp)
    16d8:	00c12983          	lw	s3,12(sp)
    16dc:	00812a03          	lw	s4,8(sp)
    16e0:	00412a83          	lw	s5,4(sp)
    16e4:	02010113          	addi	sp,sp,32
    16e8:	00008067          	ret

000016ec <__subsf3>:
    16ec:	00800737          	lui	a4,0x800
    16f0:	ff010113          	addi	sp,sp,-16
    16f4:	fff70713          	addi	a4,a4,-1 # 7fffff <__data_region_end+0x7f9f43>
    16f8:	0175d613          	srli	a2,a1,0x17
    16fc:	00a777b3          	and	a5,a4,a0
    1700:	00812423          	sw	s0,8(sp)
    1704:	00b77733          	and	a4,a4,a1
    1708:	00912223          	sw	s1,4(sp)
    170c:	01755413          	srli	s0,a0,0x17
    1710:	00112623          	sw	ra,12(sp)
    1714:	01212023          	sw	s2,0(sp)
    1718:	0ff67613          	andi	a2,a2,255
    171c:	0ff00693          	li	a3,255
    1720:	0ff47413          	andi	s0,s0,255
    1724:	01f55493          	srli	s1,a0,0x1f
    1728:	00379793          	slli	a5,a5,0x3
    172c:	01f5d593          	srli	a1,a1,0x1f
    1730:	00371713          	slli	a4,a4,0x3
    1734:	00d61463          	bne	a2,a3,173c <__subsf3+0x50>
    1738:	00071463          	bnez	a4,1740 <__subsf3+0x54>
    173c:	0015c593          	xori	a1,a1,1
    1740:	40c406b3          	sub	a3,s0,a2
    1744:	18959a63          	bne	a1,s1,18d8 <__subsf3+0x1ec>
    1748:	0ad05063          	blez	a3,17e8 <__subsf3+0xfc>
    174c:	02061663          	bnez	a2,1778 <__subsf3+0x8c>
    1750:	18070063          	beqz	a4,18d0 <__subsf3+0x1e4>
    1754:	fff68613          	addi	a2,a3,-1
    1758:	00061863          	bnez	a2,1768 <__subsf3+0x7c>
    175c:	00e787b3          	add	a5,a5,a4
    1760:	00100413          	li	s0,1
    1764:	0500006f          	j	17b4 <__subsf3+0xc8>
    1768:	0ff00593          	li	a1,255
    176c:	02b69063          	bne	a3,a1,178c <__subsf3+0xa0>
    1770:	0ff00413          	li	s0,255
    1774:	1180006f          	j	188c <__subsf3+0x1a0>
    1778:	0ff00613          	li	a2,255
    177c:	10c40863          	beq	s0,a2,188c <__subsf3+0x1a0>
    1780:	04000637          	lui	a2,0x4000
    1784:	00c76733          	or	a4,a4,a2
    1788:	00068613          	mv	a2,a3
    178c:	01b00593          	li	a1,27
    1790:	00100693          	li	a3,1
    1794:	00c5ce63          	blt	a1,a2,17b0 <__subsf3+0xc4>
    1798:	02000693          	li	a3,32
    179c:	40c686b3          	sub	a3,a3,a2
    17a0:	00c755b3          	srl	a1,a4,a2
    17a4:	00d71733          	sll	a4,a4,a3
    17a8:	00e03733          	snez	a4,a4
    17ac:	00e5e6b3          	or	a3,a1,a4
    17b0:	00d787b3          	add	a5,a5,a3
    17b4:	04000737          	lui	a4,0x4000
    17b8:	00e7f733          	and	a4,a5,a4
    17bc:	0c070863          	beqz	a4,188c <__subsf3+0x1a0>
    17c0:	00140413          	addi	s0,s0,1 # 400001 <__data_region_end+0x3f9f45>
    17c4:	0ff00713          	li	a4,255
    17c8:	30e40263          	beq	s0,a4,1acc <__subsf3+0x3e0>
    17cc:	7e000737          	lui	a4,0x7e000
    17d0:	0017f693          	andi	a3,a5,1
    17d4:	fff70713          	addi	a4,a4,-1 # 7dffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7b050f7f>
    17d8:	0017d793          	srli	a5,a5,0x1
    17dc:	00e7f7b3          	and	a5,a5,a4
    17e0:	00d7e7b3          	or	a5,a5,a3
    17e4:	0a80006f          	j	188c <__subsf3+0x1a0>
    17e8:	06068663          	beqz	a3,1854 <__subsf3+0x168>
    17ec:	408606b3          	sub	a3,a2,s0
    17f0:	02041063          	bnez	s0,1810 <__subsf3+0x124>
    17f4:	2c078263          	beqz	a5,1ab8 <__subsf3+0x3cc>
    17f8:	fff68593          	addi	a1,a3,-1
    17fc:	f60580e3          	beqz	a1,175c <__subsf3+0x70>
    1800:	0ff00513          	li	a0,255
    1804:	02a69063          	bne	a3,a0,1824 <__subsf3+0x138>
    1808:	00070793          	mv	a5,a4
    180c:	f65ff06f          	j	1770 <__subsf3+0x84>
    1810:	0ff00593          	li	a1,255
    1814:	feb60ae3          	beq	a2,a1,1808 <__subsf3+0x11c>
    1818:	040005b7          	lui	a1,0x4000
    181c:	00b7e7b3          	or	a5,a5,a1
    1820:	00068593          	mv	a1,a3
    1824:	01b00513          	li	a0,27
    1828:	00100693          	li	a3,1
    182c:	00b54e63          	blt	a0,a1,1848 <__subsf3+0x15c>
    1830:	02000693          	li	a3,32
    1834:	40b686b3          	sub	a3,a3,a1
    1838:	00b7d533          	srl	a0,a5,a1
    183c:	00d797b3          	sll	a5,a5,a3
    1840:	00f037b3          	snez	a5,a5
    1844:	00f566b3          	or	a3,a0,a5
    1848:	00e687b3          	add	a5,a3,a4
    184c:	00060413          	mv	s0,a2
    1850:	f65ff06f          	j	17b4 <__subsf3+0xc8>
    1854:	00140693          	addi	a3,s0,1
    1858:	0fe6f613          	andi	a2,a3,254
    185c:	06061263          	bnez	a2,18c0 <__subsf3+0x1d4>
    1860:	04041463          	bnez	s0,18a8 <__subsf3+0x1bc>
    1864:	24078e63          	beqz	a5,1ac0 <__subsf3+0x3d4>
    1868:	02070263          	beqz	a4,188c <__subsf3+0x1a0>
    186c:	00e787b3          	add	a5,a5,a4
    1870:	04000737          	lui	a4,0x4000
    1874:	00e7f733          	and	a4,a5,a4
    1878:	00070a63          	beqz	a4,188c <__subsf3+0x1a0>
    187c:	fc000737          	lui	a4,0xfc000
    1880:	fff70713          	addi	a4,a4,-1 # fbffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc000000>
    1884:	00e7f7b3          	and	a5,a5,a4
    1888:	00100413          	li	s0,1
    188c:	0077f713          	andi	a4,a5,7
    1890:	24070063          	beqz	a4,1ad0 <__subsf3+0x3e4>
    1894:	00f7f713          	andi	a4,a5,15
    1898:	00400693          	li	a3,4
    189c:	22d70a63          	beq	a4,a3,1ad0 <__subsf3+0x3e4>
    18a0:	00478793          	addi	a5,a5,4 # 4000004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1050f84>
    18a4:	22c0006f          	j	1ad0 <__subsf3+0x3e4>
    18a8:	f60780e3          	beqz	a5,1808 <__subsf3+0x11c>
    18ac:	ec0702e3          	beqz	a4,1770 <__subsf3+0x84>
    18b0:	00000493          	li	s1,0
    18b4:	020007b7          	lui	a5,0x2000
    18b8:	0ff00413          	li	s0,255
    18bc:	2140006f          	j	1ad0 <__subsf3+0x3e4>
    18c0:	0ff00613          	li	a2,255
    18c4:	20c68263          	beq	a3,a2,1ac8 <__subsf3+0x3dc>
    18c8:	00e787b3          	add	a5,a5,a4
    18cc:	0017d793          	srli	a5,a5,0x1
    18d0:	00068413          	mv	s0,a3
    18d4:	fb9ff06f          	j	188c <__subsf3+0x1a0>
    18d8:	08d05063          	blez	a3,1958 <__subsf3+0x26c>
    18dc:	06061263          	bnez	a2,1940 <__subsf3+0x254>
    18e0:	fe0708e3          	beqz	a4,18d0 <__subsf3+0x1e4>
    18e4:	fff68613          	addi	a2,a3,-1
    18e8:	00061863          	bnez	a2,18f8 <__subsf3+0x20c>
    18ec:	40e787b3          	sub	a5,a5,a4
    18f0:	00100413          	li	s0,1
    18f4:	0340006f          	j	1928 <__subsf3+0x23c>
    18f8:	0ff00593          	li	a1,255
    18fc:	e6b68ae3          	beq	a3,a1,1770 <__subsf3+0x84>
    1900:	01b00593          	li	a1,27
    1904:	00100693          	li	a3,1
    1908:	00c5ce63          	blt	a1,a2,1924 <__subsf3+0x238>
    190c:	02000693          	li	a3,32
    1910:	40c686b3          	sub	a3,a3,a2
    1914:	00c755b3          	srl	a1,a4,a2
    1918:	00d71733          	sll	a4,a4,a3
    191c:	00e03733          	snez	a4,a4
    1920:	00e5e6b3          	or	a3,a1,a4
    1924:	40d787b3          	sub	a5,a5,a3
    1928:	04000937          	lui	s2,0x4000
    192c:	0127f733          	and	a4,a5,s2
    1930:	f4070ee3          	beqz	a4,188c <__subsf3+0x1a0>
    1934:	fff90913          	addi	s2,s2,-1 # 3ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1050f7f>
    1938:	0127f933          	and	s2,a5,s2
    193c:	1180006f          	j	1a54 <__subsf3+0x368>
    1940:	0ff00613          	li	a2,255
    1944:	f4c404e3          	beq	s0,a2,188c <__subsf3+0x1a0>
    1948:	04000637          	lui	a2,0x4000
    194c:	00c76733          	or	a4,a4,a2
    1950:	00068613          	mv	a2,a3
    1954:	fadff06f          	j	1900 <__subsf3+0x214>
    1958:	08068063          	beqz	a3,19d8 <__subsf3+0x2ec>
    195c:	408606b3          	sub	a3,a2,s0
    1960:	02041863          	bnez	s0,1990 <__subsf3+0x2a4>
    1964:	1e078063          	beqz	a5,1b44 <__subsf3+0x458>
    1968:	fff68513          	addi	a0,a3,-1
    196c:	00051863          	bnez	a0,197c <__subsf3+0x290>
    1970:	40f707b3          	sub	a5,a4,a5
    1974:	00058493          	mv	s1,a1
    1978:	f79ff06f          	j	18f0 <__subsf3+0x204>
    197c:	0ff00813          	li	a6,255
    1980:	03069263          	bne	a3,a6,19a4 <__subsf3+0x2b8>
    1984:	00070793          	mv	a5,a4
    1988:	0ff00413          	li	s0,255
    198c:	06c0006f          	j	19f8 <__subsf3+0x30c>
    1990:	0ff00513          	li	a0,255
    1994:	fea608e3          	beq	a2,a0,1984 <__subsf3+0x298>
    1998:	04000537          	lui	a0,0x4000
    199c:	00a7e7b3          	or	a5,a5,a0
    19a0:	00068513          	mv	a0,a3
    19a4:	01b00813          	li	a6,27
    19a8:	00100693          	li	a3,1
    19ac:	00a84e63          	blt	a6,a0,19c8 <__subsf3+0x2dc>
    19b0:	02000693          	li	a3,32
    19b4:	40a686b3          	sub	a3,a3,a0
    19b8:	00a7d833          	srl	a6,a5,a0
    19bc:	00d797b3          	sll	a5,a5,a3
    19c0:	00f037b3          	snez	a5,a5
    19c4:	00f866b3          	or	a3,a6,a5
    19c8:	40d707b3          	sub	a5,a4,a3
    19cc:	00060413          	mv	s0,a2
    19d0:	00058493          	mv	s1,a1
    19d4:	f55ff06f          	j	1928 <__subsf3+0x23c>
    19d8:	00140693          	addi	a3,s0,1
    19dc:	0fe6f693          	andi	a3,a3,254
    19e0:	04069e63          	bnez	a3,1a3c <__subsf3+0x350>
    19e4:	04041263          	bnez	s0,1a28 <__subsf3+0x33c>
    19e8:	00079c63          	bnez	a5,1a00 <__subsf3+0x314>
    19ec:	00000493          	li	s1,0
    19f0:	0e070063          	beqz	a4,1ad0 <__subsf3+0x3e4>
    19f4:	00070793          	mv	a5,a4
    19f8:	00058493          	mv	s1,a1
    19fc:	e91ff06f          	j	188c <__subsf3+0x1a0>
    1a00:	e80706e3          	beqz	a4,188c <__subsf3+0x1a0>
    1a04:	40e786b3          	sub	a3,a5,a4
    1a08:	04000637          	lui	a2,0x4000
    1a0c:	00c6f633          	and	a2,a3,a2
    1a10:	40f707b3          	sub	a5,a4,a5
    1a14:	fe0612e3          	bnez	a2,19f8 <__subsf3+0x30c>
    1a18:	00000793          	li	a5,0
    1a1c:	08068063          	beqz	a3,1a9c <__subsf3+0x3b0>
    1a20:	00068793          	mv	a5,a3
    1a24:	e69ff06f          	j	188c <__subsf3+0x1a0>
    1a28:	e80792e3          	bnez	a5,18ac <__subsf3+0x1c0>
    1a2c:	e80702e3          	beqz	a4,18b0 <__subsf3+0x1c4>
    1a30:	00070793          	mv	a5,a4
    1a34:	00058493          	mv	s1,a1
    1a38:	d39ff06f          	j	1770 <__subsf3+0x84>
    1a3c:	40e78933          	sub	s2,a5,a4
    1a40:	040006b7          	lui	a3,0x4000
    1a44:	00d976b3          	and	a3,s2,a3
    1a48:	04068463          	beqz	a3,1a90 <__subsf3+0x3a4>
    1a4c:	40f70933          	sub	s2,a4,a5
    1a50:	00058493          	mv	s1,a1
    1a54:	00090513          	mv	a0,s2
    1a58:	899fe0ef          	jal	ra,2f0 <__clzsi2>
    1a5c:	ffb50513          	addi	a0,a0,-5 # 3fffffb <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1050f7b>
    1a60:	00a91933          	sll	s2,s2,a0
    1a64:	04854063          	blt	a0,s0,1aa4 <__subsf3+0x3b8>
    1a68:	40850533          	sub	a0,a0,s0
    1a6c:	00150513          	addi	a0,a0,1
    1a70:	02000413          	li	s0,32
    1a74:	00a957b3          	srl	a5,s2,a0
    1a78:	40a40533          	sub	a0,s0,a0
    1a7c:	00a91933          	sll	s2,s2,a0
    1a80:	01203933          	snez	s2,s2
    1a84:	0127e7b3          	or	a5,a5,s2
    1a88:	00000413          	li	s0,0
    1a8c:	e01ff06f          	j	188c <__subsf3+0x1a0>
    1a90:	fc0912e3          	bnez	s2,1a54 <__subsf3+0x368>
    1a94:	00000793          	li	a5,0
    1a98:	00000413          	li	s0,0
    1a9c:	00000493          	li	s1,0
    1aa0:	0300006f          	j	1ad0 <__subsf3+0x3e4>
    1aa4:	fc0007b7          	lui	a5,0xfc000
    1aa8:	fff78793          	addi	a5,a5,-1 # fbffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc000000>
    1aac:	40a40433          	sub	s0,s0,a0
    1ab0:	00f977b3          	and	a5,s2,a5
    1ab4:	dd9ff06f          	j	188c <__subsf3+0x1a0>
    1ab8:	00070793          	mv	a5,a4
    1abc:	e15ff06f          	j	18d0 <__subsf3+0x1e4>
    1ac0:	00070793          	mv	a5,a4
    1ac4:	dc9ff06f          	j	188c <__subsf3+0x1a0>
    1ac8:	0ff00413          	li	s0,255
    1acc:	00000793          	li	a5,0
    1ad0:	04000737          	lui	a4,0x4000
    1ad4:	00e7f733          	and	a4,a5,a4
    1ad8:	00070e63          	beqz	a4,1af4 <__subsf3+0x408>
    1adc:	00140413          	addi	s0,s0,1
    1ae0:	0ff00713          	li	a4,255
    1ae4:	06e40663          	beq	s0,a4,1b50 <__subsf3+0x464>
    1ae8:	fc000737          	lui	a4,0xfc000
    1aec:	fff70713          	addi	a4,a4,-1 # fbffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc000000>
    1af0:	00e7f7b3          	and	a5,a5,a4
    1af4:	0ff00713          	li	a4,255
    1af8:	0037d793          	srli	a5,a5,0x3
    1afc:	00e41863          	bne	s0,a4,1b0c <__subsf3+0x420>
    1b00:	00078663          	beqz	a5,1b0c <__subsf3+0x420>
    1b04:	004007b7          	lui	a5,0x400
    1b08:	00000493          	li	s1,0
    1b0c:	7f800537          	lui	a0,0x7f800
    1b10:	01741413          	slli	s0,s0,0x17
    1b14:	00979793          	slli	a5,a5,0x9
    1b18:	00a47433          	and	s0,s0,a0
    1b1c:	0097d793          	srli	a5,a5,0x9
    1b20:	00c12083          	lw	ra,12(sp)
    1b24:	00f467b3          	or	a5,s0,a5
    1b28:	00812403          	lw	s0,8(sp)
    1b2c:	01f49513          	slli	a0,s1,0x1f
    1b30:	00012903          	lw	s2,0(sp)
    1b34:	00412483          	lw	s1,4(sp)
    1b38:	00a7e533          	or	a0,a5,a0
    1b3c:	01010113          	addi	sp,sp,16
    1b40:	00008067          	ret
    1b44:	00070793          	mv	a5,a4
    1b48:	00068413          	mv	s0,a3
    1b4c:	eadff06f          	j	19f8 <__subsf3+0x30c>
    1b50:	00000793          	li	a5,0
    1b54:	fa1ff06f          	j	1af4 <__subsf3+0x408>

00001b58 <__fixsfsi>:
    1b58:	00800637          	lui	a2,0x800
    1b5c:	01755713          	srli	a4,a0,0x17
    1b60:	fff60793          	addi	a5,a2,-1 # 7fffff <__data_region_end+0x7f9f43>
    1b64:	0ff77713          	andi	a4,a4,255
    1b68:	07e00593          	li	a1,126
    1b6c:	00a7f7b3          	and	a5,a5,a0
    1b70:	01f55693          	srli	a3,a0,0x1f
    1b74:	04e5d663          	bge	a1,a4,1bc0 <__fixsfsi+0x68>
    1b78:	09d00593          	li	a1,157
    1b7c:	00e5da63          	bge	a1,a4,1b90 <__fixsfsi+0x38>
    1b80:	80000537          	lui	a0,0x80000
    1b84:	fff54513          	not	a0,a0
    1b88:	00a68533          	add	a0,a3,a0
    1b8c:	00008067          	ret
    1b90:	00c7e533          	or	a0,a5,a2
    1b94:	09500793          	li	a5,149
    1b98:	00e7dc63          	bge	a5,a4,1bb0 <__fixsfsi+0x58>
    1b9c:	f6a70713          	addi	a4,a4,-150
    1ba0:	00e51533          	sll	a0,a0,a4
    1ba4:	02068063          	beqz	a3,1bc4 <__fixsfsi+0x6c>
    1ba8:	40a00533          	neg	a0,a0
    1bac:	00008067          	ret
    1bb0:	09600793          	li	a5,150
    1bb4:	40e78733          	sub	a4,a5,a4
    1bb8:	00e55533          	srl	a0,a0,a4
    1bbc:	fe9ff06f          	j	1ba4 <__fixsfsi+0x4c>
    1bc0:	00000513          	li	a0,0
    1bc4:	00008067          	ret

00001bc8 <__floatsisf>:
    1bc8:	ff010113          	addi	sp,sp,-16
    1bcc:	00112623          	sw	ra,12(sp)
    1bd0:	00812423          	sw	s0,8(sp)
    1bd4:	00912223          	sw	s1,4(sp)
    1bd8:	0e050663          	beqz	a0,1cc4 <__floatsisf+0xfc>
    1bdc:	41f55793          	srai	a5,a0,0x1f
    1be0:	00a7c433          	xor	s0,a5,a0
    1be4:	40f40433          	sub	s0,s0,a5
    1be8:	01f55493          	srli	s1,a0,0x1f
    1bec:	00040513          	mv	a0,s0
    1bf0:	f00fe0ef          	jal	ra,2f0 <__clzsi2>
    1bf4:	09e00793          	li	a5,158
    1bf8:	00050713          	mv	a4,a0
    1bfc:	40a78533          	sub	a0,a5,a0
    1c00:	09600793          	li	a5,150
    1c04:	04a7c063          	blt	a5,a0,1c44 <__floatsisf+0x7c>
    1c08:	00800793          	li	a5,8
    1c0c:	00e7d663          	bge	a5,a4,1c18 <__floatsisf+0x50>
    1c10:	ff870713          	addi	a4,a4,-8
    1c14:	00e41433          	sll	s0,s0,a4
    1c18:	00941413          	slli	s0,s0,0x9
    1c1c:	01751513          	slli	a0,a0,0x17
    1c20:	00945413          	srli	s0,s0,0x9
    1c24:	00856433          	or	s0,a0,s0
    1c28:	01f49513          	slli	a0,s1,0x1f
    1c2c:	00c12083          	lw	ra,12(sp)
    1c30:	00a46533          	or	a0,s0,a0
    1c34:	00812403          	lw	s0,8(sp)
    1c38:	00412483          	lw	s1,4(sp)
    1c3c:	01010113          	addi	sp,sp,16
    1c40:	00008067          	ret
    1c44:	09900793          	li	a5,153
    1c48:	02a7d063          	bge	a5,a0,1c68 <__floatsisf+0xa0>
    1c4c:	00500793          	li	a5,5
    1c50:	40e787b3          	sub	a5,a5,a4
    1c54:	01b70693          	addi	a3,a4,27
    1c58:	00f457b3          	srl	a5,s0,a5
    1c5c:	00d41433          	sll	s0,s0,a3
    1c60:	00803433          	snez	s0,s0
    1c64:	0087e433          	or	s0,a5,s0
    1c68:	00500793          	li	a5,5
    1c6c:	00e7d663          	bge	a5,a4,1c78 <__floatsisf+0xb0>
    1c70:	ffb70793          	addi	a5,a4,-5
    1c74:	00f41433          	sll	s0,s0,a5
    1c78:	fc0006b7          	lui	a3,0xfc000
    1c7c:	fff68693          	addi	a3,a3,-1 # fbffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc000000>
    1c80:	00747793          	andi	a5,s0,7
    1c84:	00d476b3          	and	a3,s0,a3
    1c88:	00078a63          	beqz	a5,1c9c <__floatsisf+0xd4>
    1c8c:	00f47413          	andi	s0,s0,15
    1c90:	00400793          	li	a5,4
    1c94:	00f40463          	beq	s0,a5,1c9c <__floatsisf+0xd4>
    1c98:	00468693          	addi	a3,a3,4
    1c9c:	040007b7          	lui	a5,0x4000
    1ca0:	00f6f7b3          	and	a5,a3,a5
    1ca4:	00078c63          	beqz	a5,1cbc <__floatsisf+0xf4>
    1ca8:	fc0007b7          	lui	a5,0xfc000
    1cac:	fff78793          	addi	a5,a5,-1 # fbffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc000000>
    1cb0:	00f6f6b3          	and	a3,a3,a5
    1cb4:	09f00793          	li	a5,159
    1cb8:	40e78533          	sub	a0,a5,a4
    1cbc:	0036d413          	srli	s0,a3,0x3
    1cc0:	f59ff06f          	j	1c18 <__floatsisf+0x50>
    1cc4:	00000493          	li	s1,0
    1cc8:	00000413          	li	s0,0
    1ccc:	f4dff06f          	j	1c18 <__floatsisf+0x50>

00001cd0 <__extendsfdf2>:
    1cd0:	01755713          	srli	a4,a0,0x17
    1cd4:	0ff77713          	andi	a4,a4,255
    1cd8:	ff010113          	addi	sp,sp,-16
    1cdc:	00170793          	addi	a5,a4,1
    1ce0:	00812423          	sw	s0,8(sp)
    1ce4:	00912223          	sw	s1,4(sp)
    1ce8:	00951413          	slli	s0,a0,0x9
    1cec:	00112623          	sw	ra,12(sp)
    1cf0:	0fe7f793          	andi	a5,a5,254
    1cf4:	00945413          	srli	s0,s0,0x9
    1cf8:	01f55493          	srli	s1,a0,0x1f
    1cfc:	04078263          	beqz	a5,1d40 <__extendsfdf2+0x70>
    1d00:	00345793          	srli	a5,s0,0x3
    1d04:	38070713          	addi	a4,a4,896
    1d08:	01d41413          	slli	s0,s0,0x1d
    1d0c:	00c79793          	slli	a5,a5,0xc
    1d10:	01471713          	slli	a4,a4,0x14
    1d14:	00c7d793          	srli	a5,a5,0xc
    1d18:	01f49513          	slli	a0,s1,0x1f
    1d1c:	00f767b3          	or	a5,a4,a5
    1d20:	00c12083          	lw	ra,12(sp)
    1d24:	00a7e733          	or	a4,a5,a0
    1d28:	00040513          	mv	a0,s0
    1d2c:	00812403          	lw	s0,8(sp)
    1d30:	00412483          	lw	s1,4(sp)
    1d34:	00070593          	mv	a1,a4
    1d38:	01010113          	addi	sp,sp,16
    1d3c:	00008067          	ret
    1d40:	04071663          	bnez	a4,1d8c <__extendsfdf2+0xbc>
    1d44:	00000793          	li	a5,0
    1d48:	fc0402e3          	beqz	s0,1d0c <__extendsfdf2+0x3c>
    1d4c:	00040513          	mv	a0,s0
    1d50:	da0fe0ef          	jal	ra,2f0 <__clzsi2>
    1d54:	00a00793          	li	a5,10
    1d58:	02a7c263          	blt	a5,a0,1d7c <__extendsfdf2+0xac>
    1d5c:	00b00793          	li	a5,11
    1d60:	40a787b3          	sub	a5,a5,a0
    1d64:	01550713          	addi	a4,a0,21 # 80000015 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000016>
    1d68:	00f457b3          	srl	a5,s0,a5
    1d6c:	00e41433          	sll	s0,s0,a4
    1d70:	38900713          	li	a4,905
    1d74:	40a70733          	sub	a4,a4,a0
    1d78:	f95ff06f          	j	1d0c <__extendsfdf2+0x3c>
    1d7c:	ff550793          	addi	a5,a0,-11
    1d80:	00f417b3          	sll	a5,s0,a5
    1d84:	00000413          	li	s0,0
    1d88:	fe9ff06f          	j	1d70 <__extendsfdf2+0xa0>
    1d8c:	00000793          	li	a5,0
    1d90:	00040a63          	beqz	s0,1da4 <__extendsfdf2+0xd4>
    1d94:	00345793          	srli	a5,s0,0x3
    1d98:	00080737          	lui	a4,0x80
    1d9c:	01d41413          	slli	s0,s0,0x1d
    1da0:	00e7e7b3          	or	a5,a5,a4
    1da4:	7ff00713          	li	a4,2047
    1da8:	f65ff06f          	j	1d0c <__extendsfdf2+0x3c>

00001dac <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
    1dac:	00008067          	ret

00001db0 <create_mat>:

    return 0;
}

void create_mat(int address, int rows, int cols)
{
    1db0:	fd010113          	addi	sp,sp,-48
    float *matrix = (float *)address;

    for (int i=0; i<rows; i++) {
        for (int j=0; j<cols; j++) {
            int random_integer = sys_rand32_get()%1000;
            matrix[i*cols+j] = (float)random_integer / 10;
    1db4:	000057b7          	lui	a5,0x5
{
    1db8:	01812423          	sw	s8,8(sp)
            matrix[i*cols+j] = (float)random_integer / 10;
    1dbc:	d387ac03          	lw	s8,-712(a5) # 4d38 <__device_handles_end+0xc>
{
    1dc0:	02912223          	sw	s1,36(sp)
    1dc4:	01312e23          	sw	s3,28(sp)
    1dc8:	01412c23          	sw	s4,24(sp)
    1dcc:	01512a23          	sw	s5,20(sp)
    1dd0:	01612823          	sw	s6,16(sp)
    1dd4:	01712623          	sw	s7,12(sp)
    1dd8:	02112623          	sw	ra,44(sp)
    1ddc:	02812423          	sw	s0,40(sp)
    1de0:	03212023          	sw	s2,32(sp)
    1de4:	00050993          	mv	s3,a0
    1de8:	00058b13          	mv	s6,a1
    1dec:	00060493          	mv	s1,a2
    for (int i=0; i<rows; i++) {
    1df0:	00000a13          	li	s4,0
    1df4:	00000a93          	li	s5,0
            int random_integer = sys_rand32_get()%1000;
    1df8:	3e800b93          	li	s7,1000
    for (int i=0; i<rows; i++) {
    1dfc:	056ad263          	bge	s5,s6,1e40 <create_mat+0x90>
    1e00:	002a1413          	slli	s0,s4,0x2
    1e04:	01340433          	add	s0,s0,s3
        for (int j=0; j<cols; j++) {
    1e08:	00000913          	li	s2,0
    1e0c:	0240006f          	j	1e30 <create_mat+0x80>
		/* coverity[OVERRUN] */
		return (uint32_t) arch_syscall_invoke0(K_SYSCALL_SYS_RAND32_GET);
	}
#endif
	compiler_barrier();
	return z_impl_sys_rand32_get();
    1e10:	398010ef          	jal	ra,31a8 <z_impl_sys_rand32_get>
            matrix[i*cols+j] = (float)random_integer / 10;
    1e14:	03757533          	remu	a0,a0,s7
        for (int j=0; j<cols; j++) {
    1e18:	00190913          	addi	s2,s2,1
    1e1c:	00440413          	addi	s0,s0,4
            matrix[i*cols+j] = (float)random_integer / 10;
    1e20:	da9ff0ef          	jal	ra,1bc8 <__floatsisf>
    1e24:	000c0593          	mv	a1,s8
    1e28:	a8cff0ef          	jal	ra,10b4 <__divsf3>
    1e2c:	fea42e23          	sw	a0,-4(s0)
        for (int j=0; j<cols; j++) {
    1e30:	fe9940e3          	blt	s2,s1,1e10 <create_mat+0x60>
    for (int i=0; i<rows; i++) {
    1e34:	001a8a93          	addi	s5,s5,1
    1e38:	009a0a33          	add	s4,s4,s1
    1e3c:	fc1ff06f          	j	1dfc <create_mat+0x4c>
        }
    }
}
    1e40:	02c12083          	lw	ra,44(sp)
    1e44:	02812403          	lw	s0,40(sp)
    1e48:	02412483          	lw	s1,36(sp)
    1e4c:	02012903          	lw	s2,32(sp)
    1e50:	01c12983          	lw	s3,28(sp)
    1e54:	01812a03          	lw	s4,24(sp)
    1e58:	01412a83          	lw	s5,20(sp)
    1e5c:	01012b03          	lw	s6,16(sp)
    1e60:	00c12b83          	lw	s7,12(sp)
    1e64:	00812c03          	lw	s8,8(sp)
    1e68:	03010113          	addi	sp,sp,48
    1e6c:	00008067          	ret

00001e70 <print_mat>:

void print_mat(float *matrix, int rows, int cols)
{
    1e70:	fd010113          	addi	sp,sp,-48
    1e74:	02912223          	sw	s1,36(sp)
    1e78:	01312e23          	sw	s3,28(sp)
    1e7c:	01412c23          	sw	s4,24(sp)
    1e80:	01512a23          	sw	s5,20(sp)
    1e84:	01612823          	sw	s6,16(sp)
    1e88:	01712623          	sw	s7,12(sp)
    1e8c:	01812423          	sw	s8,8(sp)
    1e90:	02112623          	sw	ra,44(sp)
    1e94:	02812423          	sw	s0,40(sp)
    1e98:	03212023          	sw	s2,32(sp)
    1e9c:	00050993          	mv	s3,a0
    1ea0:	00058b13          	mv	s6,a1
    1ea4:	00060493          	mv	s1,a2
    for (int i=0; i<rows; i++) {
    1ea8:	00000a13          	li	s4,0
    1eac:	00000a93          	li	s5,0
        for (int j=0; j<cols; j++) {
            printk("%d\t", (int)matrix[i*cols+j]);
    1eb0:	00005bb7          	lui	s7,0x5
        }
        printk("\n");
    1eb4:	00005c37          	lui	s8,0x5
    for (int i=0; i<rows; i++) {
    1eb8:	056ad463          	bge	s5,s6,1f00 <print_mat+0x90>
    1ebc:	002a1413          	slli	s0,s4,0x2
    1ec0:	00898433          	add	s0,s3,s0
        for (int j=0; j<cols; j++) {
    1ec4:	00000913          	li	s2,0
    1ec8:	0200006f          	j	1ee8 <print_mat+0x78>
            printk("%d\t", (int)matrix[i*cols+j]);
    1ecc:	00042503          	lw	a0,0(s0)
        for (int j=0; j<cols; j++) {
    1ed0:	00190913          	addi	s2,s2,1
    1ed4:	00440413          	addi	s0,s0,4
            printk("%d\t", (int)matrix[i*cols+j]);
    1ed8:	c81ff0ef          	jal	ra,1b58 <__fixsfsi>
    1edc:	00050593          	mv	a1,a0
    1ee0:	ec0b8513          	addi	a0,s7,-320 # 4ec0 <__clz_tab+0x178>
    1ee4:	3d4000ef          	jal	ra,22b8 <printk>
        for (int j=0; j<cols; j++) {
    1ee8:	fe9942e3          	blt	s2,s1,1ecc <print_mat+0x5c>
        printk("\n");
    1eec:	f44c0513          	addi	a0,s8,-188 # 4f44 <__clz_tab+0x1fc>
    1ef0:	3c8000ef          	jal	ra,22b8 <printk>
    for (int i=0; i<rows; i++) {
    1ef4:	001a8a93          	addi	s5,s5,1
    1ef8:	009a0a33          	add	s4,s4,s1
    1efc:	fbdff06f          	j	1eb8 <print_mat+0x48>
    }
    printk("\n");
}
    1f00:	02812403          	lw	s0,40(sp)
    1f04:	02c12083          	lw	ra,44(sp)
    1f08:	02412483          	lw	s1,36(sp)
    1f0c:	02012903          	lw	s2,32(sp)
    1f10:	01c12983          	lw	s3,28(sp)
    1f14:	01812a03          	lw	s4,24(sp)
    1f18:	01412a83          	lw	s5,20(sp)
    1f1c:	01012b03          	lw	s6,16(sp)
    1f20:	00c12b83          	lw	s7,12(sp)
    1f24:	00812c03          	lw	s8,8(sp)
    printk("\n");
    1f28:	00005537          	lui	a0,0x5
    1f2c:	f4450513          	addi	a0,a0,-188 # 4f44 <__clz_tab+0x1fc>
}
    1f30:	03010113          	addi	sp,sp,48
    printk("\n");
    1f34:	3840006f          	j	22b8 <printk>

00001f38 <multiply_mat>:

void multiply_mat(float *mat1, float *mat2, int result_address, int rows1, int cols1, int cols2)
{
    1f38:	fa010113          	addi	sp,sp,-96
    1f3c:	04912a23          	sw	s1,84(sp)
    1f40:	05512223          	sw	s5,68(sp)
    1f44:	03712e23          	sw	s7,60(sp)
    1f48:	03812c23          	sw	s8,56(sp)
    1f4c:	03912a23          	sw	s9,52(sp)
    1f50:	03a12823          	sw	s10,48(sp)
    1f54:	03b12623          	sw	s11,44(sp)
    1f58:	00060c93          	mv	s9,a2
    1f5c:	04112e23          	sw	ra,92(sp)
    1f60:	04812c23          	sw	s0,88(sp)
    1f64:	05212823          	sw	s2,80(sp)
    1f68:	05312623          	sw	s3,76(sp)
    1f6c:	05412423          	sw	s4,72(sp)
    1f70:	05612023          	sw	s6,64(sp)
    1f74:	00050b93          	mv	s7,a0
    1f78:	00058813          	mv	a6,a1
    1f7c:	00070a93          	mv	s5,a4
    1f80:	00078493          	mv	s1,a5
    1f84:	00279613          	slli	a2,a5,0x2
    float *result = (float *)result_address;

    for (int i=0; i<rows1; i++) {
    1f88:	00000c13          	li	s8,0
    1f8c:	00000d13          	li	s10,0
    1f90:	00000d93          	li	s11,0
    1f94:	0addd463          	bge	s11,a3,203c <CONFIG_SRAM_SIZE+0x3c>
    1f98:	002d1413          	slli	s0,s10,0x2
    1f9c:	002c1b13          	slli	s6,s8,0x2
    1fa0:	01940433          	add	s0,s0,s9
    1fa4:	016b8b33          	add	s6,s7,s6
        for (int j=0; j<cols2; j++) {
    1fa8:	00000a13          	li	s4,0
    1fac:	0640006f          	j	2010 <CONFIG_SRAM_SIZE+0x10>
            float val = 0;
            for (int k=0; k<cols1; k++) {
                val += mat1[i*cols1+k]*mat2[k*cols2+j];
    1fb0:	0009a583          	lw	a1,0(s3)
    1fb4:	00072503          	lw	a0,0(a4) # 80000 <__data_region_end+0x79f44>
    1fb8:	00d12e23          	sw	a3,28(sp)
    1fbc:	01012c23          	sw	a6,24(sp)
    1fc0:	00c12a23          	sw	a2,20(sp)
    1fc4:	00f12823          	sw	a5,16(sp)
    1fc8:	00e12623          	sw	a4,12(sp)
    1fcc:	c1cff0ef          	jal	ra,13e8 <__mulsf3>
    1fd0:	00050593          	mv	a1,a0
    1fd4:	00090513          	mv	a0,s2
    1fd8:	c81fe0ef          	jal	ra,c58 <__addsf3>
            for (int k=0; k<cols1; k++) {
    1fdc:	01012783          	lw	a5,16(sp)
    1fe0:	00c12703          	lw	a4,12(sp)
    1fe4:	01412603          	lw	a2,20(sp)
    1fe8:	01c12683          	lw	a3,28(sp)
    1fec:	01812803          	lw	a6,24(sp)
                val += mat1[i*cols1+k]*mat2[k*cols2+j];
    1ff0:	00050913          	mv	s2,a0
            for (int k=0; k<cols1; k++) {
    1ff4:	00178793          	addi	a5,a5,1
    1ff8:	00470713          	addi	a4,a4,4
    1ffc:	00c989b3          	add	s3,s3,a2
    2000:	fb57c8e3          	blt	a5,s5,1fb0 <multiply_mat+0x78>
            }
            result[i*cols2+j] = val;
    2004:	01242023          	sw	s2,0(s0)
        for (int j=0; j<cols2; j++) {
    2008:	001a0a13          	addi	s4,s4,1
    200c:	00440413          	addi	s0,s0,4
    2010:	009a5e63          	bge	s4,s1,202c <CONFIG_SRAM_SIZE+0x2c>
    2014:	002a1993          	slli	s3,s4,0x2
    2018:	013809b3          	add	s3,a6,s3
    201c:	000b0713          	mv	a4,s6
            for (int k=0; k<cols1; k++) {
    2020:	00000793          	li	a5,0
            float val = 0;
    2024:	00000913          	li	s2,0
    2028:	fd9ff06f          	j	2000 <CONFIG_SRAM_SIZE>
    for (int i=0; i<rows1; i++) {
    202c:	001d8d93          	addi	s11,s11,1
    2030:	009d0d33          	add	s10,s10,s1
    2034:	015c0c33          	add	s8,s8,s5
    2038:	f5dff06f          	j	1f94 <multiply_mat+0x5c>
        }
    }
}
    203c:	05c12083          	lw	ra,92(sp)
    2040:	05812403          	lw	s0,88(sp)
    2044:	05412483          	lw	s1,84(sp)
    2048:	05012903          	lw	s2,80(sp)
    204c:	04c12983          	lw	s3,76(sp)
    2050:	04812a03          	lw	s4,72(sp)
    2054:	04412a83          	lw	s5,68(sp)
    2058:	04012b03          	lw	s6,64(sp)
    205c:	03c12b83          	lw	s7,60(sp)
    2060:	03812c03          	lw	s8,56(sp)
    2064:	03412c83          	lw	s9,52(sp)
    2068:	03012d03          	lw	s10,48(sp)
    206c:	02c12d83          	lw	s11,44(sp)
    2070:	06010113          	addi	sp,sp,96
    2074:	00008067          	ret

00002078 <verify_matmul>:

int verify_matmul(float *mat1, float *mat2, int size)
{
    2078:	fe010113          	addi	sp,sp,-32
    int num_errors = 0;

    for(int i=0; i<size; i++)
        if(mat1[i]-mat2[1] >= 0.01) num_errors++;
    207c:	000057b7          	lui	a5,0x5
{
    2080:	01612223          	sw	s6,4(sp)
    2084:	01712023          	sw	s7,0(sp)
        if(mat1[i]-mat2[1] >= 0.01) num_errors++;
    2088:	d307ab03          	lw	s6,-720(a5) # 4d30 <__device_handles_end+0x4>
    208c:	d347ab83          	lw	s7,-716(a5)
{
    2090:	00812c23          	sw	s0,24(sp)
    2094:	00912a23          	sw	s1,20(sp)
    2098:	01212823          	sw	s2,16(sp)
    209c:	01312623          	sw	s3,12(sp)
    20a0:	01412423          	sw	s4,8(sp)
    20a4:	00112e23          	sw	ra,28(sp)
    20a8:	00050993          	mv	s3,a0
    20ac:	00058a13          	mv	s4,a1
    20b0:	00060913          	mv	s2,a2
    for(int i=0; i<size; i++)
    20b4:	00000413          	li	s0,0
    int num_errors = 0;
    20b8:	00000493          	li	s1,0
    for(int i=0; i<size; i++)
    20bc:	03244863          	blt	s0,s2,20ec <verify_matmul+0x74>

    return num_errors;
    20c0:	01c12083          	lw	ra,28(sp)
    20c4:	01812403          	lw	s0,24(sp)
    20c8:	01012903          	lw	s2,16(sp)
    20cc:	00c12983          	lw	s3,12(sp)
    20d0:	00812a03          	lw	s4,8(sp)
    20d4:	00412b03          	lw	s6,4(sp)
    20d8:	00012b83          	lw	s7,0(sp)
    20dc:	00048513          	mv	a0,s1
    20e0:	01412483          	lw	s1,20(sp)
    20e4:	02010113          	addi	sp,sp,32
    20e8:	00008067          	ret
        if(mat1[i]-mat2[1] >= 0.01) num_errors++;
    20ec:	00241793          	slli	a5,s0,0x2
    20f0:	00f987b3          	add	a5,s3,a5
    20f4:	004a2583          	lw	a1,4(s4)
    20f8:	0007a503          	lw	a0,0(a5)
    20fc:	df0ff0ef          	jal	ra,16ec <__subsf3>
    2100:	bd1ff0ef          	jal	ra,1cd0 <__extendsfdf2>
    2104:	000b0613          	mv	a2,s6
    2108:	000b8693          	mv	a3,s7
    210c:	a69fe0ef          	jal	ra,b74 <__gedf2>
    2110:	00054463          	bltz	a0,2118 <verify_matmul+0xa0>
    2114:	00148493          	addi	s1,s1,1
    for(int i=0; i<size; i++)
    2118:	00140413          	addi	s0,s0,1
    211c:	fa1ff06f          	j	20bc <verify_matmul+0x44>

00002120 <main>:
{
    2120:	ff010113          	addi	sp,sp,-16
    create_mat(mat1_base_address, rows1, cols1);
    2124:	00800613          	li	a2,8
    2128:	01000593          	li	a1,16
    212c:	01000537          	lui	a0,0x1000
{
    2130:	00112623          	sw	ra,12(sp)
    2134:	00812423          	sw	s0,8(sp)
    create_mat(mat1_base_address, rows1, cols1);
    2138:	c79ff0ef          	jal	ra,1db0 <create_mat>
    printk("Printing Matrix 1!\n");
    213c:	00005537          	lui	a0,0x5
    2140:	ec450513          	addi	a0,a0,-316 # 4ec4 <__clz_tab+0x17c>
    2144:	174000ef          	jal	ra,22b8 <printk>
    print_mat(mat1, rows1, cols1);
    2148:	00800613          	li	a2,8
    214c:	01000593          	li	a1,16
    2150:	01000537          	lui	a0,0x1000
    create_mat(mat2_base_address, cols1, cols2);
    2154:	01000437          	lui	s0,0x1000
    print_mat(mat1, rows1, cols1);
    2158:	d19ff0ef          	jal	ra,1e70 <print_mat>
    create_mat(mat2_base_address, cols1, cols2);
    215c:	00a00613          	li	a2,10
    2160:	00800593          	li	a1,8
    2164:	20040513          	addi	a0,s0,512 # 1000200 <__data_region_end+0xffa144>
    2168:	c49ff0ef          	jal	ra,1db0 <create_mat>
    printk("Printing Matrix 2!\n");
    216c:	00005537          	lui	a0,0x5
    2170:	ed850513          	addi	a0,a0,-296 # 4ed8 <__clz_tab+0x190>
    2174:	144000ef          	jal	ra,22b8 <printk>
    print_mat(mat2, cols1, cols2);
    2178:	20040513          	addi	a0,s0,512
    217c:	00a00613          	li	a2,10
    2180:	00800593          	li	a1,8
    2184:	cedff0ef          	jal	ra,1e70 <print_mat>
    multiply_mat(mat1, mat2, result_sw_base_address, rows1, cols1, cols2);
    2188:	00a00793          	li	a5,10
    218c:	00800713          	li	a4,8
    2190:	5c040613          	addi	a2,s0,1472
    2194:	20040593          	addi	a1,s0,512
    2198:	01000693          	li	a3,16
    219c:	01000537          	lui	a0,0x1000
    21a0:	d99ff0ef          	jal	ra,1f38 <multiply_mat>
    printk("Printing Software Result!\n");
    21a4:	00005537          	lui	a0,0x5
    21a8:	eec50513          	addi	a0,a0,-276 # 4eec <__clz_tab+0x1a4>
    21ac:	10c000ef          	jal	ra,22b8 <printk>
    print_mat(result_sw, rows1, cols2);
    21b0:	5c040513          	addi	a0,s0,1472
    21b4:	00a00613          	li	a2,10
    21b8:	01000593          	li	a1,16
    21bc:	cb5ff0ef          	jal	ra,1e70 <print_mat>
    *a = mat1_base_address;
    21c0:	100007b7          	lui	a5,0x10000
    21c4:	0087a823          	sw	s0,16(a5) # 10000010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xd050f90>
    *b = mat2_base_address;
    21c8:	20040713          	addi	a4,s0,512
    21cc:	00e7ac23          	sw	a4,24(a5)
    *c = result_hw_base_address;
    21d0:	34040413          	addi	s0,s0,832
    21d4:	0287a023          	sw	s0,32(a5)
    *rowsA = rows1;
    21d8:	01000713          	li	a4,16
    21dc:	02e7a423          	sw	a4,40(a5)
    *colsA = cols1;
    21e0:	00800713          	li	a4,8
    21e4:	02e7a823          	sw	a4,48(a5)
    *colsB = cols2;
    21e8:	00a00713          	li	a4,10
    21ec:	02e7ac23          	sw	a4,56(a5)
    *do_matp_mem = 1;
    21f0:	00100713          	li	a4,1
    21f4:	00e7a023          	sw	a4,0(a5)
    while ((*do_matp_mem & 2) == 0);
    21f8:	10000737          	lui	a4,0x10000
    21fc:	00072783          	lw	a5,0(a4) # 10000000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xd050f80>
    2200:	0027f793          	andi	a5,a5,2
    2204:	fe078ce3          	beqz	a5,21fc <main+0xdc>
    printk("Printing Hardware Result!\n");
    2208:	00005537          	lui	a0,0x5
    220c:	f0850513          	addi	a0,a0,-248 # 4f08 <__clz_tab+0x1c0>
    2210:	0a8000ef          	jal	ra,22b8 <printk>
    print_mat(result_hw, rows1, cols2);
    2214:	01000437          	lui	s0,0x1000
    2218:	34040513          	addi	a0,s0,832 # 1000340 <__data_region_end+0xffa284>
    221c:	00a00613          	li	a2,10
    2220:	01000593          	li	a1,16
    2224:	c4dff0ef          	jal	ra,1e70 <print_mat>
    int num_errors = verify_matmul(result_hw, result_sw, rows1*cols2);
    2228:	5c040593          	addi	a1,s0,1472
    222c:	0a000613          	li	a2,160
    2230:	34040513          	addi	a0,s0,832
    2234:	e45ff0ef          	jal	ra,2078 <verify_matmul>
    2238:	00050593          	mv	a1,a0
    printk("Accelerator done with %d errors!\n", num_errors);
    223c:	00005537          	lui	a0,0x5
    2240:	f2450513          	addi	a0,a0,-220 # 4f24 <__clz_tab+0x1dc>
    2244:	074000ef          	jal	ra,22b8 <printk>
}
    2248:	00c12083          	lw	ra,12(sp)
    224c:	00812403          	lw	s0,8(sp)
    2250:	00000513          	li	a0,0
    2254:	01010113          	addi	sp,sp,16
    2258:	00008067          	ret

0000225c <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    225c:	00000513          	li	a0,0
    2260:	00008067          	ret

00002264 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    2264:	0005a783          	lw	a5,0(a1) # 4000000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1050f80>
    2268:	00178793          	addi	a5,a5,1
    226c:	00f5a023          	sw	a5,0(a1)
	return _char_out(c);
    2270:	000067b7          	lui	a5,0x6
    2274:	0907a783          	lw	a5,144(a5) # 6090 <_char_out>
    2278:	00078067          	jr	a5

0000227c <__printk_hook_install>:
	_char_out = fn;
    227c:	000067b7          	lui	a5,0x6
    2280:	08a7a823          	sw	a0,144(a5) # 6090 <_char_out>
}
    2284:	00008067          	ret

00002288 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
    2288:	fe010113          	addi	sp,sp,-32
    228c:	00050613          	mv	a2,a0
		struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
		k_spinlock_key_t key = k_spin_lock(&lock);
#endif

		cbvprintf(char_out, &ctx, fmt, ap);
    2290:	00002537          	lui	a0,0x2
{
    2294:	00058693          	mv	a3,a1
		cbvprintf(char_out, &ctx, fmt, ap);
    2298:	26450513          	addi	a0,a0,612 # 2264 <char_out>
    229c:	00c10593          	addi	a1,sp,12
{
    22a0:	00112e23          	sw	ra,28(sp)
		struct out_context ctx = { 0 };
    22a4:	00012623          	sw	zero,12(sp)
		cbvprintf(char_out, &ctx, fmt, ap);
    22a8:	244000ef          	jal	ra,24ec <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
    22ac:	01c12083          	lw	ra,28(sp)
    22b0:	02010113          	addi	sp,sp,32
    22b4:	00008067          	ret

000022b8 <printk>:
 *
 * @return N/A
 */

void printk(const char *fmt, ...)
{
    22b8:	fc010113          	addi	sp,sp,-64
    22bc:	02b12223          	sw	a1,36(sp)
	va_list ap;

	va_start(ap, fmt);
    22c0:	02410593          	addi	a1,sp,36
{
    22c4:	00112e23          	sw	ra,28(sp)
    22c8:	02c12423          	sw	a2,40(sp)
    22cc:	02d12623          	sw	a3,44(sp)
    22d0:	02e12823          	sw	a4,48(sp)
    22d4:	02f12a23          	sw	a5,52(sp)
    22d8:	03012c23          	sw	a6,56(sp)
    22dc:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
    22e0:	00b12623          	sw	a1,12(sp)

	vprintk(fmt, ap);
    22e4:	fa5ff0ef          	jal	ra,2288 <vprintk>

	va_end(ap);
}
    22e8:	01c12083          	lw	ra,28(sp)
    22ec:	04010113          	addi	sp,sp,64
    22f0:	00008067          	ret

000022f4 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    22f4:	ff010113          	addi	sp,sp,-16
    22f8:	00050793          	mv	a5,a0
    22fc:	00058513          	mv	a0,a1
    2300:	00060593          	mv	a1,a2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    2304:	00068613          	mv	a2,a3
{
    2308:	00112623          	sw	ra,12(sp)
	entry(p1, p2, p3);
    230c:	000780e7          	jalr	a5
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
    2310:	1a0020ef          	jal	ra,44b0 <z_impl_z_current_get>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
    2314:	29c020ef          	jal	ra,45b0 <z_impl_k_thread_abort>

00002318 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
    2318:	fd010113          	addi	sp,sp,-48
    231c:	02812423          	sw	s0,40(sp)
    2320:	02912223          	sw	s1,36(sp)
    2324:	03212023          	sw	s2,32(sp)
    2328:	01312e23          	sw	s3,28(sp)
    232c:	01712623          	sw	s7,12(sp)
    2330:	01812423          	sw	s8,8(sp)
    2334:	01912223          	sw	s9,4(sp)
    2338:	02112623          	sw	ra,44(sp)
    233c:	01412c23          	sw	s4,24(sp)
    2340:	01512a23          	sw	s5,20(sp)
    2344:	01612823          	sw	s6,16(sp)
	bool upcase = isupper((int)conv->specifier);
    2348:	00364783          	lbu	a5,3(a2)
{
    234c:	00070413          	mv	s0,a4
	switch (specifier) {
    2350:	06f00713          	li	a4,111
{
    2354:	00050c13          	mv	s8,a0
    2358:	00058c93          	mv	s9,a1
    235c:	00060b93          	mv	s7,a2
    2360:	00068913          	mv	s2,a3
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    2364:	fbf78993          	addi	s3,a5,-65
	switch (specifier) {
    2368:	00800493          	li	s1,8
    236c:	00e78c63          	beq	a5,a4,2384 <encode_uint+0x6c>
    2370:	0cf76263          	bltu	a4,a5,2434 <encode_uint+0x11c>
    2374:	05800713          	li	a4,88
		return 10;
    2378:	00a00493          	li	s1,10
	switch (specifier) {
    237c:	00e79463          	bne	a5,a4,2384 <encode_uint+0x6c>
		return 16;
    2380:	01000493          	li	s1,16
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
    2384:	00000a93          	li	s5,0

		*--bp = (lsv <= 9) ? ('0' + lsv)
    2388:	00900a13          	li	s4,9
    238c:	01900b13          	li	s6,25
		unsigned int lsv = (unsigned int)(value % radix);
    2390:	00048613          	mv	a2,s1
    2394:	00000693          	li	a3,0
    2398:	000c0513          	mv	a0,s8
    239c:	000c8593          	mv	a1,s9
    23a0:	bd0fe0ef          	jal	ra,770 <__umoddi3>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    23a4:	0ff57793          	andi	a5,a0,255
    23a8:	0aaa6263          	bltu	s4,a0,244c <encode_uint+0x134>
    23ac:	03078793          	addi	a5,a5,48
    23b0:	0ff7f793          	andi	a5,a5,255
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
    23b4:	00048613          	mv	a2,s1
    23b8:	00000693          	li	a3,0
    23bc:	000c0513          	mv	a0,s8
    23c0:	000c8593          	mv	a1,s9
		*--bp = (lsv <= 9) ? ('0' + lsv)
    23c4:	fef40fa3          	sb	a5,-1(s0)
    23c8:	fff40413          	addi	s0,s0,-1
		value /= radix;
    23cc:	f71fd0ef          	jal	ra,33c <__udivdi3>
	} while ((value != 0) && (bps < bp));
    23d0:	019a9463          	bne	s5,s9,23d8 <encode_uint+0xc0>
    23d4:	009c6463          	bltu	s8,s1,23dc <encode_uint+0xc4>
    23d8:	06896463          	bltu	s2,s0,2440 <encode_uint+0x128>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
    23dc:	000bd783          	lhu	a5,0(s7)
    23e0:	0207f793          	andi	a5,a5,32
    23e4:	00078c63          	beqz	a5,23fc <encode_uint+0xe4>
		if (radix == 8) {
    23e8:	00800793          	li	a5,8
    23ec:	06f49a63          	bne	s1,a5,2460 <encode_uint+0x148>
			conv->altform_0 = true;
    23f0:	002bc783          	lbu	a5,2(s7)
    23f4:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
    23f8:	00fb8123          	sb	a5,2(s7)
			;
		}
	}

	return bp;
}
    23fc:	02c12083          	lw	ra,44(sp)
    2400:	00040513          	mv	a0,s0
    2404:	02812403          	lw	s0,40(sp)
    2408:	02412483          	lw	s1,36(sp)
    240c:	02012903          	lw	s2,32(sp)
    2410:	01c12983          	lw	s3,28(sp)
    2414:	01812a03          	lw	s4,24(sp)
    2418:	01412a83          	lw	s5,20(sp)
    241c:	01012b03          	lw	s6,16(sp)
    2420:	00c12b83          	lw	s7,12(sp)
    2424:	00812c03          	lw	s8,8(sp)
    2428:	00412c83          	lw	s9,4(sp)
    242c:	03010113          	addi	sp,sp,48
    2430:	00008067          	ret
	switch (specifier) {
    2434:	0f77f793          	andi	a5,a5,247
    2438:	07000713          	li	a4,112
    243c:	f3dff06f          	j	2378 <encode_uint+0x60>
		value /= radix;
    2440:	00050c13          	mv	s8,a0
    2444:	00058c93          	mv	s9,a1
    2448:	f49ff06f          	j	2390 <encode_uint+0x78>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    244c:	013b6663          	bltu	s6,s3,2458 <encode_uint+0x140>
    2450:	03778793          	addi	a5,a5,55
    2454:	f5dff06f          	j	23b0 <encode_uint+0x98>
    2458:	05778793          	addi	a5,a5,87
    245c:	f55ff06f          	j	23b0 <encode_uint+0x98>
		} else if (radix == 16) {
    2460:	01000793          	li	a5,16
    2464:	f8f49ce3          	bne	s1,a5,23fc <encode_uint+0xe4>
			conv->altform_0c = true;
    2468:	002bc783          	lbu	a5,2(s7)
    246c:	0107e793          	ori	a5,a5,16
    2470:	f89ff06f          	j	23f8 <encode_uint+0xe0>

00002474 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    2474:	fe010113          	addi	sp,sp,-32
    2478:	00812c23          	sw	s0,24(sp)
    247c:	00912a23          	sw	s1,20(sp)
    2480:	01212823          	sw	s2,16(sp)
    2484:	01312623          	sw	s3,12(sp)
    2488:	01412423          	sw	s4,8(sp)
    248c:	00112e23          	sw	ra,28(sp)
    2490:	00050993          	mv	s3,a0
    2494:	00058a13          	mv	s4,a1
    2498:	00060493          	mv	s1,a2
    249c:	00068913          	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    24a0:	00060413          	mv	s0,a2
    24a4:	40940533          	sub	a0,s0,s1
    24a8:	01246863          	bltu	s0,s2,24b8 <outs+0x44>
    24ac:	02091063          	bnez	s2,24cc <outs+0x58>
    24b0:	00044783          	lbu	a5,0(s0)
    24b4:	00078c63          	beqz	a5,24cc <outs+0x58>
		int rc = out((int)*sp++, ctx);
    24b8:	00044503          	lbu	a0,0(s0)
    24bc:	000a0593          	mv	a1,s4
    24c0:	00140413          	addi	s0,s0,1
    24c4:	000980e7          	jalr	s3

		if (rc < 0) {
    24c8:	fc055ee3          	bgez	a0,24a4 <outs+0x30>
		}
		++count;
	}

	return (int)count;
}
    24cc:	01c12083          	lw	ra,28(sp)
    24d0:	01812403          	lw	s0,24(sp)
    24d4:	01412483          	lw	s1,20(sp)
    24d8:	01012903          	lw	s2,16(sp)
    24dc:	00c12983          	lw	s3,12(sp)
    24e0:	00812a03          	lw	s4,8(sp)
    24e4:	02010113          	addi	sp,sp,32
    24e8:	00008067          	ret

000024ec <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    24ec:	f7010113          	addi	sp,sp,-144
    24f0:	07512a23          	sw	s5,116(sp)
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
    24f4:	00005ab7          	lui	s5,0x5
    24f8:	fd4a8793          	addi	a5,s5,-44 # 4fd4 <__clz_tab+0x28c>
{
    24fc:	07612823          	sw	s6,112(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
    2500:	00005b37          	lui	s6,0x5
{
    2504:	07712623          	sw	s7,108(sp)
    2508:	07812423          	sw	s8,104(sp)
		switch (conv->specifier) {
    250c:	00f12223          	sw	a5,4(sp)
				conv->specifier = 'x';

				goto prec_int_pad0;
			}

			bps = "(nil)";
    2510:	00005bb7          	lui	s7,0x5
	switch ((enum length_mod_enum)conv->length_mod) {
    2514:	02cb0793          	addi	a5,s6,44 # 502c <__clz_tab+0x2e4>
			bpe = bps + 5;
    2518:	00005c37          	lui	s8,0x5
{
    251c:	09212023          	sw	s2,128(sp)
    2520:	07312e23          	sw	s3,124(sp)
    2524:	07912223          	sw	s9,100(sp)
    2528:	07a12023          	sw	s10,96(sp)
    252c:	05b12e23          	sw	s11,92(sp)
    2530:	08112623          	sw	ra,140(sp)
    2534:	08812423          	sw	s0,136(sp)
    2538:	08912223          	sw	s1,132(sp)
    253c:	07412c23          	sw	s4,120(sp)
    2540:	00050913          	mv	s2,a0
    2544:	00058993          	mv	s3,a1
    2548:	00060d13          	mv	s10,a2
    254c:	00068c93          	mv	s9,a3
	size_t count = 0;
    2550:	00000d93          	li	s11,0
	switch ((enum length_mod_enum)conv->length_mod) {
    2554:	00f12423          	sw	a5,8(sp)
			bps = "(nil)";
    2558:	f48b8b93          	addi	s7,s7,-184 # 4f48 <__clz_tab+0x200>
			bpe = bps + 5;
    255c:	f4dc0c13          	addi	s8,s8,-179 # 4f4d <__clz_tab+0x205>
	while (*fp != 0) {
    2560:	000d4403          	lbu	s0,0(s10)
    2564:	00041663          	bnez	s0,2570 <cbvprintf+0x84>
			OUTC(' ');
			--width;
		}
	}

	return count;
    2568:	000d8513          	mv	a0,s11
    256c:	2290006f          	j	2f94 <cbvprintf+0xaa8>
		if (*fp != '%') {
    2570:	02500793          	li	a5,37
			OUTC(*fp++);
    2574:	001d0a13          	addi	s4,s10,1
		if (*fp != '%') {
    2578:	02f40463          	beq	s0,a5,25a0 <cbvprintf+0xb4>
			OUTC(*fp++);
    257c:	00098593          	mv	a1,s3
    2580:	00040513          	mv	a0,s0
    2584:	000900e7          	jalr	s2
    2588:	200546e3          	bltz	a0,2f94 <cbvprintf+0xaa8>
    258c:	001d8d93          	addi	s11,s11,1
			continue;
    2590:	000c8413          	mv	s0,s9
    2594:	00040c93          	mv	s9,s0
    2598:	000a0d13          	mv	s10,s4
    259c:	fc5ff06f          	j	2560 <cbvprintf+0x74>
		} state = {
    25a0:	02000613          	li	a2,32
    25a4:	00000593          	li	a1,0
    25a8:	03010513          	addi	a0,sp,48
    25ac:	3c9000ef          	jal	ra,3174 <memset>
	if (*sp == '%') {
    25b0:	001d4783          	lbu	a5,1(s10)
    25b4:	0e879263          	bne	a5,s0,2698 <cbvprintf+0x1ac>
		conv->specifier = *sp++;
    25b8:	002d0a13          	addi	s4,s10,2
    25bc:	04f101a3          	sb	a5,67(sp)
		if (conv->width_star) {
    25c0:	04015783          	lhu	a5,64(sp)
    25c4:	1007f713          	andi	a4,a5,256
    25c8:	52070e63          	beqz	a4,2b04 <cbvprintf+0x618>
			width = va_arg(ap, int);
    25cc:	000ca483          	lw	s1,0(s9)
    25d0:	004c8413          	addi	s0,s9,4
			if (width < 0) {
    25d4:	0004d863          	bgez	s1,25e4 <cbvprintf+0xf8>
				conv->flag_dash = true;
    25d8:	0047e793          	ori	a5,a5,4
    25dc:	04f11023          	sh	a5,64(sp)
				width = -width;
    25e0:	409004b3          	neg	s1,s1
		if (conv->prec_star) {
    25e4:	04015703          	lhu	a4,64(sp)
    25e8:	40077793          	andi	a5,a4,1024
    25ec:	52078c63          	beqz	a5,2b24 <cbvprintf+0x638>
			int arg = va_arg(ap, int);
    25f0:	00042a83          	lw	s5,0(s0)
    25f4:	00440413          	addi	s0,s0,4
			if (arg < 0) {
    25f8:	000ad863          	bgez	s5,2608 <cbvprintf+0x11c>
				conv->prec_present = false;
    25fc:	dff77713          	andi	a4,a4,-513
    2600:	04e11023          	sh	a4,64(sp)
		int precision = -1;
    2604:	fff00a93          	li	s5,-1
			= (enum specifier_cat_enum)conv->specifier_cat;
    2608:	04012583          	lw	a1,64(sp)
		conv->pad0_value = 0;
    260c:	04012223          	sw	zero,68(sp)
		conv->pad0_pre_exp = 0;
    2610:	04012423          	sw	zero,72(sp)
			= (enum specifier_cat_enum)conv->specifier_cat;
    2614:	0105d693          	srli	a3,a1,0x10
			= (enum length_mod_enum)conv->length_mod;
    2618:	00b5d713          	srli	a4,a1,0xb
		enum specifier_cat_enum specifier_cat
    261c:	0076f693          	andi	a3,a3,7
		if (specifier_cat == SPECIFIER_SINT) {
    2620:	00100613          	li	a2,1
			= (enum length_mod_enum)conv->length_mod;
    2624:	00f77713          	andi	a4,a4,15
		if (specifier_cat == SPECIFIER_SINT) {
    2628:	56c69263          	bne	a3,a2,2b8c <cbvprintf+0x6a0>
			switch (length_mod) {
    262c:	00500613          	li	a2,5
    2630:	50c70e63          	beq	a4,a2,2b4c <cbvprintf+0x660>
    2634:	00e66a63          	bltu	a2,a4,2648 <cbvprintf+0x15c>
    2638:	00300693          	li	a3,3
    263c:	4ed70e63          	beq	a4,a3,2b38 <cbvprintf+0x64c>
    2640:	00400693          	li	a3,4
    2644:	50d70463          	beq	a4,a3,2b4c <cbvprintf+0x660>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    2648:	00042683          	lw	a3,0(s0)
    264c:	00440413          	addi	s0,s0,4
    2650:	02d12823          	sw	a3,48(sp)
    2654:	41f6d693          	srai	a3,a3,0x1f
    2658:	02d12a23          	sw	a3,52(sp)
			if (length_mod == LENGTH_HH) {
    265c:	00100693          	li	a3,1
    2660:	50d71863          	bne	a4,a3,2b70 <cbvprintf+0x684>
				value->uint = (unsigned char)value->uint;
    2664:	03014683          	lbu	a3,48(sp)
				value->uint = (unsigned short)value->uint;
    2668:	02d12823          	sw	a3,48(sp)
    266c:	02012a23          	sw	zero,52(sp)
		if (conv->invalid || conv->unsupported) {
    2670:	0035f593          	andi	a1,a1,3
    2674:	5e058863          	beqz	a1,2c64 <cbvprintf+0x778>
			OUTS(sp, fp);
    2678:	000a0693          	mv	a3,s4
    267c:	000d0613          	mv	a2,s10
    2680:	00098593          	mv	a1,s3
    2684:	00090513          	mv	a0,s2
    2688:	dedff0ef          	jal	ra,2474 <outs>
    268c:	100544e3          	bltz	a0,2f94 <cbvprintf+0xaa8>
    2690:	00ad8db3          	add	s11,s11,a0
			continue;
    2694:	f01ff06f          	j	2594 <cbvprintf+0xa8>
    2698:	00000513          	li	a0,0
    269c:	00000693          	li	a3,0
    26a0:	00000593          	li	a1,0
    26a4:	00000613          	li	a2,0
    26a8:	00000713          	li	a4,0
		switch (*sp) {
    26ac:	02b00813          	li	a6,43
    26b0:	02d00893          	li	a7,45
    26b4:	03000313          	li	t1,48
    26b8:	02000e13          	li	t3,32
    26bc:	02300e93          	li	t4,35
    26c0:	000a4783          	lbu	a5,0(s4)
    26c4:	13078863          	beq	a5,a6,27f4 <cbvprintf+0x308>
    26c8:	10f86e63          	bltu	a6,a5,27e4 <cbvprintf+0x2f8>
    26cc:	13c78a63          	beq	a5,t3,2800 <cbvprintf+0x314>
    26d0:	13d78c63          	beq	a5,t4,2808 <cbvprintf+0x31c>
    26d4:	00070863          	beqz	a4,26e4 <cbvprintf+0x1f8>
    26d8:	04015703          	lhu	a4,64(sp)
    26dc:	00476713          	ori	a4,a4,4
    26e0:	04e11023          	sh	a4,64(sp)
    26e4:	00060863          	beqz	a2,26f4 <cbvprintf+0x208>
    26e8:	04015703          	lhu	a4,64(sp)
    26ec:	00876713          	ori	a4,a4,8
    26f0:	04e11023          	sh	a4,64(sp)
    26f4:	00058863          	beqz	a1,2704 <cbvprintf+0x218>
    26f8:	04015703          	lhu	a4,64(sp)
    26fc:	01076713          	ori	a4,a4,16
    2700:	04e11023          	sh	a4,64(sp)
    2704:	00068863          	beqz	a3,2714 <cbvprintf+0x228>
    2708:	04015703          	lhu	a4,64(sp)
    270c:	02076713          	ori	a4,a4,32
    2710:	04e11023          	sh	a4,64(sp)
    2714:	00050863          	beqz	a0,2724 <cbvprintf+0x238>
    2718:	04015703          	lhu	a4,64(sp)
    271c:	04076713          	ori	a4,a4,64
    2720:	04e11023          	sh	a4,64(sp)
	if (conv->flag_zero && conv->flag_dash) {
    2724:	04012703          	lw	a4,64(sp)
    2728:	04400693          	li	a3,68
    272c:	04477713          	andi	a4,a4,68
    2730:	00d71863          	bne	a4,a3,2740 <cbvprintf+0x254>
		conv->flag_zero = false;
    2734:	04015703          	lhu	a4,64(sp)
    2738:	fbf77713          	andi	a4,a4,-65
    273c:	04e11023          	sh	a4,64(sp)
	conv->width_present = true;
    2740:	04015703          	lhu	a4,64(sp)
    2744:	08076693          	ori	a3,a4,128
    2748:	04d11023          	sh	a3,64(sp)
	if (*sp == '*') {
    274c:	02a00693          	li	a3,42
    2750:	10d79463          	bne	a5,a3,2858 <cbvprintf+0x36c>
			++sp;
    2754:	001a0793          	addi	a5,s4,1
		conv->width_star = true;
    2758:	18076713          	ori	a4,a4,384
		conv->unsupported |= ((conv->width_value < 0)
    275c:	04e11023          	sh	a4,64(sp)
	conv->prec_present = (*sp == '.');
    2760:	0007c603          	lbu	a2,0(a5)
    2764:	fd260713          	addi	a4,a2,-46
    2768:	00173713          	seqz	a4,a4
    276c:	00971693          	slli	a3,a4,0x9
    2770:	04015703          	lhu	a4,64(sp)
    2774:	dff77713          	andi	a4,a4,-513
    2778:	00d76733          	or	a4,a4,a3
    277c:	04e11023          	sh	a4,64(sp)
	if (!conv->prec_present) {
    2780:	02e00693          	li	a3,46
    2784:	0ed61a63          	bne	a2,a3,2878 <cbvprintf+0x38c>
	if (*sp == '*') {
    2788:	0017c603          	lbu	a2,1(a5)
    278c:	02a00693          	li	a3,42
    2790:	0cd60e63          	beq	a2,a3,286c <cbvprintf+0x380>
	++sp;
    2794:	00178793          	addi	a5,a5,1
	size_t val = 0;
    2798:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
    279c:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
    27a0:	00a00813          	li	a6,10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    27a4:	0007c683          	lbu	a3,0(a5)
    27a8:	00178513          	addi	a0,a5,1
    27ac:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp)) {
    27b0:	16b67463          	bgeu	a2,a1,2918 <cbvprintf+0x42c>
	conv->unsupported |= ((conv->prec_value < 0)
    27b4:	04012683          	lw	a3,64(sp)
	conv->prec_value = prec;
    27b8:	04e12423          	sw	a4,72(sp)
			      || (prec != (size_t)conv->prec_value));
    27bc:	01f75713          	srli	a4,a4,0x1f
	conv->unsupported |= ((conv->prec_value < 0)
    27c0:	0016d693          	srli	a3,a3,0x1
    27c4:	0016f693          	andi	a3,a3,1
    27c8:	00e6e733          	or	a4,a3,a4
    27cc:	04015683          	lhu	a3,64(sp)
    27d0:	00171713          	slli	a4,a4,0x1
    27d4:	ffd6f693          	andi	a3,a3,-3
    27d8:	00e6e733          	or	a4,a3,a4
    27dc:	04e11023          	sh	a4,64(sp)
	return sp;
    27e0:	0980006f          	j	2878 <cbvprintf+0x38c>
		switch (*sp) {
    27e4:	03178663          	beq	a5,a7,2810 <cbvprintf+0x324>
    27e8:	ee6796e3          	bne	a5,t1,26d4 <cbvprintf+0x1e8>
			conv->flag_zero = true;
    27ec:	00100513          	li	a0,1
    27f0:	0080006f          	j	27f8 <cbvprintf+0x30c>
			conv->flag_plus = true;
    27f4:	00100613          	li	a2,1
			++sp;
    27f8:	001a0a13          	addi	s4,s4,1
	} while (loop);
    27fc:	ec5ff06f          	j	26c0 <cbvprintf+0x1d4>
			conv->flag_space = true;
    2800:	00100593          	li	a1,1
    2804:	ff5ff06f          	j	27f8 <cbvprintf+0x30c>
			conv->flag_hash = true;
    2808:	00100693          	li	a3,1
    280c:	fedff06f          	j	27f8 <cbvprintf+0x30c>
		switch (*sp) {
    2810:	00100713          	li	a4,1
    2814:	fe5ff06f          	j	27f8 <cbvprintf+0x30c>
		val = 10U * val + *sp++ - '0';
    2818:	03070733          	mul	a4,a4,a6
    281c:	00050793          	mv	a5,a0
    2820:	fd070713          	addi	a4,a4,-48
    2824:	00d70733          	add	a4,a4,a3
    2828:	0007c683          	lbu	a3,0(a5)
    282c:	00178513          	addi	a0,a5,1
    2830:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp)) {
    2834:	feb672e3          	bgeu	a2,a1,2818 <cbvprintf+0x32c>
	if (sp != wp) {
    2838:	f2fa04e3          	beq	s4,a5,2760 <cbvprintf+0x274>
		conv->unsupported |= ((conv->width_value < 0)
    283c:	04015683          	lhu	a3,64(sp)
		conv->width_value = width;
    2840:	04e12223          	sw	a4,68(sp)
		conv->unsupported |= ((conv->width_value < 0)
    2844:	01f75713          	srli	a4,a4,0x1f
    2848:	00171713          	slli	a4,a4,0x1
    284c:	ffd6f693          	andi	a3,a3,-3
    2850:	00e6e733          	or	a4,a3,a4
    2854:	f09ff06f          	j	275c <cbvprintf+0x270>
    2858:	000a0793          	mv	a5,s4
	size_t val = 0;
    285c:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
    2860:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
    2864:	00a00813          	li	a6,10
    2868:	fc1ff06f          	j	2828 <cbvprintf+0x33c>
		conv->prec_star = true;
    286c:	40076713          	ori	a4,a4,1024
    2870:	04e11023          	sh	a4,64(sp)
		return ++sp;
    2874:	00278793          	addi	a5,a5,2
	switch (*sp) {
    2878:	0007c603          	lbu	a2,0(a5)
    287c:	06c00713          	li	a4,108
		if (*++sp == 'h') {
    2880:	00178593          	addi	a1,a5,1
	switch (*sp) {
    2884:	10e60c63          	beq	a2,a4,299c <cbvprintf+0x4b0>
    2888:	0ac76263          	bltu	a4,a2,292c <cbvprintf+0x440>
    288c:	06800713          	li	a4,104
    2890:	0ce60663          	beq	a2,a4,295c <cbvprintf+0x470>
    2894:	06a00713          	li	a4,106
    2898:	12e60863          	beq	a2,a4,29c8 <cbvprintf+0x4dc>
    289c:	04c00713          	li	a4,76
    28a0:	14e60e63          	beq	a2,a4,29fc <cbvprintf+0x510>
    28a4:	00078593          	mv	a1,a5
	conv->specifier = *sp++;
    28a8:	0005c703          	lbu	a4,0(a1)
	switch (conv->specifier) {
    28ac:	07800793          	li	a5,120
	conv->specifier = *sp++;
    28b0:	00158a13          	addi	s4,a1,1
    28b4:	04e101a3          	sb	a4,67(sp)
	switch (conv->specifier) {
    28b8:	22e7ec63          	bltu	a5,a4,2af0 <cbvprintf+0x604>
    28bc:	05700793          	li	a5,87
    28c0:	14e7ec63          	bltu	a5,a4,2a18 <cbvprintf+0x52c>
    28c4:	04100793          	li	a5,65
    28c8:	00f70a63          	beq	a4,a5,28dc <cbvprintf+0x3f0>
    28cc:	fbb70713          	addi	a4,a4,-69
    28d0:	0ff77713          	andi	a4,a4,255
    28d4:	00200793          	li	a5,2
    28d8:	20e7ec63          	bltu	a5,a4,2af0 <cbvprintf+0x604>
		conv->specifier_cat = SPECIFIER_FP;
    28dc:	04214783          	lbu	a5,66(sp)
    28e0:	ff87f793          	andi	a5,a5,-8
    28e4:	0047e793          	ori	a5,a5,4
    28e8:	04f10123          	sb	a5,66(sp)
			unsupported = true;
    28ec:	00100793          	li	a5,1
	conv->unsupported |= unsupported;
    28f0:	04012703          	lw	a4,64(sp)
    28f4:	00175713          	srli	a4,a4,0x1
    28f8:	00177713          	andi	a4,a4,1
    28fc:	00e7e7b3          	or	a5,a5,a4
    2900:	04015703          	lhu	a4,64(sp)
    2904:	00179793          	slli	a5,a5,0x1
    2908:	ffd77713          	andi	a4,a4,-3
    290c:	00f767b3          	or	a5,a4,a5
    2910:	04f11023          	sh	a5,64(sp)
	return sp;
    2914:	cadff06f          	j	25c0 <cbvprintf+0xd4>
		val = 10U * val + *sp++ - '0';
    2918:	03070733          	mul	a4,a4,a6
    291c:	00050793          	mv	a5,a0
    2920:	fd070713          	addi	a4,a4,-48
    2924:	00e68733          	add	a4,a3,a4
    2928:	e7dff06f          	j	27a4 <cbvprintf+0x2b8>
	switch (*sp) {
    292c:	07400713          	li	a4,116
    2930:	0ae60a63          	beq	a2,a4,29e4 <cbvprintf+0x4f8>
    2934:	07a00713          	li	a4,122
    2938:	f6e616e3          	bne	a2,a4,28a4 <cbvprintf+0x3b8>
		conv->length_mod = LENGTH_Z;
    293c:	04015783          	lhu	a5,64(sp)
    2940:	ffff8737          	lui	a4,0xffff8
    2944:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
    2948:	00e7f7b3          	and	a5,a5,a4
    294c:	00003737          	lui	a4,0x3
		conv->unsupported = true;
    2950:	00e7e7b3          	or	a5,a5,a4
    2954:	04f11023          	sh	a5,64(sp)
		break;
    2958:	f51ff06f          	j	28a8 <cbvprintf+0x3bc>
		if (*++sp == 'h') {
    295c:	04015503          	lhu	a0,64(sp)
    2960:	0017c803          	lbu	a6,1(a5)
    2964:	ffff86b7          	lui	a3,0xffff8
    2968:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_HH;
    296c:	00a77733          	and	a4,a4,a0
		if (*++sp == 'h') {
    2970:	00c81e63          	bne	a6,a2,298c <cbvprintf+0x4a0>
			conv->length_mod = LENGTH_HH;
    2974:	000016b7          	lui	a3,0x1
    2978:	80068693          	addi	a3,a3,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
    297c:	00d76733          	or	a4,a4,a3
    2980:	04e11023          	sh	a4,64(sp)
			++sp;
    2984:	00278593          	addi	a1,a5,2
    2988:	f21ff06f          	j	28a8 <cbvprintf+0x3bc>
			conv->length_mod = LENGTH_H;
    298c:	000017b7          	lui	a5,0x1
			conv->length_mod = LENGTH_L;
    2990:	00f76733          	or	a4,a4,a5
    2994:	04e11023          	sh	a4,64(sp)
    2998:	f11ff06f          	j	28a8 <cbvprintf+0x3bc>
		if (*++sp == 'l') {
    299c:	04015503          	lhu	a0,64(sp)
    29a0:	0017c803          	lbu	a6,1(a5) # 1001 <__kernel_ram_size+0x75>
    29a4:	ffff86b7          	lui	a3,0xffff8
    29a8:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_LL;
    29ac:	00a77733          	and	a4,a4,a0
		if (*++sp == 'l') {
    29b0:	00c81663          	bne	a6,a2,29bc <cbvprintf+0x4d0>
			conv->length_mod = LENGTH_LL;
    29b4:	000026b7          	lui	a3,0x2
    29b8:	fc5ff06f          	j	297c <cbvprintf+0x490>
			conv->length_mod = LENGTH_L;
    29bc:	000027b7          	lui	a5,0x2
    29c0:	80078793          	addi	a5,a5,-2048 # 1800 <__subsf3+0x114>
    29c4:	fcdff06f          	j	2990 <cbvprintf+0x4a4>
		conv->length_mod = LENGTH_J;
    29c8:	04015783          	lhu	a5,64(sp)
    29cc:	ffff8737          	lui	a4,0xffff8
    29d0:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
    29d4:	00e7f7b3          	and	a5,a5,a4
    29d8:	00003737          	lui	a4,0x3
		conv->length_mod = LENGTH_T;
    29dc:	80070713          	addi	a4,a4,-2048 # 2800 <cbvprintf+0x314>
    29e0:	f71ff06f          	j	2950 <cbvprintf+0x464>
    29e4:	04015783          	lhu	a5,64(sp)
    29e8:	ffff8737          	lui	a4,0xffff8
    29ec:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
    29f0:	00e7f7b3          	and	a5,a5,a4
    29f4:	00004737          	lui	a4,0x4
    29f8:	fe5ff06f          	j	29dc <cbvprintf+0x4f0>
		conv->unsupported = true;
    29fc:	04015783          	lhu	a5,64(sp)
    2a00:	ffff8737          	lui	a4,0xffff8
    2a04:	7fd70713          	addi	a4,a4,2045 # ffff87fd <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff87fe>
    2a08:	00e7f7b3          	and	a5,a5,a4
    2a0c:	00004737          	lui	a4,0x4
    2a10:	00270713          	addi	a4,a4,2 # 4002 <k_sched_time_slice_set+0x4a>
    2a14:	f3dff06f          	j	2950 <cbvprintf+0x464>
	switch (conv->specifier) {
    2a18:	fa870793          	addi	a5,a4,-88
    2a1c:	0ff7f793          	andi	a5,a5,255
    2a20:	02000693          	li	a3,32
    2a24:	0cf6e663          	bltu	a3,a5,2af0 <cbvprintf+0x604>
    2a28:	000056b7          	lui	a3,0x5
    2a2c:	00279793          	slli	a5,a5,0x2
    2a30:	f5068693          	addi	a3,a3,-176 # 4f50 <__clz_tab+0x208>
    2a34:	00d787b3          	add	a5,a5,a3
    2a38:	0007a783          	lw	a5,0(a5)
    2a3c:	00078067          	jr	a5
		conv->specifier_cat = SPECIFIER_SINT;
    2a40:	04214783          	lbu	a5,66(sp)
    2a44:	ff87f793          	andi	a5,a5,-8
    2a48:	0017e793          	ori	a5,a5,1
		if (conv->length_mod == LENGTH_UPPER_L) {
    2a4c:	04015683          	lhu	a3,64(sp)
		conv->specifier_cat = SPECIFIER_UINT;
    2a50:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    2a54:	000087b7          	lui	a5,0x8
    2a58:	80078793          	addi	a5,a5,-2048 # 7800 <__data_region_end+0x1744>
    2a5c:	00f6f7b3          	and	a5,a3,a5
    2a60:	01079793          	slli	a5,a5,0x10
    2a64:	0107d793          	srli	a5,a5,0x10
    2a68:	00004637          	lui	a2,0x4
    2a6c:	00c79663          	bne	a5,a2,2a78 <cbvprintf+0x58c>
			conv->invalid = true;
    2a70:	0016e693          	ori	a3,a3,1
    2a74:	04d11023          	sh	a3,64(sp)
		if (conv->specifier == 'c') {
    2a78:	06300693          	li	a3,99
	bool unsupported = false;
    2a7c:	00000793          	li	a5,0
		if (conv->specifier == 'c') {
    2a80:	e6d718e3          	bne	a4,a3,28f0 <cbvprintf+0x404>
		if (conv->length_mod != LENGTH_NONE) {
    2a84:	04015703          	lhu	a4,64(sp)
    2a88:	000087b7          	lui	a5,0x8
    2a8c:	80078793          	addi	a5,a5,-2048 # 7800 <__data_region_end+0x1744>
    2a90:	00e7f7b3          	and	a5,a5,a4
    2a94:	00f037b3          	snez	a5,a5
    2a98:	e59ff06f          	j	28f0 <cbvprintf+0x404>
		conv->specifier_cat = SPECIFIER_UINT;
    2a9c:	04214783          	lbu	a5,66(sp)
    2aa0:	ff87f793          	andi	a5,a5,-8
    2aa4:	0027e793          	ori	a5,a5,2
    2aa8:	fa5ff06f          	j	2a4c <cbvprintf+0x560>
		conv->specifier_cat = SPECIFIER_PTR;
    2aac:	04214783          	lbu	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    2ab0:	04015703          	lhu	a4,64(sp)
		conv->specifier_cat = SPECIFIER_PTR;
    2ab4:	ff87f793          	andi	a5,a5,-8
    2ab8:	0037e793          	ori	a5,a5,3
    2abc:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    2ac0:	000087b7          	lui	a5,0x8
    2ac4:	80078793          	addi	a5,a5,-2048 # 7800 <__data_region_end+0x1744>
    2ac8:	00e7f7b3          	and	a5,a5,a4
    2acc:	ffffc737          	lui	a4,0xffffc
    2ad0:	00e787b3          	add	a5,a5,a4
    2ad4:	0017b793          	seqz	a5,a5
    2ad8:	e19ff06f          	j	28f0 <cbvprintf+0x404>
		conv->specifier_cat = SPECIFIER_PTR;
    2adc:	04214783          	lbu	a5,66(sp)
    2ae0:	ff87f793          	andi	a5,a5,-8
    2ae4:	0037e793          	ori	a5,a5,3
    2ae8:	04f10123          	sb	a5,66(sp)
    2aec:	f99ff06f          	j	2a84 <cbvprintf+0x598>
		conv->invalid = true;
    2af0:	04015783          	lhu	a5,64(sp)
    2af4:	0017e793          	ori	a5,a5,1
    2af8:	04f11023          	sh	a5,64(sp)
	bool unsupported = false;
    2afc:	00000793          	li	a5,0
		break;
    2b00:	df1ff06f          	j	28f0 <cbvprintf+0x404>
		} else if (conv->width_present) {
    2b04:	0807f793          	andi	a5,a5,128
    2b08:	00078863          	beqz	a5,2b18 <cbvprintf+0x62c>
			width = conv->width_value;
    2b0c:	04412483          	lw	s1,68(sp)
    2b10:	000c8413          	mv	s0,s9
    2b14:	ad1ff06f          	j	25e4 <cbvprintf+0xf8>
    2b18:	000c8413          	mv	s0,s9
		int width = -1;
    2b1c:	fff00493          	li	s1,-1
    2b20:	ac5ff06f          	j	25e4 <cbvprintf+0xf8>
		} else if (conv->prec_present) {
    2b24:	20077713          	andi	a4,a4,512
		int precision = -1;
    2b28:	fff00a93          	li	s5,-1
		} else if (conv->prec_present) {
    2b2c:	ac070ee3          	beqz	a4,2608 <cbvprintf+0x11c>
			precision = conv->prec_value;
    2b30:	04812a83          	lw	s5,72(sp)
    2b34:	ad5ff06f          	j	2608 <cbvprintf+0x11c>
					value->sint = va_arg(ap, long);
    2b38:	00440513          	addi	a0,s0,4
					value->uint = (wchar_t)va_arg(ap,
    2b3c:	00042683          	lw	a3,0(s0)
    2b40:	02d12823          	sw	a3,48(sp)
    2b44:	41f6d693          	srai	a3,a3,0x1f
    2b48:	01c0006f          	j	2b64 <cbvprintf+0x678>
					(sint_value_type)va_arg(ap, long long);
    2b4c:	00740413          	addi	s0,s0,7
    2b50:	ff847413          	andi	s0,s0,-8
				value->sint =
    2b54:	00042603          	lw	a2,0(s0)
    2b58:	00442683          	lw	a3,4(s0)
					(sint_value_type)va_arg(ap, long long);
    2b5c:	00840513          	addi	a0,s0,8
				value->sint =
    2b60:	02c12823          	sw	a2,48(sp)
    2b64:	02d12a23          	sw	a3,52(sp)
					(uint_value_type)va_arg(ap, size_t);
    2b68:	00050413          	mv	s0,a0
    2b6c:	b05ff06f          	j	2670 <cbvprintf+0x184>
			} else if (length_mod == LENGTH_H) {
    2b70:	00200693          	li	a3,2
    2b74:	aed71ee3          	bne	a4,a3,2670 <cbvprintf+0x184>
				value->sint = (short)value->sint;
    2b78:	03011683          	lh	a3,48(sp)
    2b7c:	02d12823          	sw	a3,48(sp)
    2b80:	41f6d693          	srai	a3,a3,0x1f
				value->dbl = va_arg(ap, double);
    2b84:	02d12a23          	sw	a3,52(sp)
    2b88:	ae9ff06f          	j	2670 <cbvprintf+0x184>
		} else if (specifier_cat == SPECIFIER_UINT) {
    2b8c:	00200513          	li	a0,2
    2b90:	06a69463          	bne	a3,a0,2bf8 <cbvprintf+0x70c>
			switch (length_mod) {
    2b94:	00500693          	li	a3,5
    2b98:	fad70ae3          	beq	a4,a3,2b4c <cbvprintf+0x660>
    2b9c:	00e6ea63          	bltu	a3,a4,2bb0 <cbvprintf+0x6c4>
    2ba0:	00300693          	li	a3,3
    2ba4:	02d70a63          	beq	a4,a3,2bd8 <cbvprintf+0x6ec>
    2ba8:	00400693          	li	a3,4
    2bac:	fad700e3          	beq	a4,a3,2b4c <cbvprintf+0x660>
					(uint_value_type)va_arg(ap, size_t);
    2bb0:	00042683          	lw	a3,0(s0)
    2bb4:	02012a23          	sw	zero,52(sp)
    2bb8:	00440413          	addi	s0,s0,4
    2bbc:	02d12823          	sw	a3,48(sp)
			if (length_mod == LENGTH_HH) {
    2bc0:	00100693          	li	a3,1
    2bc4:	aad700e3          	beq	a4,a3,2664 <cbvprintf+0x178>
			} else if (length_mod == LENGTH_H) {
    2bc8:	00200693          	li	a3,2
    2bcc:	aad712e3          	bne	a4,a3,2670 <cbvprintf+0x184>
				value->uint = (unsigned short)value->uint;
    2bd0:	03015683          	lhu	a3,48(sp)
    2bd4:	a95ff06f          	j	2668 <cbvprintf+0x17c>
				if ((!WCHAR_IS_SIGNED)
    2bd8:	04314603          	lbu	a2,67(sp)
    2bdc:	06300693          	li	a3,99
				value->sint = va_arg(ap, int);
    2be0:	00440513          	addi	a0,s0,4
				if ((!WCHAR_IS_SIGNED)
    2be4:	f4d60ce3          	beq	a2,a3,2b3c <cbvprintf+0x650>
					value->uint = va_arg(ap, unsigned long);
    2be8:	00042683          	lw	a3,0(s0)
    2bec:	02012a23          	sw	zero,52(sp)
    2bf0:	02d12823          	sw	a3,48(sp)
    2bf4:	f75ff06f          	j	2b68 <cbvprintf+0x67c>
		} else if (specifier_cat == SPECIFIER_FP) {
    2bf8:	00400613          	li	a2,4
    2bfc:	04c69a63          	bne	a3,a2,2c50 <cbvprintf+0x764>
			if (length_mod == LENGTH_UPPER_L) {
    2c00:	00800693          	li	a3,8
    2c04:	02d71863          	bne	a4,a3,2c34 <cbvprintf+0x748>
				value->ldbl = va_arg(ap, long double);
    2c08:	00042683          	lw	a3,0(s0)
    2c0c:	0006a803          	lw	a6,0(a3)
    2c10:	0046a503          	lw	a0,4(a3)
    2c14:	0086a603          	lw	a2,8(a3)
    2c18:	00c6a683          	lw	a3,12(a3)
    2c1c:	03012823          	sw	a6,48(sp)
    2c20:	02a12a23          	sw	a0,52(sp)
    2c24:	02c12c23          	sw	a2,56(sp)
    2c28:	02d12e23          	sw	a3,60(sp)
			value->ptr = va_arg(ap, void *);
    2c2c:	00440413          	addi	s0,s0,4
    2c30:	a41ff06f          	j	2670 <cbvprintf+0x184>
				value->dbl = va_arg(ap, double);
    2c34:	00740693          	addi	a3,s0,7
    2c38:	ff86f693          	andi	a3,a3,-8
    2c3c:	0006a603          	lw	a2,0(a3)
    2c40:	00868413          	addi	s0,a3,8
    2c44:	0046a683          	lw	a3,4(a3)
    2c48:	02c12823          	sw	a2,48(sp)
    2c4c:	f39ff06f          	j	2b84 <cbvprintf+0x698>
		} else if (specifier_cat == SPECIFIER_PTR) {
    2c50:	00300613          	li	a2,3
    2c54:	a0c69ee3          	bne	a3,a2,2670 <cbvprintf+0x184>
			value->ptr = va_arg(ap, void *);
    2c58:	00042683          	lw	a3,0(s0)
    2c5c:	02d12823          	sw	a3,48(sp)
    2c60:	fcdff06f          	j	2c2c <cbvprintf+0x740>
		switch (conv->specifier) {
    2c64:	04314683          	lbu	a3,67(sp)
    2c68:	07800613          	li	a2,120
    2c6c:	92d664e3          	bltu	a2,a3,2594 <cbvprintf+0xa8>
    2c70:	06200613          	li	a2,98
    2c74:	00d66e63          	bltu	a2,a3,2c90 <cbvprintf+0x7a4>
    2c78:	02500713          	li	a4,37
    2c7c:	02e68c63          	beq	a3,a4,2cb4 <cbvprintf+0x7c8>
    2c80:	05800713          	li	a4,88
    2c84:	90e698e3          	bne	a3,a4,2594 <cbvprintf+0xa8>
    2c88:	00000b13          	li	s6,0
    2c8c:	2080006f          	j	2e94 <cbvprintf+0x9a8>
    2c90:	f9d68693          	addi	a3,a3,-99
    2c94:	0ff6f693          	andi	a3,a3,255
    2c98:	01500613          	li	a2,21
    2c9c:	8ed66ce3          	bltu	a2,a3,2594 <cbvprintf+0xa8>
    2ca0:	00412783          	lw	a5,4(sp)
    2ca4:	00269693          	slli	a3,a3,0x2
    2ca8:	00f686b3          	add	a3,a3,a5
    2cac:	0006a683          	lw	a3,0(a3)
    2cb0:	00068067          	jr	a3
			OUTC('%');
    2cb4:	00098593          	mv	a1,s3
    2cb8:	02500513          	li	a0,37
    2cbc:	000900e7          	jalr	s2
    2cc0:	2c054a63          	bltz	a0,2f94 <cbvprintf+0xaa8>
    2cc4:	001d8d93          	addi	s11,s11,1
			break;
    2cc8:	8cdff06f          	j	2594 <cbvprintf+0xa8>
			bps = (const char *)value->ptr;
    2ccc:	03012c83          	lw	s9,48(sp)
			if (precision >= 0) {
    2cd0:	160ac063          	bltz	s5,2e30 <cbvprintf+0x944>
				len = strnlen(bps, precision);
    2cd4:	000a8593          	mv	a1,s5
    2cd8:	000c8513          	mv	a0,s9
    2cdc:	474000ef          	jal	ra,3150 <strnlen>
			bpe = bps + len;
    2ce0:	00ac8d33          	add	s10,s9,a0
		char sign = 0;
    2ce4:	00000b13          	li	s6,0
		if (bps == NULL) {
    2ce8:	8a0c86e3          	beqz	s9,2594 <cbvprintf+0xa8>
		size_t nj_len = (bpe - bps);
    2cec:	419d07b3          	sub	a5,s10,s9
		if (sign != 0) {
    2cf0:	000b0463          	beqz	s6,2cf8 <cbvprintf+0x80c>
			nj_len += 1U;
    2cf4:	00178793          	addi	a5,a5,1
		if (conv->altform_0c) {
    2cf8:	04214703          	lbu	a4,66(sp)
    2cfc:	01077693          	andi	a3,a4,16
    2d00:	26068663          	beqz	a3,2f6c <cbvprintf+0xa80>
			nj_len += 2U;
    2d04:	00278793          	addi	a5,a5,2
		nj_len += conv->pad0_value;
    2d08:	04412683          	lw	a3,68(sp)
		if (conv->pad_fp) {
    2d0c:	04077713          	andi	a4,a4,64
		nj_len += conv->pad0_value;
    2d10:	00d787b3          	add	a5,a5,a3
		if (conv->pad_fp) {
    2d14:	00070663          	beqz	a4,2d20 <cbvprintf+0x834>
			nj_len += conv->pad0_pre_exp;
    2d18:	04812703          	lw	a4,72(sp)
    2d1c:	00e787b3          	add	a5,a5,a4
		if (width > 0) {
    2d20:	04905c63          	blez	s1,2d78 <cbvprintf+0x88c>
			width -= (int)nj_len;
    2d24:	40f484b3          	sub	s1,s1,a5
			if (!conv->flag_dash) {
    2d28:	04012783          	lw	a5,64(sp)
    2d2c:	0027d793          	srli	a5,a5,0x2
    2d30:	0017f793          	andi	a5,a5,1
    2d34:	04079263          	bnez	a5,2d78 <cbvprintf+0x88c>
				if (conv->flag_zero) {
    2d38:	04015783          	lhu	a5,64(sp)
    2d3c:	0407f793          	andi	a5,a5,64
    2d40:	28078863          	beqz	a5,2fd0 <cbvprintf+0xae4>
					if (sign != 0) {
    2d44:	280b0a63          	beqz	s6,2fd8 <cbvprintf+0xaec>
						OUTC(sign);
    2d48:	00098593          	mv	a1,s3
    2d4c:	000b0513          	mv	a0,s6
    2d50:	000900e7          	jalr	s2
    2d54:	24054063          	bltz	a0,2f94 <cbvprintf+0xaa8>
    2d58:	001d8d93          	addi	s11,s11,1
					pad = '0';
    2d5c:	03000793          	li	a5,48
						sign = 0;
    2d60:	00000b13          	li	s6,0
    2d64:	01b48ab3          	add	s5,s1,s11
    2d68:	00048713          	mv	a4,s1
    2d6c:	409a8db3          	sub	s11,s5,s1
				while (width-- > 0) {
    2d70:	fff48493          	addi	s1,s1,-1
    2d74:	20e04463          	bgtz	a4,2f7c <cbvprintf+0xa90>
		if (sign != 0) {
    2d78:	000b0c63          	beqz	s6,2d90 <cbvprintf+0x8a4>
			OUTC(sign);
    2d7c:	00098593          	mv	a1,s3
    2d80:	000b0513          	mv	a0,s6
    2d84:	000900e7          	jalr	s2
    2d88:	20054663          	bltz	a0,2f94 <cbvprintf+0xaa8>
    2d8c:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c | conv->altform_0) {
    2d90:	04012783          	lw	a5,64(sp)
    2d94:	0147d713          	srli	a4,a5,0x14
    2d98:	00177713          	andi	a4,a4,1
    2d9c:	00071863          	bnez	a4,2dac <cbvprintf+0x8c0>
    2da0:	0137d793          	srli	a5,a5,0x13
    2da4:	0017f793          	andi	a5,a5,1
    2da8:	00078c63          	beqz	a5,2dc0 <cbvprintf+0x8d4>
				OUTC('0');
    2dac:	00098593          	mv	a1,s3
    2db0:	03000513          	li	a0,48
    2db4:	000900e7          	jalr	s2
    2db8:	1c054e63          	bltz	a0,2f94 <cbvprintf+0xaa8>
    2dbc:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c) {
    2dc0:	04214783          	lbu	a5,66(sp)
    2dc4:	0107f793          	andi	a5,a5,16
    2dc8:	00078c63          	beqz	a5,2de0 <cbvprintf+0x8f4>
				OUTC(conv->specifier);
    2dcc:	04314503          	lbu	a0,67(sp)
    2dd0:	00098593          	mv	a1,s3
    2dd4:	000900e7          	jalr	s2
    2dd8:	1a054e63          	bltz	a0,2f94 <cbvprintf+0xaa8>
    2ddc:	001d8d93          	addi	s11,s11,1
			while (pad_len-- > 0) {
    2de0:	04412783          	lw	a5,68(sp)
    2de4:	01b78ab3          	add	s5,a5,s11
    2de8:	41ba8733          	sub	a4,s5,s11
    2dec:	1ee04a63          	bgtz	a4,2fe0 <cbvprintf+0xaf4>
			OUTS(bps, bpe);
    2df0:	000d0693          	mv	a3,s10
    2df4:	000c8613          	mv	a2,s9
    2df8:	00098593          	mv	a1,s3
    2dfc:	00090513          	mv	a0,s2
    2e00:	e74ff0ef          	jal	ra,2474 <outs>
    2e04:	18054863          	bltz	a0,2f94 <cbvprintf+0xaa8>
    2e08:	01b50db3          	add	s11,a0,s11
		while (width > 0) {
    2e0c:	01b484b3          	add	s1,s1,s11
    2e10:	41b487b3          	sub	a5,s1,s11
    2e14:	f8f05063          	blez	a5,2594 <cbvprintf+0xa8>
			OUTC(' ');
    2e18:	00098593          	mv	a1,s3
    2e1c:	02000513          	li	a0,32
    2e20:	000900e7          	jalr	s2
    2e24:	16054863          	bltz	a0,2f94 <cbvprintf+0xaa8>
    2e28:	001d8d93          	addi	s11,s11,1
			--width;
    2e2c:	fe5ff06f          	j	2e10 <cbvprintf+0x924>
				len = strlen(bps);
    2e30:	000c8513          	mv	a0,s9
    2e34:	2fc000ef          	jal	ra,3130 <strlen>
    2e38:	ea9ff06f          	j	2ce0 <cbvprintf+0x7f4>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    2e3c:	03012783          	lw	a5,48(sp)
			bps = buf;
    2e40:	01810c93          	addi	s9,sp,24
			bpe = buf + 1;
    2e44:	01910d13          	addi	s10,sp,25
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    2e48:	00f10c23          	sb	a5,24(sp)
			break;
    2e4c:	00000b13          	li	s6,0
    2e50:	e9dff06f          	j	2cec <cbvprintf+0x800>
			if (conv->flag_plus) {
    2e54:	04015703          	lhu	a4,64(sp)
				sign = '+';
    2e58:	02b00b13          	li	s6,43
			if (conv->flag_plus) {
    2e5c:	00877693          	andi	a3,a4,8
    2e60:	00069663          	bnez	a3,2e6c <cbvprintf+0x980>
				sign = ' ';
    2e64:	00171b13          	slli	s6,a4,0x1
    2e68:	020b7b13          	andi	s6,s6,32
			sint = value->sint;
    2e6c:	03412703          	lw	a4,52(sp)
    2e70:	03012683          	lw	a3,48(sp)
			if (sint < 0) {
    2e74:	02075063          	bgez	a4,2e94 <cbvprintf+0x9a8>
				value->uint = (uint_value_type)-sint;
    2e78:	40d00633          	neg	a2,a3
    2e7c:	40e00733          	neg	a4,a4
    2e80:	00d036b3          	snez	a3,a3
    2e84:	40d70733          	sub	a4,a4,a3
    2e88:	02c12823          	sw	a2,48(sp)
    2e8c:	02e12a23          	sw	a4,52(sp)
				sign = '-';
    2e90:	02d00b13          	li	s6,45
			bps = encode_uint(value->uint, conv, buf, bpe);
    2e94:	03012503          	lw	a0,48(sp)
    2e98:	03412583          	lw	a1,52(sp)
    2e9c:	02e10713          	addi	a4,sp,46
    2ea0:	01810693          	addi	a3,sp,24
    2ea4:	04010613          	addi	a2,sp,64
    2ea8:	c70ff0ef          	jal	ra,2318 <encode_uint>
    2eac:	00050c93          	mv	s9,a0
			if (precision >= 0) {
    2eb0:	02e10d13          	addi	s10,sp,46
    2eb4:	e20acae3          	bltz	s5,2ce8 <cbvprintf+0x7fc>
				conv->flag_zero = false;
    2eb8:	04015683          	lhu	a3,64(sp)
				size_t len = bpe - bps;
    2ebc:	419d0733          	sub	a4,s10,s9
				conv->flag_zero = false;
    2ec0:	fbf6f693          	andi	a3,a3,-65
    2ec4:	04d11023          	sh	a3,64(sp)
				if (len < (size_t)precision) {
    2ec8:	e35770e3          	bgeu	a4,s5,2ce8 <cbvprintf+0x7fc>
					conv->pad0_value = precision - (int)len;
    2ecc:	40ea87b3          	sub	a5,s5,a4
    2ed0:	04f12223          	sw	a5,68(sp)
    2ed4:	e15ff06f          	j	2ce8 <cbvprintf+0x7fc>
			if (value->ptr != NULL) {
    2ed8:	03012503          	lw	a0,48(sp)
    2edc:	08050263          	beqz	a0,2f60 <cbvprintf+0xa74>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    2ee0:	02e10713          	addi	a4,sp,46
    2ee4:	01810693          	addi	a3,sp,24
    2ee8:	04010613          	addi	a2,sp,64
    2eec:	00000593          	li	a1,0
    2ef0:	c28ff0ef          	jal	ra,2318 <encode_uint>
				conv->altform_0c = true;
    2ef4:	04215703          	lhu	a4,66(sp)
    2ef8:	000086b7          	lui	a3,0x8
    2efc:	81068693          	addi	a3,a3,-2032 # 7810 <__data_region_end+0x1754>
    2f00:	0ef77713          	andi	a4,a4,239
    2f04:	00d76733          	or	a4,a4,a3
				bps = encode_uint((uintptr_t)value->ptr, conv,
    2f08:	00050c93          	mv	s9,a0
				conv->altform_0c = true;
    2f0c:	04e11123          	sh	a4,66(sp)
		char sign = 0;
    2f10:	00000b13          	li	s6,0
				goto prec_int_pad0;
    2f14:	f9dff06f          	j	2eb0 <cbvprintf+0x9c4>
	switch ((enum length_mod_enum)conv->length_mod) {
    2f18:	00700693          	li	a3,7
				store_count(conv, value->ptr, count);
    2f1c:	03012783          	lw	a5,48(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
    2f20:	e6e6ea63          	bltu	a3,a4,2594 <cbvprintf+0xa8>
    2f24:	00812683          	lw	a3,8(sp)
    2f28:	00271713          	slli	a4,a4,0x2
    2f2c:	00d70733          	add	a4,a4,a3
    2f30:	00072703          	lw	a4,0(a4) # ffffc000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffffc001>
    2f34:	00070067          	jr	a4
		*(signed char *)dp = (signed char)count;
    2f38:	01b78023          	sb	s11,0(a5)
		break;
    2f3c:	e58ff06f          	j	2594 <cbvprintf+0xa8>
		*(short *)dp = (short)count;
    2f40:	01b79023          	sh	s11,0(a5)
		break;
    2f44:	e50ff06f          	j	2594 <cbvprintf+0xa8>
		*(intmax_t *)dp = (intmax_t)count;
    2f48:	41fdd713          	srai	a4,s11,0x1f
    2f4c:	01b7a023          	sw	s11,0(a5)
    2f50:	00e7a223          	sw	a4,4(a5)
		break;
    2f54:	e40ff06f          	j	2594 <cbvprintf+0xa8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    2f58:	01b7a023          	sw	s11,0(a5)
		break;
    2f5c:	e38ff06f          	j	2594 <cbvprintf+0xa8>
			bps = "(nil)";
    2f60:	000b8c93          	mv	s9,s7
			bpe = bps + 5;
    2f64:	000c0d13          	mv	s10,s8
    2f68:	ee5ff06f          	j	2e4c <cbvprintf+0x960>
		} else if (conv->altform_0) {
    2f6c:	00877693          	andi	a3,a4,8
    2f70:	d8068ce3          	beqz	a3,2d08 <cbvprintf+0x81c>
			nj_len += 1U;
    2f74:	00178793          	addi	a5,a5,1
    2f78:	d91ff06f          	j	2d08 <cbvprintf+0x81c>
					OUTC(pad);
    2f7c:	00078513          	mv	a0,a5
    2f80:	00098593          	mv	a1,s3
    2f84:	00f12623          	sw	a5,12(sp)
    2f88:	000900e7          	jalr	s2
    2f8c:	00c12783          	lw	a5,12(sp)
    2f90:	dc055ce3          	bgez	a0,2d68 <cbvprintf+0x87c>
#undef OUTS
#undef OUTC
}
    2f94:	08c12083          	lw	ra,140(sp)
    2f98:	08812403          	lw	s0,136(sp)
    2f9c:	08412483          	lw	s1,132(sp)
    2fa0:	08012903          	lw	s2,128(sp)
    2fa4:	07c12983          	lw	s3,124(sp)
    2fa8:	07812a03          	lw	s4,120(sp)
    2fac:	07412a83          	lw	s5,116(sp)
    2fb0:	07012b03          	lw	s6,112(sp)
    2fb4:	06c12b83          	lw	s7,108(sp)
    2fb8:	06812c03          	lw	s8,104(sp)
    2fbc:	06412c83          	lw	s9,100(sp)
    2fc0:	06012d03          	lw	s10,96(sp)
    2fc4:	05c12d83          	lw	s11,92(sp)
    2fc8:	09010113          	addi	sp,sp,144
    2fcc:	00008067          	ret
				char pad = ' ';
    2fd0:	02000793          	li	a5,32
    2fd4:	d91ff06f          	j	2d64 <cbvprintf+0x878>
					pad = '0';
    2fd8:	03000793          	li	a5,48
    2fdc:	d89ff06f          	j	2d64 <cbvprintf+0x878>
				OUTC('0');
    2fe0:	00098593          	mv	a1,s3
    2fe4:	03000513          	li	a0,48
    2fe8:	000900e7          	jalr	s2
    2fec:	fa0544e3          	bltz	a0,2f94 <cbvprintf+0xaa8>
    2ff0:	001d8d93          	addi	s11,s11,1
    2ff4:	df5ff06f          	j	2de8 <cbvprintf+0x8fc>

00002ff8 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    2ff8:	00008067          	ret

00002ffc <soc_interrupt_init>:
static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	unsigned int key;
	ulong_t mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
    2ffc:	00800793          	li	a5,8
    3000:	3007b7f3          	csrrc	a5,mstatus,a5
void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
    3004:	30405073          	csrwi	mie,0
    3008:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
    300c:	00008067          	ret

00003010 <fix_baud_rate>:
	*(volatile uint16_t *)addr = data;
}

static ALWAYS_INLINE uint32_t sys_read32(mem_addr_t addr)
{
	return *(volatile uint32_t *)addr;
    3010:	800017b7          	lui	a5,0x80001
    3014:	03c7a783          	lw	a5,60(a5) # 8000103c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000103d>

	/*
	 * calculate baud rate divisor. a variant of
	 * (uint32_t)(dev_cfg->sys_clk_freq / (16.0 * baud_rate) + 0.5)
	 */
	divisor = ((sys_clk_freq + (baud_rate << 3))
    3018:	000e1737          	lui	a4,0xe1
	return *(volatile uint8_t *)addr;
    301c:	800026b7          	lui	a3,0x80002
    3020:	00e787b3          	add	a5,a5,a4
		   / baud_rate) >> 4;
    3024:	0001c737          	lui	a4,0x1c
    3028:	20070713          	addi	a4,a4,512 # 1c200 <__data_region_end+0x16144>
    302c:	02e7d7b3          	divu	a5,a5,a4
    3030:	00c6c703          	lbu	a4,12(a3) # 8000200c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000200d>
	sys_write8((divisor >> 8) & 0xff, REG_BRDH);

	sys_write8(lcr_cache, REG_LCR);

	return 0;
}
    3034:	00000513          	li	a0,0
    3038:	0ff77613          	andi	a2,a4,255
	sys_write8(lcr_cache | LCR_DLAB, REG_LCR);
    303c:	f8076713          	ori	a4,a4,-128
    3040:	0ff77713          	andi	a4,a4,255
	*(volatile uint8_t *)addr = data;
    3044:	00e68623          	sb	a4,12(a3)
	divisor = ((sys_clk_freq + (baud_rate << 3))
    3048:	0047d713          	srli	a4,a5,0x4
	sys_write8( divisor       & 0xff, REG_BRDL);
    304c:	0ff77713          	andi	a4,a4,255
	sys_write8((divisor >> 8) & 0xff, REG_BRDH);
    3050:	00c7d793          	srli	a5,a5,0xc
    3054:	00e68023          	sb	a4,0(a3)
    3058:	0ff7f793          	andi	a5,a5,255
    305c:	00f68223          	sb	a5,4(a3)
    3060:	00c68623          	sb	a2,12(a3)
}
    3064:	00008067          	ret

00003068 <arch_cpu_idle>:
 */
static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	ulong_t mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
    3068:	00800793          	li	a5,8
    306c:	3007a7f3          	csrrs	a5,mstatus,a5
 */

void __weak arch_cpu_idle(void)
{
	irq_unlock(MSTATUS_IEN);
}
    3070:	00008067          	ret

00003074 <z_riscv_fatal_error>:
 #define NO_REG "                "
#endif

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
    3074:	ff010113          	addi	sp,sp,-16
    3078:	00112623          	sw	ra,12(sp)
		LOG_ERR("   mepc: " PR_REG, esf->mepc);
		LOG_ERR("mstatus: " PR_REG, esf->mstatus);
		LOG_ERR("");
	}

	z_fatal_error(reason, esf);
    307c:	2b1000ef          	jal	ra,3b2c <z_fatal_error>

00003080 <_Fault>:
		return "unknown";
	}
}

void _Fault(z_arch_esf_t *esf)
{
    3080:	ff010113          	addi	sp,sp,-16
    3084:	00112623          	sw	ra,12(sp)
    3088:	00050593          	mv	a1,a0
		}
	}
#endif /* CONFIG_USERSPACE */
	ulong_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
    308c:	342027f3          	csrr	a5,mcause

#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	ulong_t mtval;
	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
    3090:	343027f3          	csrr	a5,mtval
	z_fatal_error(reason, esf);
    3094:	00000513          	li	a0,0
    3098:	295000ef          	jal	ra,3b2c <z_fatal_error>

0000309c <z_irq_spurious>:
#include <kernel_internal.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
    309c:	ff010113          	addi	sp,sp,-16
    30a0:	00112623          	sw	ra,12(sp)
	ulong_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
    30a4:	342027f3          	csrr	a5,mcause
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    30a8:	00000593          	li	a1,0
    30ac:	00100513          	li	a0,1
    30b0:	fc5ff0ef          	jal	ra,3074 <z_riscv_fatal_error>

000030b4 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
    30b4:	ff010113          	addi	sp,sp,-16
    30b8:	00112623          	sw	ra,12(sp)
	z_bss_zero();
    30bc:	3a5000ef          	jal	ra,3c60 <z_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
    30c0:	f3dff0ef          	jal	ra,2ffc <soc_interrupt_init>
#endif
#ifdef CONFIG_PMP_STACK_GUARD
	z_riscv_configure_interrupt_stack_guard();
#endif
	z_cstart();
    30c4:	3bd000ef          	jal	ra,3c80 <z_cstart>

000030c8 <__initialize>:
SECTION_FUNC(TEXT, __initialize)
	/*
	 * This will boot master core, just halt other cores.
	 * Note: need to be updated for complete SMP support
	 */
	csrr a0, mhartid
    30c8:	f1402573          	csrr	a0,mhartid
	beqz a0, boot_master_core
    30cc:	00050663          	beqz	a0,30d8 <boot_master_core>

000030d0 <loop_slave_core>:

loop_slave_core:
	wfi
    30d0:	10500073          	wfi
	j loop_slave_core
    30d4:	ffdff06f          	j	30d0 <loop_slave_core>

000030d8 <boot_master_core>:

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + CONFIG_ISR_STACK_SIZE
	 */
	la sp, z_interrupt_stacks
    30d8:	00002117          	auipc	sp,0x2
    30dc:	7b810113          	addi	sp,sp,1976 # 5890 <z_interrupt_stacks>
	li t0, CONFIG_ISR_STACK_SIZE
    30e0:	000012b7          	lui	t0,0x1
    30e4:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
    30e8:	00510133          	add	sp,sp,t0

	csrw mscratch, sp
    30ec:	34011073          	csrw	mscratch,sp

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
    30f0:	fc5ff0ef          	jal	ra,30b4 <_PrepC>

000030f4 <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
    30f4:	a00ff06f          	j	22f4 <z_thread_entry>

000030f8 <arch_new_thread>:
#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	const struct soc_esf soc_esf_init = {SOC_ESF_INIT};
#endif

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)Z_STACK_PTR_ALIGN(
    30f8:	fb460613          	addi	a2,a2,-76 # 3fb4 <z_reset_time_slice+0x54>
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
    30fc:	ff067613          	andi	a2,a2,-16
				);

	/* Setup the initial stack frame */
	stack_init->a0 = (ulong_t)entry;
	stack_init->a1 = (ulong_t)p1;
	stack_init->a2 = (ulong_t)p2;
    3100:	02f62623          	sw	a5,44(a2)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = MSTATUS_DEF_RESTORE;
    3104:	000027b7          	lui	a5,0x2
    3108:	88078793          	addi	a5,a5,-1920 # 1880 <__subsf3+0x194>
    310c:	04f62423          	sw	a5,72(a2)
#elif defined(CONFIG_FPU)
	/* Unshared FP mode: enable FPU of each thread. */
	stack_init->mstatus |= MSTATUS_FS_INIT;
#endif

	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
    3110:	000037b7          	lui	a5,0x3
    3114:	0f478793          	addi	a5,a5,244 # 30f4 <z_thread_entry_wrapper>
	stack_init->a0 = (ulong_t)entry;
    3118:	02d62223          	sw	a3,36(a2)
	stack_init->a1 = (ulong_t)p1;
    311c:	02e62423          	sw	a4,40(a2)
	stack_init->a3 = (ulong_t)p3;
    3120:	03062823          	sw	a6,48(a2)
	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
    3124:	04f62223          	sw	a5,68(a2)

#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	stack_init->soc_context = soc_esf_init;
#endif

	thread->callee_saved.sp = (ulong_t)stack_init;
    3128:	02c52823          	sw	a2,48(a0)
}
    312c:	00008067          	ret

00003130 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    3130:	00050793          	mv	a5,a0
	size_t n = 0;
    3134:	00000513          	li	a0,0

	while (*s != '\0') {
    3138:	00a78733          	add	a4,a5,a0
    313c:	00074703          	lbu	a4,0(a4)
    3140:	00071463          	bnez	a4,3148 <strlen+0x18>
		s++;
		n++;
	}

	return n;
}
    3144:	00008067          	ret
		n++;
    3148:	00150513          	addi	a0,a0,1
    314c:	fedff06f          	j	3138 <strlen+0x8>

00003150 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    3150:	00050793          	mv	a5,a0
	size_t n = 0;
    3154:	00000513          	li	a0,0

	while (*s != '\0' && n < maxlen) {
    3158:	00a78733          	add	a4,a5,a0
    315c:	00074703          	lbu	a4,0(a4)
    3160:	00070463          	beqz	a4,3168 <strnlen+0x18>
    3164:	00b51463          	bne	a0,a1,316c <strnlen+0x1c>
		s++;
		n++;
	}

	return n;
}
    3168:	00008067          	ret
		n++;
    316c:	00150513          	addi	a0,a0,1
    3170:	fe9ff06f          	j	3158 <strnlen+0x8>

00003174 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    3174:	0ff5f593          	andi	a1,a1,255
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    3178:	00c50633          	add	a2,a0,a2
	unsigned char *d_byte = (unsigned char *)buf;
    317c:	00050793          	mv	a5,a0
	while (n > 0) {
    3180:	00c79463          	bne	a5,a2,3188 <memset+0x14>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    3184:	00008067          	ret
		*(d_byte++) = c_byte;
    3188:	00178793          	addi	a5,a5,1
    318c:	feb78fa3          	sb	a1,-1(a5)
		n--;
    3190:	ff1ff06f          	j	3180 <memset+0xc>

00003194 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
    3194:	fff00513          	li	a0,-1
    3198:	00008067          	ret

0000319c <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    319c:	000067b7          	lui	a5,0x6
    31a0:	08a7aa23          	sw	a0,148(a5) # 6094 <_stdout_hook>
}
    31a4:	00008067          	ret

000031a8 <z_impl_sys_rand32_get>:
 *
 * @return a 32-bit number
 */

uint32_t z_impl_sys_rand32_get(void)
{
    31a8:	ff010113          	addi	sp,sp,-16
    31ac:	00812423          	sw	s0,8(sp)
    31b0:	00112623          	sw	ra,12(sp)

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
    31b4:	079000ef          	jal	ra,3a2c <sys_clock_cycle_get_32>
    31b8:	00050413          	mv	s0,a0
		/* coverity[OVERRUN] */
		return (atomic_val_t) arch_syscall_invoke2(*(uintptr_t *)&target, *(uintptr_t *)&value, K_SYSCALL_ATOMIC_ADD);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_add(target, value);
    31bc:	3b9ad5b7          	lui	a1,0x3b9ad
    31c0:	00005537          	lui	a0,0x5
    31c4:	a0358593          	addi	a1,a1,-1533 # 3b9aca03 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x389fd983>
    31c8:	14850513          	addi	a0,a0,328 # 5148 <_rand32_counter>
    31cc:	071010ef          	jal	ra,4a3c <z_impl_atomic_add>
	return k_cycle_get_32() + atomic_add(&_rand32_counter, _RAND32_INC);
}
    31d0:	00c12083          	lw	ra,12(sp)
    31d4:	00850533          	add	a0,a0,s0
    31d8:	00812403          	lw	s0,8(sp)
    31dc:	01010113          	addi	sp,sp,16
    31e0:	00008067          	ret

000031e4 <swerv_pic_init>:
	return *(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg);
}

static void swerv_pic_write(uint32_t reg, uint32_t val)
{
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    31e4:	f00c37b7          	lui	a5,0xf00c3
    31e8:	0007a023          	sw	zero,0(a5) # f00c3000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c3001>
    31ec:	f00c27b7          	lui	a5,0xf00c2
    31f0:	00478713          	addi	a4,a5,4 # f00c2004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c2005>

	/* Init priority order to 0, 0=lowest to 15=highest */
	swerv_pic_write(SWERV_PIC_mpiccfg, 0);

	/* Ensure that all interrupts are disabled initially */
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    31f4:	12c78793          	addi	a5,a5,300
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    31f8:	00072023          	sw	zero,0(a4)
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    31fc:	00470713          	addi	a4,a4,4
    3200:	fef71ce3          	bne	a4,a5,31f8 <swerv_pic_init+0x14>
    3204:	f00c07b7          	lui	a5,0xf00c0
    3208:	00478713          	addi	a4,a5,4 # f00c0004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c0005>
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    320c:	00f00693          	li	a3,15
		swerv_pic_write(SWERV_PIC_meie(i), 0);
	}

	/* Set priority of each interrupt line to 0 initially */
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    3210:	12c78793          	addi	a5,a5,300
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    3214:	00d72023          	sw	a3,0(a4)
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    3218:	00470713          	addi	a4,a4,4
    321c:	fef71ce3          	bne	a4,a5,3214 <swerv_pic_init+0x30>
    3220:	f00c47b7          	lui	a5,0xf00c4
    3224:	00478713          	addi	a4,a5,4 # f00c4004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c4005>
		swerv_pic_write(SWERV_PIC_meipl(i), 15);
	}

	/* Set property of each interrupt line to level-triggered/high */
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    3228:	12c78793          	addi	a5,a5,300
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    322c:	00072023          	sw	zero,0(a4)
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    3230:	00470713          	addi	a4,a4,4
    3234:	fef71ce3          	bne	a4,a5,322c <swerv_pic_init+0x48>
    3238:	f00c57b7          	lui	a5,0xf00c5
    323c:	00478713          	addi	a4,a5,4 # f00c5004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c5005>
		swerv_pic_write(SWERV_PIC_meigwctrl(i), (0<<1)|(0<<0));
	}

	/* clear pending of each interrupt line */
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    3240:	12c78793          	addi	a5,a5,300
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    3244:	00072023          	sw	zero,0(a4)
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    3248:	00470713          	addi	a4,a4,4
    324c:	fef71ce3          	bne	a4,a5,3244 <swerv_pic_init+0x60>
		swerv_pic_write(SWERV_PIC_meigwclr(i), 0);
	}

	/* No interrupts masked */
	__asm__ swerv_pic_writecsr(meipt, 0);
    3250:	bc905073          	csrwi	0xbc9,0
	__asm__ swerv_pic_writecsr(meicidpl, 0);
    3254:	bcb05073          	csrwi	0xbcb,0
	__asm__ swerv_pic_writecsr(meicurpl, 0);
    3258:	bcc05073          	csrwi	0xbcc,0

	/*
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
    325c:	000017b7          	lui	a5,0x1
    3260:	80078793          	addi	a5,a5,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
    3264:	3047a7f3          	csrrs	a5,mie,a5
}
    3268:	00000513          	li	a0,0
    326c:	00008067          	ret

00003270 <swerv_pic_irq_handler>:
{
    3270:	ff010113          	addi	sp,sp,-16
    3274:	00112623          	sw	ra,12(sp)
    3278:	00812423          	sw	s0,8(sp)
	__asm__ swerv_pic_writecsr(meicpct, 0);
    327c:	bca05073          	csrwi	0xbca,0
	__asm__ swerv_pic_readcsr(meihap, tmp);
    3280:	fc802473          	csrr	s0,0xfc8
	irq = (tmp >> 2) & 0xff;
    3284:	00245413          	srli	s0,s0,0x2
    3288:	0ff47413          	andi	s0,s0,255
	save_irq = irq;
    328c:	000057b7          	lui	a5,0x5
    3290:	1487a623          	sw	s0,332(a5) # 514c <save_irq>
	if (irq == 0U || irq >= 64) {
    3294:	fff40713          	addi	a4,s0,-1
    3298:	03e00793          	li	a5,62
    329c:	00e7f663          	bgeu	a5,a4,32a8 <swerv_pic_irq_handler+0x38>
		z_irq_spurious(NULL);
    32a0:	00000513          	li	a0,0
    32a4:	df9ff0ef          	jal	ra,309c <z_irq_spurious>
	irq += RISCV_MAX_GENERIC_IRQ;
    32a8:	00b40713          	addi	a4,s0,11
	if (ite->isr)
    32ac:	000057b7          	lui	a5,0x5
    32b0:	00371713          	slli	a4,a4,0x3
    32b4:	b1478793          	addi	a5,a5,-1260 # 4b14 <_sw_isr_table>
    32b8:	00e787b3          	add	a5,a5,a4
    32bc:	0047a703          	lw	a4,4(a5)
    32c0:	00070663          	beqz	a4,32cc <swerv_pic_irq_handler+0x5c>
		ite->isr(ite->arg);
    32c4:	0007a503          	lw	a0,0(a5)
    32c8:	000700e7          	jalr	a4
	swerv_pic_write(SWERV_PIC_meigwclr(irq), 0);
    32cc:	000017b7          	lui	a5,0x1
    32d0:	40b78793          	addi	a5,a5,1035 # 140b <__mulsf3+0x23>
    32d4:	00f40433          	add	s0,s0,a5
    32d8:	00241413          	slli	s0,s0,0x2
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    32dc:	f00c07b7          	lui	a5,0xf00c0
    32e0:	00f40433          	add	s0,s0,a5
}
    32e4:	00c12083          	lw	ra,12(sp)
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    32e8:	00042023          	sw	zero,0(s0)
}
    32ec:	00812403          	lw	s0,8(sp)
    32f0:	01010113          	addi	sp,sp,16
    32f4:	00008067          	ret

000032f8 <swerv_pic_irq_enable>:
	if ((irq >= SWERV_PIC_MAX_ID) || (irq < RISCV_MAX_GENERIC_IRQ)) {
    32f8:	ff550713          	addi	a4,a0,-11
    32fc:	03f00793          	li	a5,63
    3300:	02e7e663          	bltu	a5,a4,332c <swerv_pic_irq_enable+0x34>
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3304:	00800793          	li	a5,8
    3308:	3007b7f3          	csrrc	a5,mstatus,a5
	swerv_pic_write(SWERV_PIC_meie(irq - RISCV_MAX_GENERIC_IRQ), 1);
    330c:	7f550513          	addi	a0,a0,2037
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    3310:	f00c0737          	lui	a4,0xf00c0
	swerv_pic_write(SWERV_PIC_meie(irq - RISCV_MAX_GENERIC_IRQ), 1);
    3314:	00251513          	slli	a0,a0,0x2
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    3318:	00e50533          	add	a0,a0,a4
    331c:	00100713          	li	a4,1
    3320:	00e52023          	sw	a4,0(a0)
	key = (mstatus & MSTATUS_IEN);
    3324:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    3328:	3007a7f3          	csrrs	a5,mstatus,a5
}
    332c:	00008067          	ret

00003330 <arch_irq_enable>:
	if (irq > RISCV_MAX_GENERIC_IRQ) {
    3330:	00b00793          	li	a5,11
    3334:	00a7f463          	bgeu	a5,a0,333c <arch_irq_enable+0xc>
		swerv_pic_irq_enable(irq);
    3338:	fc1ff06f          	j	32f8 <swerv_pic_irq_enable>
			  : "=r" (mie)
			  : "r" (1 << irq));
    333c:	00100793          	li	a5,1
    3340:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
    3344:	30452573          	csrrs	a0,mie,a0
}
    3348:	00008067          	ret

0000334c <uart_console_init>:
{

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    334c:	00005537          	lui	a0,0x5
{
    3350:	ff010113          	addi	sp,sp,-16
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    3354:	acc50713          	addi	a4,a0,-1332 # 4acc <__device_dts_ord_11>
    3358:	000057b7          	lui	a5,0x5
{
    335c:	00112623          	sw	ra,12(sp)
    3360:	00812423          	sw	s0,8(sp)
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    3364:	14e7a823          	sw	a4,336(a5) # 5150 <uart_console_dev>
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    3368:	acc50513          	addi	a0,a0,-1332
    336c:	784000ef          	jal	ra,3af0 <z_device_ready>
    3370:	fed00793          	li	a5,-19
    3374:	00050e63          	beqz	a0,3390 <uart_console_init+0x44>
	__stdout_hook_install(console_out);
    3378:	00003437          	lui	s0,0x3
    337c:	3a440513          	addi	a0,s0,932 # 33a4 <console_out>
    3380:	e1dff0ef          	jal	ra,319c <__stdout_hook_install>
	__printk_hook_install(console_out);
    3384:	3a440513          	addi	a0,s0,932
    3388:	ef5fe0ef          	jal	ra,227c <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
    338c:	00000793          	li	a5,0
}
    3390:	00c12083          	lw	ra,12(sp)
    3394:	00812403          	lw	s0,8(sp)
    3398:	00078513          	mv	a0,a5
    339c:	01010113          	addi	sp,sp,16
    33a0:	00008067          	ret

000033a4 <console_out>:
{
    33a4:	ff010113          	addi	sp,sp,-16
    33a8:	00812423          	sw	s0,8(sp)
    33ac:	00912223          	sw	s1,4(sp)
    33b0:	00112623          	sw	ra,12(sp)
    33b4:	000054b7          	lui	s1,0x5
	if ('\n' == c) {
    33b8:	00a00793          	li	a5,10
{
    33bc:	00050413          	mv	s0,a0
    33c0:	15048493          	addi	s1,s1,336 # 5150 <uart_console_dev>
	if ('\n' == c) {
    33c4:	00f51c63          	bne	a0,a5,33dc <console_out+0x38>
		uart_poll_out(uart_console_dev, '\r');
    33c8:	0004a503          	lw	a0,0(s1)
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    33cc:	00852783          	lw	a5,8(a0)
    33d0:	00d00593          	li	a1,13
    33d4:	0047a783          	lw	a5,4(a5)
    33d8:	000780e7          	jalr	a5
	uart_poll_out(uart_console_dev, c);
    33dc:	0004a503          	lw	a0,0(s1)
    33e0:	00852783          	lw	a5,8(a0)
    33e4:	0ff47593          	andi	a1,s0,255
    33e8:	0047a783          	lw	a5,4(a5)
    33ec:	000780e7          	jalr	a5
}
    33f0:	00c12083          	lw	ra,12(sp)
    33f4:	00040513          	mv	a0,s0
    33f8:	00812403          	lw	s0,8(sp)
    33fc:	00412483          	lw	s1,4(sp)
    3400:	01010113          	addi	sp,sp,16
    3404:	00008067          	ret

00003408 <gpio_mmio32_config>:

static int gpio_mmio32_config(const struct device *dev,
			      gpio_pin_t pin, gpio_flags_t flags)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    3408:	01052783          	lw	a5,16(a0)
    340c:	0047a683          	lw	a3,4(a5)

	if ((config->mask & (1 << pin)) == 0) {
    3410:	00100793          	li	a5,1
    3414:	00b795b3          	sll	a1,a5,a1
    3418:	0086a783          	lw	a5,8(a3)
    341c:	00f5f7b3          	and	a5,a1,a5
    3420:	06078c63          	beqz	a5,3498 <gpio_mmio32_config+0x90>
		return -EINVAL; /* Pin not in our validity mask */
	}

	if (flags & ~(GPIO_INPUT | GPIO_OUTPUT |
    3424:	fffff7b7          	lui	a5,0xfffff
    3428:	0fe78793          	addi	a5,a5,254 # fffff0fe <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffff0ff>
    342c:	00f677b3          	and	a5,a2,a5
		      GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH |
		      GPIO_ACTIVE_LOW)) {
		/* We ignore direction and fake polarity, rest is unsupported */
		return -ENOTSUP;
    3430:	f7a00513          	li	a0,-134
	if (flags & ~(GPIO_INPUT | GPIO_OUTPUT |
    3434:	06079463          	bnez	a5,349c <gpio_mmio32_config+0x94>
	}

	if ((flags & GPIO_OUTPUT) != 0) {
    3438:	20067793          	andi	a5,a2,512
			*reg = (*reg & (config->mask & ~(1 << pin)));
		}
		irq_unlock(key);
	}

	return 0;
    343c:	00000513          	li	a0,0
	if ((flags & GPIO_OUTPUT) != 0) {
    3440:	04078e63          	beqz	a5,349c <gpio_mmio32_config+0x94>
		volatile uint32_t *reg = config->reg;
    3444:	0046a703          	lw	a4,4(a3)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3448:	00800793          	li	a5,8
    344c:	3007b7f3          	csrrc	a5,mstatus,a5
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    3450:	00b65513          	srli	a0,a2,0xb
    3454:	00157513          	andi	a0,a0,1
	key = (mstatus & MSTATUS_IEN);
    3458:	0087f793          	andi	a5,a5,8
    345c:	00050e63          	beqz	a0,3478 <gpio_mmio32_config+0x70>
			*reg = (*reg | (1 << pin));
    3460:	00072683          	lw	a3,0(a4) # f00c0000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c0001>
    3464:	00d5e5b3          	or	a1,a1,a3
			*reg = (*reg & (config->mask & ~(1 << pin)));
    3468:	00b72023          	sw	a1,0(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    346c:	3007a7f3          	csrrs	a5,mstatus,a5
	return 0;
    3470:	00000513          	li	a0,0
}
    3474:	00008067          	ret
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    3478:	40067613          	andi	a2,a2,1024
    347c:	fe0608e3          	beqz	a2,346c <gpio_mmio32_config+0x64>
			*reg = (*reg & (config->mask & ~(1 << pin)));
    3480:	0086a683          	lw	a3,8(a3)
    3484:	00072603          	lw	a2,0(a4)
    3488:	fff5c593          	not	a1,a1
    348c:	00d5f5b3          	and	a1,a1,a3
    3490:	00c5f5b3          	and	a1,a1,a2
    3494:	fd5ff06f          	j	3468 <gpio_mmio32_config+0x60>
		return -EINVAL; /* Pin not in our validity mask */
    3498:	fea00513          	li	a0,-22
}
    349c:	00008067          	ret

000034a0 <gpio_mmio32_port_get_raw>:

static int gpio_mmio32_port_get_raw(const struct device *dev, uint32_t *value)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    34a0:	01052783          	lw	a5,16(a0)

	*value = *config->reg & config->mask;

	return 0;
}
    34a4:	00000513          	li	a0,0
	const struct gpio_mmio32_config *config = context->config;
    34a8:	0047a703          	lw	a4,4(a5)
	*value = *config->reg & config->mask;
    34ac:	00472783          	lw	a5,4(a4)
    34b0:	0007a683          	lw	a3,0(a5)
    34b4:	00872783          	lw	a5,8(a4)
    34b8:	00d7f7b3          	and	a5,a5,a3
    34bc:	00f5a023          	sw	a5,0(a1)
}
    34c0:	00008067          	ret

000034c4 <gpio_mmio32_port_set_masked_raw>:
static int gpio_mmio32_port_set_masked_raw(const struct device *dev,
					   uint32_t mask,
					   uint32_t value)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    34c4:	01052783          	lw	a5,16(a0)
    34c8:	0047a783          	lw	a5,4(a5)
	volatile uint32_t *reg = config->reg;
    34cc:	0047a703          	lw	a4,4(a5)
	unsigned int key;

	mask &= config->mask;
    34d0:	0087a783          	lw	a5,8(a5)
    34d4:	00f5f5b3          	and	a1,a1,a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
    34d8:	00800793          	li	a5,8
    34dc:	3007b7f3          	csrrc	a5,mstatus,a5
	value &= mask;

	/* Update pin state atomically */
	key = irq_lock();
	*reg = (*reg & ~mask) | value;
    34e0:	00072683          	lw	a3,0(a4)
	key = (mstatus & MSTATUS_IEN);
    34e4:	0087f793          	andi	a5,a5,8
    34e8:	00c6c633          	xor	a2,a3,a2
    34ec:	00b67633          	and	a2,a2,a1
    34f0:	00d64633          	xor	a2,a2,a3
    34f4:	00c72023          	sw	a2,0(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    34f8:	3007a7f3          	csrrs	a5,mstatus,a5
	irq_unlock(key);

	return 0;
}
    34fc:	00000513          	li	a0,0
    3500:	00008067          	ret

00003504 <gpio_mmio32_port_set_bits_raw>:

static int gpio_mmio32_port_set_bits_raw(const struct device *dev,
					 uint32_t mask)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    3504:	01052783          	lw	a5,16(a0)
    3508:	0047a783          	lw	a5,4(a5)
	volatile uint32_t *reg = config->reg;
	unsigned int key;

	mask &= config->mask;
    350c:	0087a703          	lw	a4,8(a5)
	volatile uint32_t *reg = config->reg;
    3510:	0047a683          	lw	a3,4(a5)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3514:	00800793          	li	a5,8
	mask &= config->mask;
    3518:	00e5f733          	and	a4,a1,a4
    351c:	3007b7f3          	csrrc	a5,mstatus,a5

	/* Update pin state atomically */
	key = irq_lock();
	*reg = (*reg | mask);
    3520:	0006a583          	lw	a1,0(a3)
	key = (mstatus & MSTATUS_IEN);
    3524:	0087f793          	andi	a5,a5,8
    3528:	00e5e5b3          	or	a1,a1,a4
    352c:	00b6a023          	sw	a1,0(a3)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    3530:	3007a7f3          	csrrs	a5,mstatus,a5
	irq_unlock(key);

	return 0;
}
    3534:	00000513          	li	a0,0
    3538:	00008067          	ret

0000353c <gpio_mmio32_port_clear_bits_raw>:

static int gpio_mmio32_port_clear_bits_raw(const struct device *dev,
					   uint32_t mask)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    353c:	01052783          	lw	a5,16(a0)
    3540:	0047a783          	lw	a5,4(a5)
	volatile uint32_t *reg = config->reg;
    3544:	0047a703          	lw	a4,4(a5)
	unsigned int key;

	mask &= config->mask;
    3548:	0087a783          	lw	a5,8(a5)
    354c:	00f5f5b3          	and	a1,a1,a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3550:	00800793          	li	a5,8
    3554:	3007b7f3          	csrrc	a5,mstatus,a5

	/* Update pin state atomically */
	key = irq_lock();
	*reg = (*reg & ~mask);
    3558:	00072683          	lw	a3,0(a4)
    355c:	fff5c593          	not	a1,a1
	key = (mstatus & MSTATUS_IEN);
    3560:	0087f793          	andi	a5,a5,8
    3564:	00d5f5b3          	and	a1,a1,a3
    3568:	00b72023          	sw	a1,0(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    356c:	3007a7f3          	csrrs	a5,mstatus,a5
	irq_unlock(key);

	return 0;
}
    3570:	00000513          	li	a0,0
    3574:	00008067          	ret

00003578 <gpio_mmio32_port_toggle_bits>:

static int gpio_mmio32_port_toggle_bits(const struct device *dev,
					uint32_t mask)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    3578:	01052783          	lw	a5,16(a0)
    357c:	0047a783          	lw	a5,4(a5)
	volatile uint32_t *reg = config->reg;
	unsigned int key;

	mask &= config->mask;
    3580:	0087a703          	lw	a4,8(a5)
	volatile uint32_t *reg = config->reg;
    3584:	0047a683          	lw	a3,4(a5)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3588:	00800793          	li	a5,8
	mask &= config->mask;
    358c:	00e5f733          	and	a4,a1,a4
    3590:	3007b7f3          	csrrc	a5,mstatus,a5

	/* Update pin state atomically */
	key = irq_lock();
	*reg = (*reg ^ mask);
    3594:	0006a583          	lw	a1,0(a3)
	key = (mstatus & MSTATUS_IEN);
    3598:	0087f793          	andi	a5,a5,8
    359c:	00e5c5b3          	xor	a1,a1,a4
    35a0:	00b6a023          	sw	a1,0(a3)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    35a4:	3007a7f3          	csrrs	a5,mstatus,a5
	irq_unlock(key);

	return 0;
}
    35a8:	00000513          	li	a0,0
    35ac:	00008067          	ret

000035b0 <gpio_mmio32_pin_interrupt_configure>:
static int gpio_mmio32_pin_interrupt_configure(const struct device *dev,
					       gpio_pin_t pin,
					       enum gpio_int_mode mode,
					       enum gpio_int_trig trig)
{
	if (mode != GPIO_INT_MODE_DISABLED) {
    35b0:	000027b7          	lui	a5,0x2
		return -ENOTSUP;
	}

	return 0;
    35b4:	00000513          	li	a0,0
	if (mode != GPIO_INT_MODE_DISABLED) {
    35b8:	00f60463          	beq	a2,a5,35c0 <gpio_mmio32_pin_interrupt_configure+0x10>
		return -ENOTSUP;
    35bc:	f7a00513          	li	a0,-134
}
    35c0:	00008067          	ret

000035c4 <gpio_mmio32_init>:
int gpio_mmio32_init(const struct device *dev)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = dev->config;

	context->config = config;
    35c4:	01052783          	lw	a5,16(a0)
    35c8:	00452703          	lw	a4,4(a0)

	return 0;
}
    35cc:	00000513          	li	a0,0
	context->config = config;
    35d0:	00e7a223          	sw	a4,4(a5) # 2004 <CONFIG_SRAM_SIZE+0x4>
}
    35d4:	00008067          	ret

000035d8 <gpio_veerwolf_init>:
/* Driver functions */

static int gpio_veerwolf_init(const struct device *dev)
{
	return 0;
}
    35d8:	00000513          	li	a0,0
    35dc:	00008067          	ret

000035e0 <gpio_veerwolf_configure>:

static int gpio_veerwolf_configure(const struct device *dev,
				gpio_pin_t pin, gpio_flags_t flags)
{
	return 0;
}
    35e0:	00000513          	li	a0,0
    35e4:	00008067          	ret

000035e8 <gpio_veerwolf_port_get_raw>:

static int gpio_veerwolf_port_get_raw(const struct device *dev,
				   gpio_port_value_t *value)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    35e8:	00452783          	lw	a5,4(a0)

	*value = sys_read32(addr);
	return 0;
}
    35ec:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    35f0:	0007a783          	lw	a5,0(a5)
	return *(volatile uint32_t *)addr;
    35f4:	0007a783          	lw	a5,0(a5)
	*value = sys_read32(addr);
    35f8:	00f5a023          	sw	a5,0(a1)
}
    35fc:	00008067          	ret

00003600 <gpio_veerwolf_port_set_masked_raw>:

static int gpio_veerwolf_port_set_masked_raw(const struct device *dev,
					  gpio_port_pins_t mask,
					  gpio_port_value_t value)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    3600:	00452783          	lw	a5,4(a0)
	port_val = sys_read32(addr);
	port_val = (port_val & ~mask) | (value & mask);
	sys_write32(port_val, addr);

	return 0;
}
    3604:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    3608:	0007a783          	lw	a5,0(a5)
    360c:	0007a703          	lw	a4,0(a5)
	port_val = (port_val & ~mask) | (value & mask);
    3610:	00e64633          	xor	a2,a2,a4
    3614:	00b67633          	and	a2,a2,a1
    3618:	00e64633          	xor	a2,a2,a4
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	*(volatile uint32_t *)addr = data;
    361c:	00c7a023          	sw	a2,0(a5)
}
    3620:	00008067          	ret

00003624 <gpio_veerwolf_port_set_bits_raw>:

static int gpio_veerwolf_port_set_bits_raw(const struct device *dev,
					gpio_port_pins_t pins)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    3624:	00452783          	lw	a5,4(a0)

	port_val = sys_read32(addr) | pins;
	sys_write32(port_val, addr);

	return 0;
}
    3628:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    362c:	0007a783          	lw	a5,0(a5)
	return *(volatile uint32_t *)addr;
    3630:	0007a703          	lw	a4,0(a5)
	port_val = sys_read32(addr) | pins;
    3634:	00e5e5b3          	or	a1,a1,a4
	*(volatile uint32_t *)addr = data;
    3638:	00b7a023          	sw	a1,0(a5)
}
    363c:	00008067          	ret

00003640 <gpio_veerwolf_port_clear_bits_raw>:

static int gpio_veerwolf_port_clear_bits_raw(const struct device *dev,
					  gpio_port_pins_t pins)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    3640:	00452783          	lw	a5,4(a0)
	uint32_t port_val;

	port_val = sys_read32(addr) & ~pins;
    3644:	fff5c593          	not	a1,a1
	sys_write32(port_val, addr);

	return 0;
}
    3648:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    364c:	0007a783          	lw	a5,0(a5)
	return *(volatile uint32_t *)addr;
    3650:	0007a703          	lw	a4,0(a5)
	port_val = sys_read32(addr) & ~pins;
    3654:	00e5f5b3          	and	a1,a1,a4
	*(volatile uint32_t *)addr = data;
    3658:	00b7a023          	sw	a1,0(a5)
}
    365c:	00008067          	ret

00003660 <gpio_veerwolf_port_toggle_bits>:

static int gpio_veerwolf_port_toggle_bits(const struct device *dev,
				       gpio_port_pins_t pins)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    3660:	00452783          	lw	a5,4(a0)

	port_val = sys_read32(addr) ^ pins;
	sys_write32(port_val, addr);

	return 0;
}
    3664:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    3668:	0007a783          	lw	a5,0(a5)
	return *(volatile uint32_t *)addr;
    366c:	0007a703          	lw	a4,0(a5)
	port_val = sys_read32(addr) ^ pins;
    3670:	00e5c5b3          	xor	a1,a1,a4
	*(volatile uint32_t *)addr = data;
    3674:	00b7a023          	sw	a1,0(a5)
}
    3678:	00008067          	ret

0000367c <gpio_veerwolf_pin_interrupt_configure>:
					      enum gpio_int_mode mode,
					      enum gpio_int_trig trig)
{
	int ret = 0;

	if (mode != GPIO_INT_MODE_DISABLED) {
    367c:	000027b7          	lui	a5,0x2
	int ret = 0;
    3680:	00000513          	li	a0,0
	if (mode != GPIO_INT_MODE_DISABLED) {
    3684:	00f60463          	beq	a2,a5,368c <gpio_veerwolf_pin_interrupt_configure+0x10>
		ret = -ENOTSUP;
    3688:	f7a00513          	li	a0,-134
	}
	return ret;
}
    368c:	00008067          	ret

00003690 <uart_ns16550_configure>:
}

static int uart_ns16550_configure(const struct device *dev,
				  const struct uart_config *cfg)
{
	struct uart_ns16550_dev_data * const dev_data = DEV_DATA(dev);
    3690:	01052883          	lw	a7,16(a0)
{
    3694:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3698:	00800693          	li	a3,8
    369c:	3006b6f3          	csrrc	a3,mstatus,a3
		OUTWORD(PCP(dev), pcp & ~PCP_UPDATE);
		OUTWORD(PCP(dev), pcp | PCP_UPDATE);
	}
#endif

	set_baud_rate(dev, cfg->baudrate);
    36a0:	0005a503          	lw	a0,0(a1)
	key = (mstatus & MSTATUS_IEN);
    36a4:	0086f693          	andi	a3,a3,8
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
    36a8:	06050863          	beqz	a0,3718 <uart_ns16550_configure+0x88>
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
    36ac:	0047a603          	lw	a2,4(a5) # 2004 <CONFIG_SRAM_SIZE+0x4>
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
    36b0:	00462803          	lw	a6,4(a2)
    36b4:	06080263          	beqz	a6,3718 <uart_ns16550_configure+0x88>
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
    36b8:	00351713          	slli	a4,a0,0x3
    36bc:	01070733          	add	a4,a4,a6
					/ baud_rate) >> 4;
    36c0:	02a75733          	divu	a4,a4,a0
		lcr_cache = INBYTE(LCR(dev));
    36c4:	00062803          	lw	a6,0(a2)
	struct uart_ns16550_dev_data * const dev_data = DEV_DATA(dev);
    36c8:	0107a303          	lw	t1,16(a5)
	return *(volatile uint8_t *)addr;
    36cc:	00c84603          	lbu	a2,12(a6)
    36d0:	0ff67e13          	andi	t3,a2,255
		OUTBYTE(LCR(dev), LCR_DLAB | lcr_cache);
    36d4:	f8066613          	ori	a2,a2,-128
    36d8:	0ff67613          	andi	a2,a2,255
	*(volatile uint8_t *)addr = data;
    36dc:	00c80623          	sb	a2,12(a6)
	return DEVICE_MMIO_GET(dev);
    36e0:	0047a803          	lw	a6,4(a5)
    36e4:	00082803          	lw	a6,0(a6)
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
    36e8:	00475613          	srli	a2,a4,0x4
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
    36ec:	0ff67613          	andi	a2,a2,255
    36f0:	00c80023          	sb	a2,0(a6)
	return DEVICE_MMIO_GET(dev);
    36f4:	0047a603          	lw	a2,4(a5)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
    36f8:	00c75713          	srli	a4,a4,0xc
    36fc:	0ff77713          	andi	a4,a4,255
    3700:	00062603          	lw	a2,0(a2)
    3704:	00e60223          	sb	a4,4(a2)
	return DEVICE_MMIO_GET(dev);
    3708:	0047a703          	lw	a4,4(a5)
		OUTBYTE(LCR(dev), lcr_cache);
    370c:	00072703          	lw	a4,0(a4)
    3710:	01c70623          	sb	t3,12(a4)
		dev_data->uart_config.baudrate = baud_rate;
    3714:	00a32023          	sw	a0,0(t1)

	/* Local structure to hold temporary values to pass to OUTBYTE() */
	struct uart_config uart_cfg;

	switch (cfg->data_bits) {
    3718:	0065c603          	lbu	a2,6(a1)
    371c:	00300713          	li	a4,3
		break;
	case UART_CFG_DATA_BITS_8:
		uart_cfg.data_bits = LCR_CS8;
		break;
	default:
		ret = -ENOTSUP;
    3720:	f7a00513          	li	a0,-134
    3724:	08c76663          	bltu	a4,a2,37b0 <uart_ns16550_configure+0x120>
		goto out;
	}

	switch (cfg->stop_bits) {
    3728:	0055c803          	lbu	a6,5(a1)
    372c:	00100513          	li	a0,1
    3730:	08a80463          	beq	a6,a0,37b8 <uart_ns16550_configure+0x128>
    3734:	f7a00513          	li	a0,-134
    3738:	06e81c63          	bne	a6,a4,37b0 <uart_ns16550_configure+0x120>
    373c:	00400813          	li	a6,4
	default:
		ret = -ENOTSUP;
		goto out;
	}

	switch (cfg->parity) {
    3740:	0045c703          	lbu	a4,4(a1)
    3744:	00070a63          	beqz	a4,3758 <uart_ns16550_configure+0xc8>
    3748:	00200313          	li	t1,2
    374c:	f7a00513          	li	a0,-134
    3750:	06671063          	bne	a4,t1,37b0 <uart_ns16550_configure+0x120>
    3754:	01000713          	li	a4,16
	default:
		ret = -ENOTSUP;
		goto out;
	}

	dev_data->uart_config = *cfg;
    3758:	0005a503          	lw	a0,0(a1)

	/* data bits, stop bits, parity, clear DLAB */
	OUTBYTE(LCR(dev),
    375c:	01066633          	or	a2,a2,a6
    3760:	00c76733          	or	a4,a4,a2
	return DEVICE_MMIO_GET(dev);
    3764:	0047a603          	lw	a2,4(a5)
	dev_data->uart_config = *cfg;
    3768:	00a8a023          	sw	a0,0(a7)
    376c:	0045a583          	lw	a1,4(a1)
	OUTBYTE(LCR(dev),
    3770:	00062603          	lw	a2,0(a2)
	int ret = 0;
    3774:	00000513          	li	a0,0
	dev_data->uart_config = *cfg;
    3778:	00b8a223          	sw	a1,4(a7)
    377c:	00e60623          	sb	a4,12(a2)
	return DEVICE_MMIO_GET(dev);
    3780:	0047a703          	lw	a4,4(a5)
    3784:	00b00613          	li	a2,11
	if (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS) {
		mdc |= MCR_AFCE;
	}
#endif

	OUTBYTE(MDC(dev), mdc);
    3788:	00072703          	lw	a4,0(a4)
    378c:	00c70823          	sb	a2,16(a4)
	return DEVICE_MMIO_GET(dev);
    3790:	0047a703          	lw	a4,4(a5)
    3794:	f8700613          	li	a2,-121
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
    3798:	00072703          	lw	a4,0(a4)
    379c:	00c70423          	sb	a2,8(a4)
	return DEVICE_MMIO_GET(dev);
    37a0:	0047a783          	lw	a5,4(a5)
    37a4:	0007a783          	lw	a5,0(a5)
	return *(volatile uint8_t *)addr;
    37a8:	0007c703          	lbu	a4,0(a5)
	*(volatile uint8_t *)addr = data;
    37ac:	00078223          	sb	zero,4(a5)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    37b0:	3006a6f3          	csrrs	a3,mstatus,a3
	OUTBYTE(IER(dev), 0x00);

out:
	k_spin_unlock(&dev_data->lock, key);
	return ret;
};
    37b4:	00008067          	ret
		uart_cfg.stop_bits = LCR_1_STB;
    37b8:	00000813          	li	a6,0
    37bc:	f85ff06f          	j	3740 <uart_ns16550_configure+0xb0>

000037c0 <uart_ns16550_config_get>:

#ifdef CONFIG_UART_USE_RUNTIME_CONFIGURE
static int uart_ns16550_config_get(const struct device *dev,
				   struct uart_config *cfg)
{
	struct uart_ns16550_dev_data *data = DEV_DATA(dev);
    37c0:	01052783          	lw	a5,16(a0)
	cfg->stop_bits = data->uart_config.stop_bits;
	cfg->data_bits = data->uart_config.data_bits;
	cfg->flow_ctrl = data->uart_config.flow_ctrl;

	return 0;
}
    37c4:	00000513          	li	a0,0
	cfg->baudrate = data->uart_config.baudrate;
    37c8:	0007a703          	lw	a4,0(a5)
    37cc:	00e5a023          	sw	a4,0(a1)
	cfg->parity = data->uart_config.parity;
    37d0:	0047c703          	lbu	a4,4(a5)
    37d4:	00e58223          	sb	a4,4(a1)
	cfg->stop_bits = data->uart_config.stop_bits;
    37d8:	0057c703          	lbu	a4,5(a5)
    37dc:	00e582a3          	sb	a4,5(a1)
	cfg->data_bits = data->uart_config.data_bits;
    37e0:	0067c703          	lbu	a4,6(a5)
    37e4:	00e58323          	sb	a4,6(a1)
	cfg->flow_ctrl = data->uart_config.flow_ctrl;
    37e8:	0077c783          	lbu	a5,7(a5)
    37ec:	00f583a3          	sb	a5,7(a1)
}
    37f0:	00008067          	ret

000037f4 <uart_ns16550_init>:
 */
static int uart_ns16550_init(const struct device *dev)
{
	int ret;

	ret = uart_ns16550_configure(dev, &DEV_DATA(dev)->uart_config);
    37f4:	01052583          	lw	a1,16(a0)
    37f8:	e99ff06f          	j	3690 <uart_ns16550_configure>

000037fc <uart_ns16550_poll_in>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    37fc:	00800793          	li	a5,8
    3800:	3007b7f3          	csrrc	a5,mstatus,a5
	return DEVICE_MMIO_GET(dev);
    3804:	00452703          	lw	a4,4(a0)
	key = (mstatus & MSTATUS_IEN);
    3808:	0087f793          	andi	a5,a5,8
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(const struct device *dev, unsigned char *c)
{
	int ret = -1;
    380c:	fff00513          	li	a0,-1
	return DEVICE_MMIO_GET(dev);
    3810:	00072683          	lw	a3,0(a4)
	return *(volatile uint8_t *)addr;
    3814:	0146c703          	lbu	a4,20(a3)
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	if ((INBYTE(LSR(dev)) & LSR_RXRDY) != 0) {
    3818:	00177713          	andi	a4,a4,1
    381c:	00070863          	beqz	a4,382c <uart_ns16550_poll_in+0x30>
    3820:	0006c703          	lbu	a4,0(a3)
		/* got a character */
		*c = INBYTE(RDR(dev));
		ret = 0;
    3824:	00000513          	li	a0,0
		*c = INBYTE(RDR(dev));
    3828:	00e58023          	sb	a4,0(a1)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    382c:	3007a7f3          	csrrs	a5,mstatus,a5
	}

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return ret;
}
    3830:	00008067          	ret

00003834 <uart_ns16550_poll_out>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3834:	00800793          	li	a5,8
    3838:	3007b7f3          	csrrc	a5,mstatus,a5
	return DEVICE_MMIO_GET(dev);
    383c:	00452703          	lw	a4,4(a0)
	key = (mstatus & MSTATUS_IEN);
    3840:	0087f793          	andi	a5,a5,8
    3844:	00072683          	lw	a3,0(a4)
static void uart_ns16550_poll_out(const struct device *dev,
					   unsigned char c)
{
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0) {
    3848:	01468613          	addi	a2,a3,20
    384c:	00064703          	lbu	a4,0(a2)
    3850:	02077713          	andi	a4,a4,32
    3854:	fe070ce3          	beqz	a4,384c <uart_ns16550_poll_out+0x18>
	*(volatile uint8_t *)addr = data;
    3858:	00b68023          	sb	a1,0(a3)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    385c:	3007a7f3          	csrrs	a5,mstatus,a5
	}

	OUTBYTE(THR(dev), c);

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
}
    3860:	00008067          	ret

00003864 <uart_ns16550_err_check>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3864:	00800793          	li	a5,8
    3868:	3007b7f3          	csrrc	a5,mstatus,a5
	return DEVICE_MMIO_GET(dev);
    386c:	00452703          	lw	a4,4(a0)
	key = (mstatus & MSTATUS_IEN);
    3870:	0087f793          	andi	a5,a5,8
 * UART_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(const struct device *dev)
{
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);
	int check = (INBYTE(LSR(dev)) & LSR_EOB_MASK);
    3874:	00072703          	lw	a4,0(a4)
	return *(volatile uint8_t *)addr;
    3878:	01474503          	lbu	a0,20(a4)
    387c:	0ff57513          	andi	a0,a0,255
	__asm__ volatile ("csrrs %0, mstatus, %1"
    3880:	3007a7f3          	csrrs	a5,mstatus,a5
    3884:	01e57513          	andi	a0,a0,30

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return check >> 1;
}
    3888:	00155513          	srli	a0,a0,0x1
    388c:	00008067          	ret

00003890 <mtime>:
	volatile uint32_t *r = (uint32_t *)RISCV_MTIME_BASE;
	uint32_t lo, hi;

	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
    3890:	800017b7          	lui	a5,0x80001
    3894:	0247a703          	lw	a4,36(a5) # 80001024 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001025>
		lo = r[0];
    3898:	0207a503          	lw	a0,32(a5)
	} while (r[1] != hi);
    389c:	0247a583          	lw	a1,36(a5)
    38a0:	fee59ae3          	bne	a1,a4,3894 <mtime+0x4>

	return (((uint64_t)hi) << 32) | lo;
#endif
}
    38a4:	00008067          	ret

000038a8 <timer_isr>:

static void timer_isr(const void *arg)
{
    38a8:	fe010113          	addi	sp,sp,-32
    38ac:	01312623          	sw	s3,12(sp)
    38b0:	00112e23          	sw	ra,28(sp)
    38b4:	00812c23          	sw	s0,24(sp)
    38b8:	00912a23          	sw	s1,20(sp)
    38bc:	01212823          	sw	s2,16(sp)
    38c0:	01412423          	sw	s4,8(sp)
    38c4:	01512223          	sw	s5,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    38c8:	00800993          	li	s3,8
    38cc:	3009b9f3          	csrrc	s3,mstatus,s3
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = mtime();
    38d0:	fc1ff0ef          	jal	ra,3890 <mtime>
	key = (mstatus & MSTATUS_IEN);
    38d4:	0089f993          	andi	s3,s3,8
    38d8:	00050a13          	mv	s4,a0
    38dc:	00058913          	mv	s2,a1
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);

	last_count = now;
    38e0:	00005437          	lui	s0,0x5
    38e4:	13040413          	addi	s0,s0,304 # 5130 <last_count>
    38e8:	00a42023          	sw	a0,0(s0)
    38ec:	00b42223          	sw	a1,4(s0)

static inline int z_impl_sys_clock_hw_cycles_per_sec_runtime_get(void)
{
	extern int z_clock_hw_cycles_per_sec;

	return z_clock_hw_cycles_per_sec;
    38f0:	00006ab7          	lui	s5,0x6

	if (!TICKLESS) {
		uint64_t next = last_count + CYC_PER_TICK;
    38f4:	0a8aa503          	lw	a0,168(s5) # 60a8 <z_clock_hw_cycles_per_sec>
    38f8:	00000693          	li	a3,0
    38fc:	06400613          	li	a2,100
    3900:	41f55593          	srai	a1,a0,0x1f
    3904:	a39fc0ef          	jal	ra,33c <__udivdi3>
    3908:	00042483          	lw	s1,0(s0)
    390c:	00442783          	lw	a5,4(s0)
    3910:	009504b3          	add	s1,a0,s1
    3914:	00a4b433          	sltu	s0,s1,a0
    3918:	00f40433          	add	s0,s0,a5

		if ((int64_t)(next - now) < MIN_DELAY) {
    391c:	41448a33          	sub	s4,s1,s4
    3920:	0144b5b3          	sltu	a1,s1,s4
    3924:	41240933          	sub	s2,s0,s2
    3928:	40b90933          	sub	s2,s2,a1
		uint64_t next = last_count + CYC_PER_TICK;
    392c:	00048793          	mv	a5,s1
    3930:	00040693          	mv	a3,s0
		if ((int64_t)(next - now) < MIN_DELAY) {
    3934:	03204863          	bgtz	s2,3964 <timer_isr+0xbc>
    3938:	00091663          	bnez	s2,3944 <timer_isr+0x9c>
    393c:	3e700713          	li	a4,999
    3940:	03476263          	bltu	a4,s4,3964 <timer_isr+0xbc>
			next += CYC_PER_TICK;
    3944:	0a8aa503          	lw	a0,168(s5)
    3948:	00000693          	li	a3,0
    394c:	06400613          	li	a2,100
    3950:	41f55593          	srai	a1,a0,0x1f
    3954:	9e9fc0ef          	jal	ra,33c <__udivdi3>
    3958:	00a487b3          	add	a5,s1,a0
    395c:	0097b4b3          	sltu	s1,a5,s1
    3960:	008486b3          	add	a3,s1,s0
	r[1] = 0xffffffff;
    3964:	80001737          	lui	a4,0x80001
    3968:	fff00613          	li	a2,-1
    396c:	02c72623          	sw	a2,44(a4) # 8000102c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000102d>
	r[0] = (uint32_t)time;
    3970:	02f72423          	sw	a5,40(a4)
	r[1] = (uint32_t)(time >> 32);
    3974:	02d72623          	sw	a3,44(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    3978:	3009a9f3          	csrrs	s3,mstatus,s3
		set_mtimecmp(next);
	}

	k_spin_unlock(&lock, key);
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
    397c:	01812403          	lw	s0,24(sp)
    3980:	01c12083          	lw	ra,28(sp)
    3984:	01412483          	lw	s1,20(sp)
    3988:	01012903          	lw	s2,16(sp)
    398c:	00c12983          	lw	s3,12(sp)
    3990:	00812a03          	lw	s4,8(sp)
    3994:	00412a83          	lw	s5,4(sp)
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    3998:	00100513          	li	a0,1
}
    399c:	02010113          	addi	sp,sp,32
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    39a0:	7610006f          	j	4900 <sys_clock_announce>

000039a4 <sys_clock_driver_init>:

int sys_clock_driver_init(const struct device *dev)
{
    39a4:	ff010113          	addi	sp,sp,-16
    39a8:	00812423          	sw	s0,8(sp)
	ARG_UNUSED(dev);

	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
	last_count = mtime();
    39ac:	00005437          	lui	s0,0x5
{
    39b0:	00112623          	sw	ra,12(sp)
	last_count = mtime();
    39b4:	13040413          	addi	s0,s0,304 # 5130 <last_count>
    39b8:	ed9ff0ef          	jal	ra,3890 <mtime>
    39bc:	00a42023          	sw	a0,0(s0)
    39c0:	00b42223          	sw	a1,4(s0)
    39c4:	000067b7          	lui	a5,0x6
	set_mtimecmp(last_count + CYC_PER_TICK);
    39c8:	0a87a503          	lw	a0,168(a5) # 60a8 <z_clock_hw_cycles_per_sec>
    39cc:	06400613          	li	a2,100
    39d0:	00000693          	li	a3,0
    39d4:	41f55593          	srai	a1,a0,0x1f
    39d8:	965fc0ef          	jal	ra,33c <__udivdi3>
    39dc:	00042783          	lw	a5,0(s0)
    39e0:	00442703          	lw	a4,4(s0)
	r[1] = 0xffffffff;
    39e4:	fff00693          	li	a3,-1
	set_mtimecmp(last_count + CYC_PER_TICK);
    39e8:	00f507b3          	add	a5,a0,a5
    39ec:	00a7b533          	sltu	a0,a5,a0
    39f0:	00e50533          	add	a0,a0,a4
	r[1] = 0xffffffff;
    39f4:	80001737          	lui	a4,0x80001
    39f8:	02d72623          	sw	a3,44(a4) # 8000102c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000102d>
	r[0] = (uint32_t)time;
    39fc:	02f72423          	sw	a5,40(a4)
	r[1] = (uint32_t)(time >> 32);
    3a00:	02a72623          	sw	a0,44(a4)
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
    3a04:	00700513          	li	a0,7
    3a08:	929ff0ef          	jal	ra,3330 <arch_irq_enable>
	return 0;
}
    3a0c:	00c12083          	lw	ra,12(sp)
    3a10:	00812403          	lw	s0,8(sp)
    3a14:	00000513          	li	a0,0
    3a18:	01010113          	addi	sp,sp,16
    3a1c:	00008067          	ret

00003a20 <sys_clock_set_timeout>:
	}

	set_mtimecmp(cyc + last_count);
	k_spin_unlock(&lock, key);
#endif
}
    3a20:	00008067          	ret

00003a24 <sys_clock_elapsed>:
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = ((uint32_t)mtime() - (uint32_t)last_count) / CYC_PER_TICK;

	k_spin_unlock(&lock, key);
	return ret;
}
    3a24:	00000513          	li	a0,0
    3a28:	00008067          	ret

00003a2c <sys_clock_cycle_get_32>:

uint32_t sys_clock_cycle_get_32(void)
{
    3a2c:	ff010113          	addi	sp,sp,-16
    3a30:	00112623          	sw	ra,12(sp)
	return (uint32_t)mtime();
    3a34:	e5dff0ef          	jal	ra,3890 <mtime>
}
    3a38:	00c12083          	lw	ra,12(sp)
    3a3c:	01010113          	addi	sp,sp,16
    3a40:	00008067          	ret

00003a44 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
    3a44:	00008067          	ret

00003a48 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    3a48:	00251713          	slli	a4,a0,0x2
    3a4c:	000057b7          	lui	a5,0x5
    3a50:	00150513          	addi	a0,a0,1
    3a54:	0e478793          	addi	a5,a5,228 # 50e4 <levels.0>
    3a58:	00251513          	slli	a0,a0,0x2
{
    3a5c:	fe010113          	addi	sp,sp,-32
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    3a60:	00e78733          	add	a4,a5,a4
    3a64:	00a78533          	add	a0,a5,a0
{
    3a68:	00812c23          	sw	s0,24(sp)
    3a6c:	01212823          	sw	s2,16(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    3a70:	00072403          	lw	s0,0(a4)
    3a74:	00052903          	lw	s2,0(a0)
{
    3a78:	01312623          	sw	s3,12(sp)
    3a7c:	00112e23          	sw	ra,28(sp)
    3a80:	00912a23          	sw	s1,20(sp)
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    3a84:	0ff00993          	li	s3,255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    3a88:	03246063          	bltu	s0,s2,3aa8 <z_sys_init_run_level+0x60>
			}
			dev->state->initialized = true;
		}
	}
}
    3a8c:	01c12083          	lw	ra,28(sp)
    3a90:	01812403          	lw	s0,24(sp)
    3a94:	01412483          	lw	s1,20(sp)
    3a98:	01012903          	lw	s2,16(sp)
    3a9c:	00c12983          	lw	s3,12(sp)
    3aa0:	02010113          	addi	sp,sp,32
    3aa4:	00008067          	ret
		const struct device *dev = entry->dev;
    3aa8:	00442483          	lw	s1,4(s0)
		int rc = entry->init(dev);
    3aac:	00042783          	lw	a5,0(s0)
    3ab0:	00048513          	mv	a0,s1
    3ab4:	000780e7          	jalr	a5
		if (dev != NULL) {
    3ab8:	02048863          	beqz	s1,3ae8 <z_sys_init_run_level+0xa0>
				dev->state->init_res = rc;
    3abc:	00c4a783          	lw	a5,12(s1)
			if (rc != 0) {
    3ac0:	00050e63          	beqz	a0,3adc <z_sys_init_run_level+0x94>
				if (rc < 0) {
    3ac4:	41f55713          	srai	a4,a0,0x1f
    3ac8:	00a74533          	xor	a0,a4,a0
    3acc:	40e50533          	sub	a0,a0,a4
				dev->state->init_res = rc;
    3ad0:	00a9d463          	bge	s3,a0,3ad8 <z_sys_init_run_level+0x90>
    3ad4:	0ff00513          	li	a0,255
    3ad8:	00a78023          	sb	a0,0(a5)
			dev->state->initialized = true;
    3adc:	0007d703          	lhu	a4,0(a5)
    3ae0:	10076713          	ori	a4,a4,256
    3ae4:	00e79023          	sh	a4,0(a5)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    3ae8:	00840413          	addi	s0,s0,8
    3aec:	f9dff06f          	j	3a88 <z_sys_init_run_level+0x40>

00003af0 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    3af0:	00050e63          	beqz	a0,3b0c <z_device_ready+0x1c>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    3af4:	00c52783          	lw	a5,12(a0)
    3af8:	0007a503          	lw	a0,0(a5)
    3afc:	1ff57513          	andi	a0,a0,511
    3b00:	f0050513          	addi	a0,a0,-256
    3b04:	00153513          	seqz	a0,a0
    3b08:	00008067          	ret
		return false;
    3b0c:	00000513          	li	a0,0
}
    3b10:	00008067          	ret

00003b14 <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3b14:	00800793          	li	a5,8
    3b18:	3007b7f3          	csrrc	a5,mstatus,a5
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    3b1c:	0000006f          	j	3b1c <arch_system_halt+0x8>

00003b20 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    3b20:	ff010113          	addi	sp,sp,-16
    3b24:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
    3b28:	fedff0ef          	jal	ra,3b14 <arch_system_halt>

00003b2c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    3b2c:	fe010113          	addi	sp,sp,-32
    3b30:	00812c23          	sw	s0,24(sp)
    3b34:	01212823          	sw	s2,16(sp)
    3b38:	00112e23          	sw	ra,28(sp)
    3b3c:	00912a23          	sw	s1,20(sp)
    3b40:	00050913          	mv	s2,a0
    3b44:	00b12623          	sw	a1,12(sp)
    3b48:	00800413          	li	s0,8
    3b4c:	30043473          	csrrc	s0,mstatus,s0
	return z_impl_z_current_get();
    3b50:	161000ef          	jal	ra,44b0 <z_impl_z_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    3b54:	00c12583          	lw	a1,12(sp)
    3b58:	00050493          	mv	s1,a0
    3b5c:	00090513          	mv	a0,s2
    3b60:	fc1ff0ef          	jal	ra,3b20 <k_sys_fatal_error_handler>
	key = (mstatus & MSTATUS_IEN);
    3b64:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    3b68:	30042473          	csrrs	s0,mstatus,s0
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    3b6c:	01812403          	lw	s0,24(sp)
    3b70:	01c12083          	lw	ra,28(sp)
    3b74:	01012903          	lw	s2,16(sp)
	z_impl_k_thread_abort(thread);
    3b78:	00048513          	mv	a0,s1
    3b7c:	01412483          	lw	s1,20(sp)
    3b80:	02010113          	addi	sp,sp,32
    3b84:	22d0006f          	j	45b0 <z_impl_k_thread_abort>

00003b88 <init_idle_thread>:
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    3b88:	01800693          	li	a3,24
    3b8c:	02d506b3          	mul	a3,a0,a3
{
    3b90:	fe010113          	addi	sp,sp,-32
    3b94:	00812c23          	sw	s0,24(sp)
	z_setup_new_thread(thread, stack,
    3b98:	00005737          	lui	a4,0x5
	struct k_thread *thread = &z_idle_threads[i];
    3b9c:	00005437          	lui	s0,0x5
	k_thread_stack_t *stack = z_idle_stacks[i];
    3ba0:	00951313          	slli	t1,a0,0x9
	struct k_thread *thread = &z_idle_threads[i];
    3ba4:	16840413          	addi	s0,s0,360 # 5168 <z_idle_threads>
    3ba8:	00751513          	slli	a0,a0,0x7
	z_setup_new_thread(thread, stack,
    3bac:	26870713          	addi	a4,a4,616 # 5268 <_kernel>
    3bb0:	000055b7          	lui	a1,0x5
	struct k_thread *thread = &z_idle_threads[i];
    3bb4:	00a40433          	add	s0,s0,a0
	z_setup_new_thread(thread, stack,
    3bb8:	00100793          	li	a5,1
    3bbc:	00d70733          	add	a4,a4,a3
    3bc0:	69058593          	addi	a1,a1,1680 # 5690 <z_idle_stacks>
    3bc4:	000046b7          	lui	a3,0x4
    3bc8:	00f12023          	sw	a5,0(sp)
    3bcc:	00012223          	sw	zero,4(sp)
    3bd0:	00000793          	li	a5,0
    3bd4:	00040513          	mv	a0,s0
    3bd8:	00f00893          	li	a7,15
    3bdc:	00000813          	li	a6,0
    3be0:	ef468693          	addi	a3,a3,-268 # 3ef4 <idle>
    3be4:	20000613          	li	a2,512
    3be8:	006585b3          	add	a1,a1,t1
{
    3bec:	00112e23          	sw	ra,28(sp)
	z_setup_new_thread(thread, stack,
    3bf0:	168000ef          	jal	ra,3d58 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    3bf4:	00d44783          	lbu	a5,13(s0)
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    3bf8:	01c12083          	lw	ra,28(sp)
    3bfc:	ffb7f793          	andi	a5,a5,-5
    3c00:	00f406a3          	sb	a5,13(s0)
    3c04:	01812403          	lw	s0,24(sp)
    3c08:	02010113          	addi	sp,sp,32
    3c0c:	00008067          	ret

00003c10 <bg_thread_main>:
{
    3c10:	ff010113          	addi	sp,sp,-16
	z_sys_post_kernel = true;
    3c14:	000057b7          	lui	a5,0x5
    3c18:	00100713          	li	a4,1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    3c1c:	00200513          	li	a0,2
{
    3c20:	00112623          	sw	ra,12(sp)
	z_sys_post_kernel = true;
    3c24:	16e78223          	sb	a4,356(a5) # 5164 <z_sys_post_kernel>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    3c28:	e21ff0ef          	jal	ra,3a48 <z_sys_init_run_level>
	boot_banner();
    3c2c:	635000ef          	jal	ra,4a60 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    3c30:	00300513          	li	a0,3
    3c34:	e15ff0ef          	jal	ra,3a48 <z_sys_init_run_level>
	z_init_static_threads();
    3c38:	1a4000ef          	jal	ra,3ddc <z_init_static_threads>
	main();
    3c3c:	ce4fe0ef          	jal	ra,2120 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    3c40:	000057b7          	lui	a5,0x5
    3c44:	1e878793          	addi	a5,a5,488 # 51e8 <z_main_thread>
    3c48:	00c7c703          	lbu	a4,12(a5)
    3c4c:	ffe77713          	andi	a4,a4,-2
    3c50:	00e78623          	sb	a4,12(a5)
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    3c54:	00c12083          	lw	ra,12(sp)
    3c58:	01010113          	addi	sp,sp,16
    3c5c:	00008067          	ret

00003c60 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    3c60:	00005537          	lui	a0,0x5
    3c64:	000057b7          	lui	a5,0x5
    3c68:	13050613          	addi	a2,a0,304 # 5130 <last_count>
    3c6c:	28c78793          	addi	a5,a5,652 # 528c <sched_spinlock>
    3c70:	40c78633          	sub	a2,a5,a2
    3c74:	00000593          	li	a1,0
    3c78:	13050513          	addi	a0,a0,304
    3c7c:	cf8ff06f          	j	3174 <memset>

00003c80 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    3c80:	f6010113          	addi	sp,sp,-160
    3c84:	08812c23          	sw	s0,152(sp)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    3c88:	10100793          	li	a5,257
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    3c8c:	00005437          	lui	s0,0x5
    3c90:	26840413          	addi	s0,s0,616 # 5268 <_kernel>
	dummy_thread->base.user_options = K_ESSENTIAL;
    3c94:	00f11e23          	sh	a5,28(sp)
	_current_cpu->current = dummy_thread;
    3c98:	01010793          	addi	a5,sp,16
    3c9c:	08112e23          	sw	ra,156(sp)
    3ca0:	00f42423          	sw	a5,8(s0)
    3ca4:	08912a23          	sw	s1,148(sp)
    3ca8:	09212823          	sw	s2,144(sp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    3cac:	d99ff0ef          	jal	ra,3a44 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    3cb0:	00000513          	li	a0,0
    3cb4:	d95ff0ef          	jal	ra,3a48 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    3cb8:	00100513          	li	a0,1
    3cbc:	d8dff0ef          	jal	ra,3a48 <z_sys_init_run_level>
	z_sched_init();
    3cc0:	7cc000ef          	jal	ra,448c <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    3cc4:	000057b7          	lui	a5,0x5
    3cc8:	0f878793          	addi	a5,a5,248 # 50f8 <levels.0+0x14>
	_kernel.ready_q.cache = &z_main_thread;
    3ccc:	000054b7          	lui	s1,0x5
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    3cd0:	00f12223          	sw	a5,4(sp)
    3cd4:	000046b7          	lui	a3,0x4
    3cd8:	00100793          	li	a5,1
    3cdc:	000055b7          	lui	a1,0x5
	_kernel.ready_q.cache = &z_main_thread;
    3ce0:	1e848913          	addi	s2,s1,488 # 51e8 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    3ce4:	00000893          	li	a7,0
    3ce8:	00000813          	li	a6,0
    3cec:	00000713          	li	a4,0
    3cf0:	c1068693          	addi	a3,a3,-1008 # 3c10 <bg_thread_main>
    3cf4:	40000613          	li	a2,1024
    3cf8:	29058593          	addi	a1,a1,656 # 5290 <z_main_stack>
    3cfc:	00f12023          	sw	a5,0(sp)
    3d00:	1e848513          	addi	a0,s1,488
    3d04:	00000793          	li	a5,0
	_kernel.ready_q.cache = &z_main_thread;
    3d08:	01242c23          	sw	s2,24(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    3d0c:	04c000ef          	jal	ra,3d58 <z_setup_new_thread>
    3d10:	00d94783          	lbu	a5,13(s2)
	z_ready_thread(&z_main_thread);
    3d14:	1e848513          	addi	a0,s1,488
    3d18:	ffb7f793          	andi	a5,a5,-5
    3d1c:	00f906a3          	sb	a5,13(s2)
    3d20:	638000ef          	jal	ra,4358 <z_ready_thread>
		init_idle_thread(i);
    3d24:	00000513          	li	a0,0
    3d28:	e61ff0ef          	jal	ra,3b88 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    3d2c:	000057b7          	lui	a5,0x5
    3d30:	16878793          	addi	a5,a5,360 # 5168 <z_idle_threads>
    3d34:	00f42623          	sw	a5,12(s0)
		_kernel.cpus[i].irq_stack =
    3d38:	000067b7          	lui	a5,0x6
    3d3c:	09078793          	addi	a5,a5,144 # 6090 <_char_out>
		_kernel.cpus[i].id = i;
    3d40:	00040a23          	sb	zero,20(s0)
		_kernel.cpus[i].irq_stack =
    3d44:	00f42223          	sw	a5,4(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3d48:	00800513          	li	a0,8
    3d4c:	30053573          	csrrc	a0,mstatus,a0
	ret = arch_swap(key);
    3d50:	00857513          	andi	a0,a0,8
    3d54:	d78fc0ef          	jal	ra,2cc <arch_swap>

00003d58 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    3d58:	ff010113          	addi	sp,sp,-16
    3d5c:	00812423          	sw	s0,8(sp)
    3d60:	00912223          	sw	s1,4(sp)
    3d64:	00112623          	sw	ra,12(sp)
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    3d68:	06850313          	addi	t1,a0,104
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    3d6c:	06652423          	sw	t1,104(a0)
	list->tail = (sys_dnode_t *)list;
    3d70:	06652623          	sw	t1,108(a0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    3d74:	01012303          	lw	t1,16(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    3d78:	00f60613          	addi	a2,a2,15
    3d7c:	ff067613          	andi	a2,a2,-16
	stack_ptr = (char *)stack + stack_obj_size;
    3d80:	00c584b3          	add	s1,a1,a2
	thread_base->user_options = (uint8_t)options;
    3d84:	00650623          	sb	t1,12(a0)
	thread_base->thread_state = (uint8_t)initial_state;
    3d88:	00400313          	li	t1,4
	thread_base->pended_on = NULL;
    3d8c:	00052423          	sw	zero,8(a0)
	thread_base->thread_state = (uint8_t)initial_state;
    3d90:	006506a3          	sb	t1,13(a0)

	thread_base->prio = priority;
    3d94:	01150723          	sb	a7,14(a0)

	thread_base->sched_locked = 0U;
    3d98:	000507a3          	sb	zero,15(a0)
 * @return N/A
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
    3d9c:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
    3da0:	00052e23          	sw	zero,28(a0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    3da4:	00048613          	mv	a2,s1
{
    3da8:	00050413          	mv	s0,a0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    3dac:	b4cff0ef          	jal	ra,30f8 <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
    3db0:	000057b7          	lui	a5,0x5
    3db4:	2707a783          	lw	a5,624(a5) # 5270 <_kernel+0x8>
}
    3db8:	00c12083          	lw	ra,12(sp)
	new_thread->init_data = NULL;
    3dbc:	06042223          	sw	zero,100(s0)
	new_thread->resource_pool = _current->resource_pool;
    3dc0:	0747a783          	lw	a5,116(a5)
}
    3dc4:	00048513          	mv	a0,s1
    3dc8:	00412483          	lw	s1,4(sp)
	new_thread->resource_pool = _current->resource_pool;
    3dcc:	06f42a23          	sw	a5,116(s0)
}
    3dd0:	00812403          	lw	s0,8(sp)
    3dd4:	01010113          	addi	sp,sp,16
    3dd8:	00008067          	ret

00003ddc <z_init_static_threads>:
{
    3ddc:	fd010113          	addi	sp,sp,-48
	_FOREACH_STATIC_THREAD(thread_data) {
    3de0:	000067b7          	lui	a5,0x6
{
    3de4:	03212023          	sw	s2,32(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
    3de8:	00006937          	lui	s2,0x6
{
    3dec:	02812423          	sw	s0,40(sp)
    3df0:	02912223          	sw	s1,36(sp)
    3df4:	02112623          	sw	ra,44(sp)
    3df8:	01312e23          	sw	s3,28(sp)
    3dfc:	01412c23          	sw	s4,24(sp)
    3e00:	01512a23          	sw	s5,20(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
    3e04:	0bc78413          	addi	s0,a5,188 # 60bc <__data_region_end>
    3e08:	0bc78493          	addi	s1,a5,188
    3e0c:	0bc90913          	addi	s2,s2,188 # 60bc <__data_region_end>
    3e10:	05246063          	bltu	s0,s2,3e50 <z_init_static_threads+0x74>
	k_sched_lock();
    3e14:	284000ef          	jal	ra,4098 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    3e18:	00048413          	mv	s0,s1
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    3e1c:	fff00993          	li	s3,-1
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
    3e20:	00900a13          	li	s4,9

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    3e24:	00004ab7          	lui	s5,0x4
	_FOREACH_STATIC_THREAD(thread_data) {
    3e28:	07246663          	bltu	s0,s2,3e94 <z_init_static_threads+0xb8>
}
    3e2c:	02812403          	lw	s0,40(sp)
    3e30:	02c12083          	lw	ra,44(sp)
    3e34:	02412483          	lw	s1,36(sp)
    3e38:	02012903          	lw	s2,32(sp)
    3e3c:	01c12983          	lw	s3,28(sp)
    3e40:	01812a03          	lw	s4,24(sp)
    3e44:	01412a83          	lw	s5,20(sp)
    3e48:	03010113          	addi	sp,sp,48
	k_sched_unlock();
    3e4c:	5f80006f          	j	4444 <k_sched_unlock>
		z_setup_new_thread(
    3e50:	02c42783          	lw	a5,44(s0)
    3e54:	00f12223          	sw	a5,4(sp)
    3e58:	02042783          	lw	a5,32(s0)
    3e5c:	00f12023          	sw	a5,0(sp)
    3e60:	01442783          	lw	a5,20(s0)
    3e64:	01c42883          	lw	a7,28(s0)
    3e68:	01842803          	lw	a6,24(s0)
    3e6c:	01042703          	lw	a4,16(s0)
    3e70:	00c42683          	lw	a3,12(s0)
    3e74:	00842603          	lw	a2,8(s0)
    3e78:	00442583          	lw	a1,4(s0)
    3e7c:	00042503          	lw	a0,0(s0)
    3e80:	ed9ff0ef          	jal	ra,3d58 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    3e84:	00042783          	lw	a5,0(s0)
    3e88:	0687a223          	sw	s0,100(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
    3e8c:	03040413          	addi	s0,s0,48
    3e90:	f81ff06f          	j	3e10 <z_init_static_threads+0x34>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    3e94:	02442783          	lw	a5,36(s0)
    3e98:	03378863          	beq	a5,s3,3ec8 <z_init_static_threads+0xec>
			schedule_new_thread(thread_data->init_thread,
    3e9c:	00042483          	lw	s1,0(s0)
					    K_MSEC(thread_data->init_delay));
    3ea0:	0007d463          	bgez	a5,3ea8 <z_init_static_threads+0xcc>
    3ea4:	00000793          	li	a5,0
    3ea8:	00978513          	addi	a0,a5,9
    3eac:	41f7d593          	srai	a1,a5,0x1f
    3eb0:	00f537b3          	sltu	a5,a0,a5
    3eb4:	00b785b3          	add	a1,a5,a1
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    3eb8:	01451c63          	bne	a0,s4,3ed0 <z_init_static_threads+0xf4>
    3ebc:	00059a63          	bnez	a1,3ed0 <z_init_static_threads+0xf4>
	z_sched_start(thread);
    3ec0:	00048513          	mv	a0,s1
    3ec4:	4c4000ef          	jal	ra,4388 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    3ec8:	03040413          	addi	s0,s0,48
    3ecc:	f5dff06f          	j	3e28 <z_init_static_threads+0x4c>
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
    3ed0:	00a00613          	li	a2,10
    3ed4:	00000693          	li	a3,0
    3ed8:	c64fc0ef          	jal	ra,33c <__udivdi3>
    3edc:	00050613          	mv	a2,a0
    3ee0:	00058693          	mv	a3,a1
    3ee4:	01848513          	addi	a0,s1,24
    3ee8:	3d8a8593          	addi	a1,s5,984 # 43d8 <z_thread_timeout>
    3eec:	7c8000ef          	jal	ra,46b4 <z_add_timeout>
    3ef0:	fd9ff06f          	j	3ec8 <z_init_static_threads+0xec>

00003ef4 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    3ef4:	ff010113          	addi	sp,sp,-16
    3ef8:	00812423          	sw	s0,8(sp)
    3efc:	00112623          	sw	ra,12(sp)
    3f00:	00800413          	li	s0,8
    3f04:	300437f3          	csrrc	a5,mstatus,s0
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    3f08:	960ff0ef          	jal	ra,3068 <arch_cpu_idle>
    3f0c:	ff9ff06f          	j	3f04 <idle+0x10>

00003f10 <sys_dlist_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    3f10:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
    3f14:	00052783          	lw	a5,0(a0)

	prev->next = next;
    3f18:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
    3f1c:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
    3f20:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
    3f24:	00052223          	sw	zero,4(a0)
	sys_dnode_init(node);
}
    3f28:	00008067          	ret

00003f2c <unpend_thread_no_timeout>:
		pend_locked(thread, wait_q, timeout);
	}
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
    3f2c:	ff010113          	addi	sp,sp,-16
    3f30:	00812423          	sw	s0,8(sp)
    3f34:	00112623          	sw	ra,12(sp)
    3f38:	00050413          	mv	s0,a0

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    3f3c:	fd5ff0ef          	jal	ra,3f10 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
    3f40:	00d44783          	lbu	a5,13(s0)
}
    3f44:	00c12083          	lw	ra,12(sp)
	thread->base.pended_on = NULL;
    3f48:	00042423          	sw	zero,8(s0)
    3f4c:	ffd7f793          	andi	a5,a5,-3
    3f50:	00f406a3          	sb	a5,13(s0)
}
    3f54:	00812403          	lw	s0,8(sp)
    3f58:	01010113          	addi	sp,sp,16
    3f5c:	00008067          	ret

00003f60 <z_reset_time_slice>:
{
    3f60:	ff010113          	addi	sp,sp,-16
    3f64:	00812423          	sw	s0,8(sp)
	if (slice_time != 0) {
    3f68:	00005437          	lui	s0,0x5
    3f6c:	15c40413          	addi	s0,s0,348 # 515c <slice_time>
    3f70:	00042783          	lw	a5,0(s0)
{
    3f74:	00112623          	sw	ra,12(sp)
	if (slice_time != 0) {
    3f78:	02078863          	beqz	a5,3fa8 <z_reset_time_slice+0x48>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    3f7c:	aa9ff0ef          	jal	ra,3a24 <sys_clock_elapsed>
    3f80:	00050793          	mv	a5,a0
    3f84:	00042503          	lw	a0,0(s0)
}
    3f88:	00812403          	lw	s0,8(sp)
    3f8c:	00c12083          	lw	ra,12(sp)
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    3f90:	00f507b3          	add	a5,a0,a5
    3f94:	00005737          	lui	a4,0x5
    3f98:	26f72c23          	sw	a5,632(a4) # 5278 <_kernel+0x10>
		z_set_timeout_expiry(slice_time, false);
    3f9c:	00000593          	li	a1,0
}
    3fa0:	01010113          	addi	sp,sp,16
		z_set_timeout_expiry(slice_time, false);
    3fa4:	1050006f          	j	48a8 <z_set_timeout_expiry>
}
    3fa8:	00c12083          	lw	ra,12(sp)
    3fac:	00812403          	lw	s0,8(sp)
    3fb0:	01010113          	addi	sp,sp,16
    3fb4:	00008067          	ret

00003fb8 <k_sched_time_slice_set>:
{
    3fb8:	ff010113          	addi	sp,sp,-16
    3fbc:	00812423          	sw	s0,8(sp)
    3fc0:	00912223          	sw	s1,4(sp)
    3fc4:	00112623          	sw	ra,12(sp)
    3fc8:	00050793          	mv	a5,a0
    3fcc:	00058493          	mv	s1,a1
    3fd0:	00800413          	li	s0,8
    3fd4:	30043473          	csrrc	s0,mstatus,s0
		_current_cpu->slice_ticks = 0;
    3fd8:	00005737          	lui	a4,0x5
		t += off;
    3fdc:	00950513          	addi	a0,a0,9
    3fe0:	26072c23          	sw	zero,632(a4) # 5278 <_kernel+0x10>
	key = (mstatus & MSTATUS_IEN);
    3fe4:	00847413          	andi	s0,s0,8
    3fe8:	00f535b3          	sltu	a1,a0,a5
		if (result32 && (t < BIT64(32))) {
    3fec:	02f56c63          	bltu	a0,a5,4024 <k_sched_time_slice_set+0x6c>
			return ((uint32_t)t) / (from_hz / to_hz);
    3ff0:	00a00793          	li	a5,10
    3ff4:	02f55533          	divu	a0,a0,a5
		slice_time = k_ms_to_ticks_ceil32(slice);
    3ff8:	000057b7          	lui	a5,0x5
    3ffc:	14a7ae23          	sw	a0,348(a5) # 515c <slice_time>
		slice_max_prio = prio;
    4000:	000057b7          	lui	a5,0x5
    4004:	1497ac23          	sw	s1,344(a5) # 5158 <slice_max_prio>
		z_reset_time_slice();
    4008:	f59ff0ef          	jal	ra,3f60 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    400c:	30042473          	csrrs	s0,mstatus,s0
}
    4010:	00c12083          	lw	ra,12(sp)
    4014:	00812403          	lw	s0,8(sp)
    4018:	00412483          	lw	s1,4(sp)
    401c:	01010113          	addi	sp,sp,16
    4020:	00008067          	ret
			return t / ((uint64_t)from_hz / to_hz);
    4024:	00a00613          	li	a2,10
    4028:	00000693          	li	a3,0
    402c:	b10fc0ef          	jal	ra,33c <__udivdi3>
    4030:	fc9ff06f          	j	3ff8 <k_sched_time_slice_set+0x40>

00004034 <z_reschedule>:
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
    4034:	0085f713          	andi	a4,a1,8
{
    4038:	00058513          	mv	a0,a1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    403c:	02070263          	beqz	a4,4060 <z_reschedule+0x2c>
FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf);

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
    4040:	000057b7          	lui	a5,0x5
    4044:	26878793          	addi	a5,a5,616 # 5268 <_kernel>
	if (resched(key.key) && need_swap()) {
    4048:	0007a683          	lw	a3,0(a5)
    404c:	00069a63          	bnez	a3,4060 <z_reschedule+0x2c>
    4050:	0187a683          	lw	a3,24(a5)
    4054:	0087a783          	lw	a5,8(a5)
    4058:	00f68463          	beq	a3,a5,4060 <z_reschedule+0x2c>
    405c:	a70fc06f          	j	2cc <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    4060:	30072773          	csrrs	a4,mstatus,a4
}
    4064:	00008067          	ret

00004068 <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
    4068:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    406c:	00078a63          	beqz	a5,4080 <z_reschedule_irqlock+0x18>
	if (resched(key)) {
    4070:	00005737          	lui	a4,0x5
    4074:	26872703          	lw	a4,616(a4) # 5268 <_kernel>
    4078:	00071463          	bnez	a4,4080 <z_reschedule_irqlock+0x18>
    407c:	a50fc06f          	j	2cc <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    4080:	3007a7f3          	csrrs	a5,mstatus,a5
}
    4084:	00008067          	ret

00004088 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    4088:	00800513          	li	a0,8
    408c:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(arch_irq_lock());
    4090:	00857513          	andi	a0,a0,8
    4094:	fd5ff06f          	j	4068 <z_reschedule_irqlock>

00004098 <k_sched_lock>:
    4098:	00800793          	li	a5,8
    409c:	3007b7f3          	csrrc	a5,mstatus,a5
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    40a0:	00005737          	lui	a4,0x5
    40a4:	27072683          	lw	a3,624(a4) # 5270 <_kernel+0x8>
    40a8:	00f6c703          	lbu	a4,15(a3)
    40ac:	fff70713          	addi	a4,a4,-1
    40b0:	00e687a3          	sb	a4,15(a3)
	key = (mstatus & MSTATUS_IEN);
    40b4:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    40b8:	3007a7f3          	csrrs	a5,mstatus,a5
}
    40bc:	00008067          	ret

000040c0 <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
    40c0:	00050793          	mv	a5,a0
	return list->head == list;
    40c4:	00052503          	lw	a0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40c8:	00a79463          	bne	a5,a0,40d0 <z_priq_dumb_best+0x10>
	struct k_thread *thread = NULL;
    40cc:	00000513          	li	a0,0

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    40d0:	00008067          	ret

000040d4 <update_cache>:
{
    40d4:	ff010113          	addi	sp,sp,-16
    40d8:	01212023          	sw	s2,0(sp)
    40dc:	00050913          	mv	s2,a0
	thread = _priq_run_best(&_kernel.ready_q.runq);
    40e0:	00005537          	lui	a0,0x5
    40e4:	28450513          	addi	a0,a0,644 # 5284 <_kernel+0x1c>
{
    40e8:	00812423          	sw	s0,8(sp)
    40ec:	00912223          	sw	s1,4(sp)
    40f0:	00112623          	sw	ra,12(sp)
    40f4:	00005437          	lui	s0,0x5
	thread = _priq_run_best(&_kernel.ready_q.runq);
    40f8:	fc9ff0ef          	jal	ra,40c0 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    40fc:	26840413          	addi	s0,s0,616 # 5268 <_kernel>
    4100:	00050493          	mv	s1,a0
    4104:	00051463          	bnez	a0,410c <update_cache+0x38>
    4108:	00c42483          	lw	s1,12(s0)
	if (z_is_thread_prevented_from_running(_current)) {
    410c:	00842783          	lw	a5,8(s0)
	if (preempt_ok != 0) {
    4110:	02091c63          	bnez	s2,4148 <update_cache+0x74>
	if (z_is_thread_prevented_from_running(_current)) {
    4114:	00d7c703          	lbu	a4,13(a5)
    4118:	01f77713          	andi	a4,a4,31
    411c:	02071663          	bnez	a4,4148 <update_cache+0x74>
	if (is_preempt(_current) || is_metairq(thread)) {
    4120:	00e7d683          	lhu	a3,14(a5)
    4124:	07f00713          	li	a4,127
    4128:	02d77063          	bgeu	a4,a3,4148 <update_cache+0x74>
		_kernel.ready_q.cache = _current;
    412c:	00f42c23          	sw	a5,24(s0)
}
    4130:	00c12083          	lw	ra,12(sp)
    4134:	00812403          	lw	s0,8(sp)
    4138:	00412483          	lw	s1,4(sp)
    413c:	00012903          	lw	s2,0(sp)
    4140:	01010113          	addi	sp,sp,16
    4144:	00008067          	ret
		if (thread != _current) {
    4148:	00f48463          	beq	s1,a5,4150 <update_cache+0x7c>
			z_reset_time_slice();
    414c:	e15ff0ef          	jal	ra,3f60 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    4150:	00942c23          	sw	s1,24(s0)
}
    4154:	fddff06f          	j	4130 <update_cache+0x5c>

00004158 <move_thread_to_end_of_prio_q>:
{
    4158:	ff010113          	addi	sp,sp,-16
    415c:	00812423          	sw	s0,8(sp)
    4160:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
    4164:	00d54783          	lbu	a5,13(a0)
    4168:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
    416c:	01879713          	slli	a4,a5,0x18
    4170:	41875713          	srai	a4,a4,0x18
    4174:	00075863          	bgez	a4,4184 <move_thread_to_end_of_prio_q+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4178:	07f7f793          	andi	a5,a5,127
    417c:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
    4180:	d91ff0ef          	jal	ra,3f10 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    4184:	00d44783          	lbu	a5,13(s0)
	return list->head == list;
    4188:	00005737          	lui	a4,0x5
    418c:	26870693          	addi	a3,a4,616 # 5268 <_kernel>
    4190:	f807e793          	ori	a5,a5,-128
    4194:	00f406a3          	sb	a5,13(s0)
    4198:	01c6a783          	lw	a5,28(a3)
	return (node == list->tail) ? NULL : node->next;
    419c:	0206a583          	lw	a1,32(a3)
    41a0:	000056b7          	lui	a3,0x5
    41a4:	28468693          	addi	a3,a3,644 # 5284 <_kernel+0x1c>
    41a8:	26870713          	addi	a4,a4,616
	return sys_dlist_is_empty(list) ? NULL : list->head;
    41ac:	04d78c63          	beq	a5,a3,4204 <move_thread_to_end_of_prio_q+0xac>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    41b0:	04078a63          	beqz	a5,4204 <move_thread_to_end_of_prio_q+0xac>
	int32_t b1 = thread_1->base.prio;
    41b4:	00e40503          	lb	a0,14(s0)
	int32_t b2 = thread_2->base.prio;
    41b8:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
    41bc:	02c50e63          	beq	a0,a2,41f8 <move_thread_to_end_of_prio_q+0xa0>
		return b2 - b1;
    41c0:	40a60633          	sub	a2,a2,a0
		if (z_sched_prio_cmp(thread, t) > 0) {
    41c4:	02c05a63          	blez	a2,41f8 <move_thread_to_end_of_prio_q+0xa0>
	sys_dnode_t *const prev = successor->prev;
    41c8:	0047a683          	lw	a3,4(a5)
	node->next = successor;
    41cc:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
    41d0:	00d42223          	sw	a3,4(s0)
	prev->next = node;
    41d4:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
    41d8:	0087a223          	sw	s0,4(a5)
	update_cache(thread == _current);
    41dc:	00872503          	lw	a0,8(a4)
}
    41e0:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
    41e4:	40850533          	sub	a0,a0,s0
}
    41e8:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
    41ec:	00153513          	seqz	a0,a0
}
    41f0:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
    41f4:	ee1ff06f          	j	40d4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    41f8:	00b78663          	beq	a5,a1,4204 <move_thread_to_end_of_prio_q+0xac>
    41fc:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4200:	fa079ce3          	bnez	a5,41b8 <move_thread_to_end_of_prio_q+0x60>
	node->next = list;
    4204:	00d42023          	sw	a3,0(s0)
	node->prev = tail;
    4208:	00b42223          	sw	a1,4(s0)
	tail->next = node;
    420c:	0085a023          	sw	s0,0(a1)
	list->tail = node;
    4210:	02872023          	sw	s0,32(a4)
}
    4214:	fc9ff06f          	j	41dc <move_thread_to_end_of_prio_q+0x84>

00004218 <z_time_slice>:
{
    4218:	ff010113          	addi	sp,sp,-16
    421c:	00812423          	sw	s0,8(sp)
    4220:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    4224:	00800413          	li	s0,8
    4228:	30043473          	csrrc	s0,mstatus,s0
	if (slice_time && sliceable(_current)) {
    422c:	000057b7          	lui	a5,0x5
    4230:	15c7a703          	lw	a4,348(a5) # 515c <slice_time>
    4234:	000057b7          	lui	a5,0x5
	key = (mstatus & MSTATUS_IEN);
    4238:	00847413          	andi	s0,s0,8
    423c:	26878793          	addi	a5,a5,616 # 5268 <_kernel>
    4240:	06070863          	beqz	a4,42b0 <z_time_slice+0x98>
    4244:	00050693          	mv	a3,a0
    4248:	0087a503          	lw	a0,8(a5)
		&& !z_is_idle_thread_object(thread);
    424c:	07f00713          	li	a4,127
    4250:	00e55603          	lhu	a2,14(a0)
    4254:	04c76e63          	bltu	a4,a2,42b0 <z_time_slice+0x98>
		&& !z_is_thread_prevented_from_running(thread)
    4258:	00d54703          	lbu	a4,13(a0)
    425c:	01f77713          	andi	a4,a4,31
    4260:	04071863          	bnez	a4,42b0 <z_time_slice+0x98>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    4264:	00005737          	lui	a4,0x5
    4268:	00e50603          	lb	a2,14(a0)
    426c:	15872703          	lw	a4,344(a4) # 5158 <slice_max_prio>
    4270:	04e64063          	blt	a2,a4,42b0 <z_time_slice+0x98>
		&& !z_is_idle_thread_object(thread);
    4274:	00005737          	lui	a4,0x5
    4278:	16870713          	addi	a4,a4,360 # 5168 <z_idle_threads>
    427c:	02e50a63          	beq	a0,a4,42b0 <z_time_slice+0x98>
		if (ticks >= _current_cpu->slice_ticks) {
    4280:	0107a703          	lw	a4,16(a5)
    4284:	02e6c063          	blt	a3,a4,42a4 <z_time_slice+0x8c>
			move_thread_to_end_of_prio_q(_current);
    4288:	ed1ff0ef          	jal	ra,4158 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    428c:	cd5ff0ef          	jal	ra,3f60 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    4290:	30042473          	csrrs	s0,mstatus,s0
}
    4294:	00c12083          	lw	ra,12(sp)
    4298:	00812403          	lw	s0,8(sp)
    429c:	01010113          	addi	sp,sp,16
    42a0:	00008067          	ret
			_current_cpu->slice_ticks -= ticks;
    42a4:	40d70733          	sub	a4,a4,a3
    42a8:	00e7a823          	sw	a4,16(a5)
    42ac:	fe5ff06f          	j	4290 <z_time_slice+0x78>
		_current_cpu->slice_ticks = 0;
    42b0:	0007a823          	sw	zero,16(a5)
    42b4:	fddff06f          	j	4290 <z_time_slice+0x78>

000042b8 <ready_thread>:
    42b8:	00d54783          	lbu	a5,13(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    42bc:	01879713          	slli	a4,a5,0x18
    42c0:	41875713          	srai	a4,a4,0x18
    42c4:	08074863          	bltz	a4,4354 <ready_thread+0x9c>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    42c8:	01f7f713          	andi	a4,a5,31
    42cc:	08071463          	bnez	a4,4354 <ready_thread+0x9c>
    42d0:	01852703          	lw	a4,24(a0)
    42d4:	08071063          	bnez	a4,4354 <ready_thread+0x9c>
	thread->base.thread_state |= _THREAD_QUEUED;
    42d8:	f807e793          	ori	a5,a5,-128
	return list->head == list;
    42dc:	00005737          	lui	a4,0x5
    42e0:	26870693          	addi	a3,a4,616 # 5268 <_kernel>
    42e4:	00f506a3          	sb	a5,13(a0)
    42e8:	01c6a783          	lw	a5,28(a3)
	return (node == list->tail) ? NULL : node->next;
    42ec:	0206a583          	lw	a1,32(a3)
    42f0:	000056b7          	lui	a3,0x5
    42f4:	28468693          	addi	a3,a3,644 # 5284 <_kernel+0x1c>
    42f8:	26870713          	addi	a4,a4,616
	return sys_dlist_is_empty(list) ? NULL : list->head;
    42fc:	04d78263          	beq	a5,a3,4340 <ready_thread+0x88>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4300:	04078063          	beqz	a5,4340 <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
    4304:	00e50803          	lb	a6,14(a0)
	int32_t b2 = thread_2->base.prio;
    4308:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
    430c:	02c80463          	beq	a6,a2,4334 <ready_thread+0x7c>
		return b2 - b1;
    4310:	41060633          	sub	a2,a2,a6
		if (z_sched_prio_cmp(thread, t) > 0) {
    4314:	02c05063          	blez	a2,4334 <ready_thread+0x7c>
	sys_dnode_t *const prev = successor->prev;
    4318:	0047a703          	lw	a4,4(a5)
	node->next = successor;
    431c:	00f52023          	sw	a5,0(a0)
	node->prev = prev;
    4320:	00e52223          	sw	a4,4(a0)
	prev->next = node;
    4324:	00a72023          	sw	a0,0(a4)
	successor->prev = node;
    4328:	00a7a223          	sw	a0,4(a5)
		update_cache(0);
    432c:	00000513          	li	a0,0
    4330:	da5ff06f          	j	40d4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    4334:	00b78663          	beq	a5,a1,4340 <ready_thread+0x88>
    4338:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    433c:	fc0796e3          	bnez	a5,4308 <ready_thread+0x50>
	node->next = list;
    4340:	00d52023          	sw	a3,0(a0)
	node->prev = tail;
    4344:	00b52223          	sw	a1,4(a0)
	tail->next = node;
    4348:	00a5a023          	sw	a0,0(a1)
	list->tail = node;
    434c:	02a72023          	sw	a0,32(a4)
}
    4350:	fddff06f          	j	432c <ready_thread+0x74>
}
    4354:	00008067          	ret

00004358 <z_ready_thread>:
{
    4358:	ff010113          	addi	sp,sp,-16
    435c:	00812423          	sw	s0,8(sp)
    4360:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    4364:	00800413          	li	s0,8
    4368:	30043473          	csrrc	s0,mstatus,s0
			ready_thread(thread);
    436c:	f4dff0ef          	jal	ra,42b8 <ready_thread>
	key = (mstatus & MSTATUS_IEN);
    4370:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    4374:	30042473          	csrrs	s0,mstatus,s0
}
    4378:	00c12083          	lw	ra,12(sp)
    437c:	00812403          	lw	s0,8(sp)
    4380:	01010113          	addi	sp,sp,16
    4384:	00008067          	ret

00004388 <z_sched_start>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    4388:	00800593          	li	a1,8
    438c:	3005b5f3          	csrrc	a1,mstatus,a1
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    4390:	00d54703          	lbu	a4,13(a0)
	key = (mstatus & MSTATUS_IEN);
    4394:	0085f593          	andi	a1,a1,8
	if (z_has_thread_started(thread)) {
    4398:	00477693          	andi	a3,a4,4
    439c:	00069663          	bnez	a3,43a8 <z_sched_start+0x20>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    43a0:	3005a5f3          	csrrs	a1,mstatus,a1
		return;
    43a4:	00008067          	ret
{
    43a8:	fe010113          	addi	sp,sp,-32
    43ac:	00112e23          	sw	ra,28(sp)
	thread->base.thread_state &= ~_THREAD_PRESTART;
    43b0:	ffb77713          	andi	a4,a4,-5
    43b4:	00e506a3          	sb	a4,13(a0)
    43b8:	00b12623          	sw	a1,12(sp)
	ready_thread(thread);
    43bc:	efdff0ef          	jal	ra,42b8 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    43c0:	00c12583          	lw	a1,12(sp)
}
    43c4:	01c12083          	lw	ra,28(sp)
	z_reschedule(&sched_spinlock, key);
    43c8:	00005537          	lui	a0,0x5
    43cc:	28c50513          	addi	a0,a0,652 # 528c <sched_spinlock>
}
    43d0:	02010113          	addi	sp,sp,32
	z_reschedule(&sched_spinlock, key);
    43d4:	c61ff06f          	j	4034 <z_reschedule>

000043d8 <z_thread_timeout>:
{
    43d8:	fe010113          	addi	sp,sp,-32
    43dc:	00912a23          	sw	s1,20(sp)
    43e0:	00112e23          	sw	ra,28(sp)
    43e4:	00812c23          	sw	s0,24(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    43e8:	00800493          	li	s1,8
    43ec:	3004b4f3          	csrrc	s1,mstatus,s1
		if (!killed) {
    43f0:	ff554783          	lbu	a5,-11(a0)
	key = (mstatus & MSTATUS_IEN);
    43f4:	0084f493          	andi	s1,s1,8
    43f8:	0287f793          	andi	a5,a5,40
    43fc:	02079863          	bnez	a5,442c <z_thread_timeout+0x54>
    4400:	00050413          	mv	s0,a0
			if (thread->base.pended_on != NULL) {
    4404:	ff042783          	lw	a5,-16(s0)
	struct k_thread *thread = CONTAINER_OF(timeout,
    4408:	fe850513          	addi	a0,a0,-24
			if (thread->base.pended_on != NULL) {
    440c:	00078863          	beqz	a5,441c <z_thread_timeout+0x44>
				unpend_thread_no_timeout(thread);
    4410:	00a12623          	sw	a0,12(sp)
    4414:	b19ff0ef          	jal	ra,3f2c <unpend_thread_no_timeout>
    4418:	00c12503          	lw	a0,12(sp)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    441c:	ff544783          	lbu	a5,-11(s0)
    4420:	feb7f793          	andi	a5,a5,-21
    4424:	fef40aa3          	sb	a5,-11(s0)
			ready_thread(thread);
    4428:	e91ff0ef          	jal	ra,42b8 <ready_thread>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    442c:	3004a4f3          	csrrs	s1,mstatus,s1
}
    4430:	01c12083          	lw	ra,28(sp)
    4434:	01812403          	lw	s0,24(sp)
    4438:	01412483          	lw	s1,20(sp)
    443c:	02010113          	addi	sp,sp,32
    4440:	00008067          	ret

00004444 <k_sched_unlock>:
{
    4444:	ff010113          	addi	sp,sp,-16
    4448:	00812423          	sw	s0,8(sp)
    444c:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    4450:	00800413          	li	s0,8
    4454:	30043473          	csrrc	s0,mstatus,s0
		++_current->base.sched_locked;
    4458:	000057b7          	lui	a5,0x5
    445c:	2707a703          	lw	a4,624(a5) # 5270 <_kernel+0x8>
		update_cache(0);
    4460:	00000513          	li	a0,0
	key = (mstatus & MSTATUS_IEN);
    4464:	00847413          	andi	s0,s0,8
		++_current->base.sched_locked;
    4468:	00f74783          	lbu	a5,15(a4)
    446c:	00178793          	addi	a5,a5,1
    4470:	00f707a3          	sb	a5,15(a4)
		update_cache(0);
    4474:	c61ff0ef          	jal	ra,40d4 <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    4478:	30042473          	csrrs	s0,mstatus,s0
}
    447c:	00812403          	lw	s0,8(sp)
    4480:	00c12083          	lw	ra,12(sp)
    4484:	01010113          	addi	sp,sp,16
	z_reschedule_unlocked();
    4488:	c01ff06f          	j	4088 <z_reschedule_unlocked>

0000448c <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    448c:	000057b7          	lui	a5,0x5
    4490:	00005737          	lui	a4,0x5
    4494:	26878793          	addi	a5,a5,616 # 5268 <_kernel>
    4498:	28470713          	addi	a4,a4,644 # 5284 <_kernel+0x1c>
    449c:	00e7ae23          	sw	a4,28(a5)
	list->tail = (sys_dnode_t *)list;
    44a0:	02e7a023          	sw	a4,32(a5)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    44a4:	00000593          	li	a1,0
    44a8:	00000513          	li	a0,0
    44ac:	b0dff06f          	j	3fb8 <k_sched_time_slice_set>

000044b0 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    44b0:	000057b7          	lui	a5,0x5
    44b4:	2707a503          	lw	a0,624(a5) # 5270 <_kernel+0x8>
    44b8:	00008067          	ret

000044bc <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    44bc:	fe010113          	addi	sp,sp,-32
    44c0:	00912a23          	sw	s1,20(sp)
    44c4:	00112e23          	sw	ra,28(sp)
    44c8:	00812c23          	sw	s0,24(sp)
    44cc:	01212823          	sw	s2,16(sp)
    44d0:	01312623          	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    44d4:	00800493          	li	s1,8
    44d8:	3004b4f3          	csrrc	s1,mstatus,s1
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    44dc:	00d54783          	lbu	a5,13(a0)
	key = (mstatus & MSTATUS_IEN);
    44e0:	0084f493          	andi	s1,s1,8
    44e4:	0087f713          	andi	a4,a5,8
    44e8:	02070263          	beqz	a4,450c <z_thread_abort+0x50>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    44ec:	3004a4f3          	csrrs	s1,mstatus,s1
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    44f0:	01c12083          	lw	ra,28(sp)
    44f4:	01812403          	lw	s0,24(sp)
    44f8:	01412483          	lw	s1,20(sp)
    44fc:	01012903          	lw	s2,16(sp)
    4500:	00c12983          	lw	s3,12(sp)
    4504:	02010113          	addi	sp,sp,32
    4508:	00008067          	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
    450c:	fdf7f713          	andi	a4,a5,-33
    4510:	00876713          	ori	a4,a4,8
		if (z_is_thread_queued(thread)) {
    4514:	01871693          	slli	a3,a4,0x18
    4518:	4186d693          	srai	a3,a3,0x18
    451c:	00050413          	mv	s0,a0
    4520:	0406ce63          	bltz	a3,457c <z_thread_abort+0xc0>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    4524:	00e506a3          	sb	a4,13(a0)
		if (thread->base.pended_on != NULL) {
    4528:	00842783          	lw	a5,8(s0)
    452c:	00078663          	beqz	a5,4538 <z_thread_abort+0x7c>
			unpend_thread_no_timeout(thread);
    4530:	00040513          	mv	a0,s0
    4534:	9f9ff0ef          	jal	ra,3f2c <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    4538:	01840513          	addi	a0,s0,24
    453c:	328000ef          	jal	ra,4864 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    4540:	06840993          	addi	s3,s0,104
	return list->head == list;
    4544:	06842903          	lw	s2,104(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4548:	01390463          	beq	s2,s3,4550 <z_thread_abort+0x94>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    454c:	04091263          	bnez	s2,4590 <z_thread_abort+0xd4>
		update_cache(1);
    4550:	00100513          	li	a0,1
    4554:	b81ff0ef          	jal	ra,40d4 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
    4558:	000057b7          	lui	a5,0x5
    455c:	26878793          	addi	a5,a5,616 # 5268 <_kernel>
    4560:	0087a703          	lw	a4,8(a5)
    4564:	f88714e3          	bne	a4,s0,44ec <z_thread_abort+0x30>
    4568:	0007a783          	lw	a5,0(a5)
    456c:	f80790e3          	bnez	a5,44ec <z_thread_abort+0x30>
    4570:	00048513          	mv	a0,s1
    4574:	d59fb0ef          	jal	ra,2cc <arch_swap>
	return ret;
    4578:	f75ff06f          	j	44ec <z_thread_abort+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    457c:	05f7f793          	andi	a5,a5,95
    4580:	0087e793          	ori	a5,a5,8
    4584:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
    4588:	989ff0ef          	jal	ra,3f10 <sys_dlist_remove>
}
    458c:	f9dff06f          	j	4528 <z_thread_abort+0x6c>
		unpend_thread_no_timeout(thread);
    4590:	00090513          	mv	a0,s2
    4594:	999ff0ef          	jal	ra,3f2c <unpend_thread_no_timeout>
    4598:	01890513          	addi	a0,s2,24
    459c:	2c8000ef          	jal	ra,4864 <z_abort_timeout>
		ready_thread(thread);
    45a0:	00090513          	mv	a0,s2
	thread->arch.swap_return_value = value;
    45a4:	06092c23          	sw	zero,120(s2)
    45a8:	d11ff0ef          	jal	ra,42b8 <ready_thread>
    45ac:	f99ff06f          	j	4544 <z_thread_abort+0x88>

000045b0 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
    45b0:	f0dff06f          	j	44bc <z_thread_abort>

000045b4 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    45b4:	000057b7          	lui	a5,0x5
    45b8:	1607a783          	lw	a5,352(a5) # 5160 <announce_remaining>
    45bc:	00079463          	bnez	a5,45c4 <elapsed+0x10>
    45c0:	c64ff06f          	j	3a24 <sys_clock_elapsed>
}
    45c4:	00000513          	li	a0,0
    45c8:	00008067          	ret

000045cc <next_timeout>:
	return list->head == list;
    45cc:	000067b7          	lui	a5,0x6

static int32_t next_timeout(void)
{
    45d0:	ff010113          	addi	sp,sp,-16
    45d4:	0a078793          	addi	a5,a5,160 # 60a0 <timeout_list>
    45d8:	00812423          	sw	s0,8(sp)
    45dc:	0007a403          	lw	s0,0(a5)
    45e0:	00112623          	sw	ra,12(sp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    45e4:	00f41463          	bne	s0,a5,45ec <next_timeout+0x20>
    45e8:	00000413          	li	s0,0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    45ec:	fc9ff0ef          	jal	ra,45b4 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    45f0:	02040c63          	beqz	s0,4628 <next_timeout+0x5c>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    45f4:	01042703          	lw	a4,16(s0)
    45f8:	01442783          	lw	a5,20(s0)
    45fc:	41f55693          	srai	a3,a0,0x1f
    4600:	40a70533          	sub	a0,a4,a0
    4604:	00a73733          	sltu	a4,a4,a0
    4608:	40d787b3          	sub	a5,a5,a3
    460c:	40e787b3          	sub	a5,a5,a4
	int32_t ret = to == NULL ? MAX_WAIT
    4610:	00f04663          	bgtz	a5,461c <next_timeout+0x50>
    4614:	04079063          	bnez	a5,4654 <next_timeout+0x88>
    4618:	02050e63          	beqz	a0,4654 <next_timeout+0x88>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    461c:	00f04663          	bgtz	a5,4628 <next_timeout+0x5c>
    4620:	00079863          	bnez	a5,4630 <next_timeout+0x64>
    4624:	00055663          	bgez	a0,4630 <next_timeout+0x64>
	int32_t ret = to == NULL ? MAX_WAIT
    4628:	80000537          	lui	a0,0x80000
    462c:	fff54513          	not	a0,a0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    4630:	000057b7          	lui	a5,0x5
    4634:	2787a783          	lw	a5,632(a5) # 5278 <_kernel+0x10>
    4638:	00078663          	beqz	a5,4644 <next_timeout+0x78>
    463c:	00a7d463          	bge	a5,a0,4644 <next_timeout+0x78>
    4640:	00078513          	mv	a0,a5
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    4644:	00c12083          	lw	ra,12(sp)
    4648:	00812403          	lw	s0,8(sp)
    464c:	01010113          	addi	sp,sp,16
    4650:	00008067          	ret
	int32_t ret = to == NULL ? MAX_WAIT
    4654:	00000513          	li	a0,0
    4658:	fd9ff06f          	j	4630 <next_timeout+0x64>

0000465c <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
    465c:	00052783          	lw	a5,0(a0) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    4660:	02050e63          	beqz	a0,469c <remove_timeout+0x40>
	return (node == list->tail) ? NULL : node->next;
    4664:	00006737          	lui	a4,0x6
    4668:	0a472703          	lw	a4,164(a4) # 60a4 <timeout_list+0x4>
    466c:	02e50863          	beq	a0,a4,469c <remove_timeout+0x40>
	if (next(t) != NULL) {
    4670:	02078663          	beqz	a5,469c <remove_timeout+0x40>
		next(t)->dticks += t->dticks;
    4674:	0107a703          	lw	a4,16(a5)
    4678:	01052683          	lw	a3,16(a0)
    467c:	01452583          	lw	a1,20(a0)
    4680:	0147a603          	lw	a2,20(a5)
    4684:	00d706b3          	add	a3,a4,a3
    4688:	00e6b733          	sltu	a4,a3,a4
    468c:	00b60633          	add	a2,a2,a1
    4690:	00c70733          	add	a4,a4,a2
    4694:	00d7a823          	sw	a3,16(a5)
    4698:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = node->prev;
    469c:	00452703          	lw	a4,4(a0)
	prev->next = next;
    46a0:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
    46a4:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
    46a8:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
    46ac:	00052223          	sw	zero,4(a0)
}
    46b0:	00008067          	ret

000046b4 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    46b4:	fe010113          	addi	sp,sp,-32
    46b8:	00812c23          	sw	s0,24(sp)
    46bc:	00912a23          	sw	s1,20(sp)
    46c0:	01312623          	sw	s3,12(sp)
    46c4:	00112e23          	sw	ra,28(sp)
    46c8:	00068993          	mv	s3,a3
    46cc:	01212823          	sw	s2,16(sp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    46d0:	fff00693          	li	a3,-1
{
    46d4:	00050413          	mv	s0,a0
    46d8:	00060493          	mv	s1,a2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    46dc:	00d61463          	bne	a2,a3,46e4 <z_add_timeout+0x30>
    46e0:	16c98463          	beq	s3,a2,4848 <z_add_timeout+0x194>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    46e4:	00b42423          	sw	a1,8(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    46e8:	00800913          	li	s2,8
    46ec:	30093973          	csrrc	s2,mstatus,s2

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    46f0:	ffe00693          	li	a3,-2
    46f4:	409687b3          	sub	a5,a3,s1
    46f8:	00f6b733          	sltu	a4,a3,a5
    46fc:	fff9c793          	not	a5,s3
    4700:	40e787b3          	sub	a5,a5,a4
	key = (mstatus & MSTATUS_IEN);
    4704:	00897913          	andi	s2,s2,8
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    4708:	0607ce63          	bltz	a5,4784 <z_add_timeout+0xd0>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    470c:	000057b7          	lui	a5,0x5
    4710:	13878793          	addi	a5,a5,312 # 5138 <curr_tick>
    4714:	0007a703          	lw	a4,0(a5)
    4718:	0047a783          	lw	a5,4(a5)
    471c:	40e68733          	sub	a4,a3,a4
    4720:	00e6b6b3          	sltu	a3,a3,a4
    4724:	fff7c793          	not	a5,a5
    4728:	40d787b3          	sub	a5,a5,a3
    472c:	409704b3          	sub	s1,a4,s1
    4730:	00973733          	sltu	a4,a4,s1
    4734:	413786b3          	sub	a3,a5,s3

			to->dticks = MAX(1, ticks);
    4738:	40e686b3          	sub	a3,a3,a4
    473c:	00d04a63          	bgtz	a3,4750 <z_add_timeout+0x9c>
    4740:	00069463          	bnez	a3,4748 <z_add_timeout+0x94>
    4744:	00049663          	bnez	s1,4750 <z_add_timeout+0x9c>
    4748:	00100493          	li	s1,1
    474c:	00000693          	li	a3,0
    4750:	00942823          	sw	s1,16(s0)
	return list->head == list;
    4754:	00006637          	lui	a2,0x6
    4758:	0a060713          	addi	a4,a2,160 # 60a0 <timeout_list>
    475c:	00072783          	lw	a5,0(a4)
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    4760:	00d42a23          	sw	a3,20(s0)
    4764:	0a060613          	addi	a2,a2,160
	sys_dnode_t *const tail = list->tail;
    4768:	00472803          	lw	a6,4(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    476c:	06c79263          	bne	a5,a2,47d0 <z_add_timeout+0x11c>
	node->next = list;
    4770:	00c42023          	sw	a2,0(s0)
	node->prev = tail;
    4774:	01042223          	sw	a6,4(s0)
	tail->next = node;
    4778:	00882023          	sw	s0,0(a6)
	list->tail = node;
    477c:	00862223          	sw	s0,4(a2)
}
    4780:	09c0006f          	j	481c <z_add_timeout+0x168>
    4784:	e31ff0ef          	jal	ra,45b4 <elapsed>
    4788:	00148793          	addi	a5,s1,1
    478c:	0097b4b3          	sltu	s1,a5,s1
    4790:	013486b3          	add	a3,s1,s3
    4794:	41f55493          	srai	s1,a0,0x1f
    4798:	00a78533          	add	a0,a5,a0
    479c:	00f537b3          	sltu	a5,a0,a5
    47a0:	009686b3          	add	a3,a3,s1
    47a4:	00d786b3          	add	a3,a5,a3
    47a8:	00a42823          	sw	a0,16(s0)
    47ac:	fa9ff06f          	j	4754 <z_add_timeout+0xa0>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    47b0:	40e68733          	sub	a4,a3,a4
    47b4:	00e6b6b3          	sltu	a3,a3,a4
    47b8:	40a585b3          	sub	a1,a1,a0
    47bc:	40d586b3          	sub	a3,a1,a3
    47c0:	00e42823          	sw	a4,16(s0)
    47c4:	00d42a23          	sw	a3,20(s0)
	return (node == list->tail) ? NULL : node->next;
    47c8:	faf804e3          	beq	a6,a5,4770 <z_add_timeout+0xbc>
    47cc:	0007a783          	lw	a5,0(a5)
		for (t = first(); t != NULL; t = next(t)) {
    47d0:	fa0780e3          	beqz	a5,4770 <z_add_timeout+0xbc>
			if (t->dticks > to->dticks) {
    47d4:	0147a503          	lw	a0,20(a5)
    47d8:	01442583          	lw	a1,20(s0)
    47dc:	0107a703          	lw	a4,16(a5)
    47e0:	01042683          	lw	a3,16(s0)
    47e4:	00a5c663          	blt	a1,a0,47f0 <z_add_timeout+0x13c>
    47e8:	fcb514e3          	bne	a0,a1,47b0 <z_add_timeout+0xfc>
    47ec:	fce6f2e3          	bgeu	a3,a4,47b0 <z_add_timeout+0xfc>
				t->dticks -= to->dticks;
    47f0:	40d706b3          	sub	a3,a4,a3
    47f4:	00d73733          	sltu	a4,a4,a3
    47f8:	40b505b3          	sub	a1,a0,a1
    47fc:	40e58733          	sub	a4,a1,a4
    4800:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = successor->prev;
    4804:	0047a703          	lw	a4,4(a5)
    4808:	00d7a823          	sw	a3,16(a5)
	node->next = successor;
    480c:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
    4810:	00e42223          	sw	a4,4(s0)
	prev->next = node;
    4814:	00872023          	sw	s0,0(a4)
	successor->prev = node;
    4818:	0087a223          	sw	s0,4(a5)
	return list->head == list;
    481c:	00062783          	lw	a5,0(a2)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4820:	02c78263          	beq	a5,a2,4844 <z_add_timeout+0x190>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    4824:	02f41063          	bne	s0,a5,4844 <z_add_timeout+0x190>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    4828:	da5ff0ef          	jal	ra,45cc <next_timeout>

			if (next_time == 0 ||
    482c:	00050863          	beqz	a0,483c <z_add_timeout+0x188>
			    _current_cpu->slice_ticks != next_time) {
    4830:	000057b7          	lui	a5,0x5
			if (next_time == 0 ||
    4834:	2787a783          	lw	a5,632(a5) # 5278 <_kernel+0x10>
    4838:	00a78663          	beq	a5,a0,4844 <z_add_timeout+0x190>
				sys_clock_set_timeout(next_time, false);
    483c:	00000593          	li	a1,0
    4840:	9e0ff0ef          	jal	ra,3a20 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    4844:	30092973          	csrrs	s2,mstatus,s2
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    4848:	01c12083          	lw	ra,28(sp)
    484c:	01812403          	lw	s0,24(sp)
    4850:	01412483          	lw	s1,20(sp)
    4854:	01012903          	lw	s2,16(sp)
    4858:	00c12983          	lw	s3,12(sp)
    485c:	02010113          	addi	sp,sp,32
    4860:	00008067          	ret

00004864 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    4864:	ff010113          	addi	sp,sp,-16
    4868:	00812423          	sw	s0,8(sp)
    486c:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    4870:	00800413          	li	s0,8
    4874:	30043473          	csrrc	s0,mstatus,s0
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    4878:	00052783          	lw	a5,0(a0)
	key = (mstatus & MSTATUS_IEN);
    487c:	00847413          	andi	s0,s0,8
    4880:	02078063          	beqz	a5,48a0 <z_abort_timeout+0x3c>
			remove_timeout(to);
    4884:	dd9ff0ef          	jal	ra,465c <remove_timeout>
			ret = 0;
    4888:	00000513          	li	a0,0
	__asm__ volatile ("csrrs %0, mstatus, %1"
    488c:	30042473          	csrrs	s0,mstatus,s0
		}
	}

	return ret;
}
    4890:	00c12083          	lw	ra,12(sp)
    4894:	00812403          	lw	s0,8(sp)
    4898:	01010113          	addi	sp,sp,16
    489c:	00008067          	ret
	int ret = -EINVAL;
    48a0:	fea00513          	li	a0,-22
    48a4:	fe9ff06f          	j	488c <z_abort_timeout+0x28>

000048a8 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    48a8:	fe010113          	addi	sp,sp,-32
    48ac:	00812c23          	sw	s0,24(sp)
    48b0:	00912a23          	sw	s1,20(sp)
    48b4:	00112e23          	sw	ra,28(sp)
    48b8:	00050493          	mv	s1,a0
    48bc:	00b12623          	sw	a1,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    48c0:	00800413          	li	s0,8
    48c4:	30043473          	csrrc	s0,mstatus,s0
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    48c8:	d05ff0ef          	jal	ra,45cc <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    48cc:	00100793          	li	a5,1
	key = (mstatus & MSTATUS_IEN);
    48d0:	00847413          	andi	s0,s0,8
    48d4:	00a7da63          	bge	a5,a0,48e8 <z_set_timeout_expiry+0x40>
    48d8:	00c12583          	lw	a1,12(sp)
    48dc:	00954663          	blt	a0,s1,48e8 <z_set_timeout_expiry+0x40>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    48e0:	00048513          	mv	a0,s1
    48e4:	93cff0ef          	jal	ra,3a20 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    48e8:	30042473          	csrrs	s0,mstatus,s0
		}
	}
}
    48ec:	01c12083          	lw	ra,28(sp)
    48f0:	01812403          	lw	s0,24(sp)
    48f4:	01412483          	lw	s1,20(sp)
    48f8:	02010113          	addi	sp,sp,32
    48fc:	00008067          	ret

00004900 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    4900:	fd010113          	addi	sp,sp,-48
    4904:	02812423          	sw	s0,40(sp)
    4908:	02912223          	sw	s1,36(sp)
    490c:	02112623          	sw	ra,44(sp)
    4910:	03212023          	sw	s2,32(sp)
    4914:	01312e23          	sw	s3,28(sp)
    4918:	01412c23          	sw	s4,24(sp)
    491c:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
    4920:	00800413          	li	s0,8
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    4924:	8f5ff0ef          	jal	ra,4218 <z_time_slice>
    4928:	30043473          	csrrc	s0,mstatus,s0
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    492c:	00005937          	lui	s2,0x5
    4930:	16992023          	sw	s1,352(s2) # 5160 <announce_remaining>
	return list->head == list;
    4934:	000069b7          	lui	s3,0x6

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    4938:	000054b7          	lui	s1,0x5
	key = (mstatus & MSTATUS_IEN);
    493c:	00847413          	andi	s0,s0,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
    4940:	16090913          	addi	s2,s2,352
    4944:	0a098993          	addi	s3,s3,160 # 60a0 <timeout_list>
		curr_tick += dt;
    4948:	13848493          	addi	s1,s1,312 # 5138 <curr_tick>
	__asm__ volatile ("csrrc %0, mstatus, %1"
    494c:	00800a13          	li	s4,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
    4950:	00092783          	lw	a5,0(s2)
    4954:	0009a503          	lw	a0,0(s3)
		curr_tick += dt;
    4958:	0004a683          	lw	a3,0(s1)
    495c:	0044a883          	lw	a7,4(s1)
    4960:	41f7d593          	srai	a1,a5,0x1f
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4964:	03350a63          	beq	a0,s3,4998 <sys_clock_announce+0x98>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    4968:	02050863          	beqz	a0,4998 <sys_clock_announce+0x98>
    496c:	01452603          	lw	a2,20(a0)
    4970:	01052703          	lw	a4,16(a0)
    4974:	00c5c663          	blt	a1,a2,4980 <sys_clock_announce+0x80>
    4978:	06b61663          	bne	a2,a1,49e4 <sys_clock_announce+0xe4>
    497c:	06e7f463          	bgeu	a5,a4,49e4 <sys_clock_announce+0xe4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    4980:	40f70833          	sub	a6,a4,a5
    4984:	01073733          	sltu	a4,a4,a6
    4988:	40b60633          	sub	a2,a2,a1
    498c:	40e60733          	sub	a4,a2,a4
    4990:	01052823          	sw	a6,16(a0)
    4994:	00e52a23          	sw	a4,20(a0)
	}

	curr_tick += announce_remaining;
    4998:	00d786b3          	add	a3,a5,a3
    499c:	011585b3          	add	a1,a1,a7
    49a0:	00f6b7b3          	sltu	a5,a3,a5
    49a4:	00b787b3          	add	a5,a5,a1
    49a8:	00d4a023          	sw	a3,0(s1)
    49ac:	00f4a223          	sw	a5,4(s1)
	announce_remaining = 0;
    49b0:	00092023          	sw	zero,0(s2)

	sys_clock_set_timeout(next_timeout(), false);
    49b4:	c19ff0ef          	jal	ra,45cc <next_timeout>
    49b8:	00000593          	li	a1,0
    49bc:	864ff0ef          	jal	ra,3a20 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    49c0:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
    49c4:	02c12083          	lw	ra,44(sp)
    49c8:	02812403          	lw	s0,40(sp)
    49cc:	02412483          	lw	s1,36(sp)
    49d0:	02012903          	lw	s2,32(sp)
    49d4:	01c12983          	lw	s3,28(sp)
    49d8:	01812a03          	lw	s4,24(sp)
    49dc:	03010113          	addi	sp,sp,48
    49e0:	00008067          	ret
		curr_tick += dt;
    49e4:	00d706b3          	add	a3,a4,a3
		announce_remaining -= dt;
    49e8:	40e787b3          	sub	a5,a5,a4
		curr_tick += dt;
    49ec:	41f75593          	srai	a1,a4,0x1f
    49f0:	00e6b633          	sltu	a2,a3,a4
    49f4:	011585b3          	add	a1,a1,a7
		announce_remaining -= dt;
    49f8:	00f92023          	sw	a5,0(s2)
		t->dticks = 0;
    49fc:	00000813          	li	a6,0
    4a00:	00000793          	li	a5,0
		curr_tick += dt;
    4a04:	00b605b3          	add	a1,a2,a1
		t->dticks = 0;
    4a08:	00f52823          	sw	a5,16(a0)
    4a0c:	01052a23          	sw	a6,20(a0)
		curr_tick += dt;
    4a10:	00d4a023          	sw	a3,0(s1)
    4a14:	00b4a223          	sw	a1,4(s1)
		remove_timeout(t);
    4a18:	00a12623          	sw	a0,12(sp)
    4a1c:	c41ff0ef          	jal	ra,465c <remove_timeout>
    4a20:	30042473          	csrrs	s0,mstatus,s0
		t->fn(t);
    4a24:	00c12503          	lw	a0,12(sp)
    4a28:	00852783          	lw	a5,8(a0)
    4a2c:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
    4a30:	300a3473          	csrrc	s0,mstatus,s4
	key = (mstatus & MSTATUS_IEN);
    4a34:	00847413          	andi	s0,s0,8
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    4a38:	f19ff06f          	j	4950 <sys_clock_announce+0x50>

00004a3c <z_impl_atomic_add>:
 * @param value the value to add
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_add(atomic_t *target, atomic_val_t value)
{
    4a3c:	00050713          	mv	a4,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
    4a40:	00800793          	li	a5,8
    4a44:	3007b7f3          	csrrc	a5,mstatus,a5
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
    4a48:	00052503          	lw	a0,0(a0)
	key = (mstatus & MSTATUS_IEN);
    4a4c:	0087f793          	andi	a5,a5,8
	*target += value;
    4a50:	00b505b3          	add	a1,a0,a1
    4a54:	00b72023          	sw	a1,0(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    4a58:	3007a7f3          	csrrs	a5,mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
    4a5c:	00008067          	ret

00004a60 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    4a60:	00005637          	lui	a2,0x5
    4a64:	000055b7          	lui	a1,0x5
    4a68:	00005537          	lui	a0,0x5
    4a6c:	08860613          	addi	a2,a2,136 # 5088 <gpio_mmio32_api+0x28>
    4a70:	10058593          	addi	a1,a1,256 # 5100 <levels.0+0x1c>
    4a74:	10850513          	addi	a0,a0,264 # 5108 <levels.0+0x24>
    4a78:	841fd06f          	j	22b8 <printk>
