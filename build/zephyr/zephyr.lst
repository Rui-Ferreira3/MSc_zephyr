
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

00000000 <__start>:

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
   0:	00000297          	auipc	t0,0x0
   4:	03028293          	addi	t0,t0,48 # 30 <__irq_wrapper>
	csrw mtvec, t0
   8:	30529073          	csrw	mtvec,t0
	/*
	* To avoid having to hardcode the main clock frequency,
	* we read the actual value from register 0x8000103c
	* and store to z_clock_hw_cycles_per_sec
	*/
	li	t0, 0x80001000
   c:	800012b7          	lui	t0,0x80001
	lw	t1, 0x3c(t0)
  10:	03c2a303          	lw	t1,60(t0) # 8000103c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000103d>
	la	t0, z_clock_hw_cycles_per_sec
  14:	00005297          	auipc	t0,0x5
  18:	81428293          	addi	t0,t0,-2028 # 4828 <z_clock_hw_cycles_per_sec>
	sw	t1, 0(t0)
  1c:	0062a023          	sw	t1,0(t0)

	/* Jump to __initialize */
	tail __initialize
  20:	18d0106f          	j	19ac <__initialize>

Disassembly of section exceptions:

00000030 <__irq_wrapper>:
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	STORE_CALLER_SAVED()
  30:	fb010113          	addi	sp,sp,-80
  34:	00112023          	sw	ra,0(sp)
  38:	00412223          	sw	tp,4(sp)
  3c:	00512423          	sw	t0,8(sp)
  40:	00612623          	sw	t1,12(sp)
  44:	00712823          	sw	t2,16(sp)
  48:	01c12a23          	sw	t3,20(sp)
  4c:	01d12c23          	sw	t4,24(sp)
  50:	01e12e23          	sw	t5,28(sp)
  54:	03f12023          	sw	t6,32(sp)
  58:	02a12223          	sw	a0,36(sp)
  5c:	02b12423          	sw	a1,40(sp)
  60:	02c12623          	sw	a2,44(sp)
  64:	02d12823          	sw	a3,48(sp)
  68:	02e12a23          	sw	a4,52(sp)
  6c:	02f12c23          	sw	a5,56(sp)
  70:	03012e23          	sw	a6,60(sp)
  74:	05112023          	sw	a7,64(sp)

skip_store_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Save MEPC register */
	csrr t0, mepc
  78:	341022f3          	csrr	t0,mepc
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
  7c:	04512223          	sw	t0,68(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, mstatus
  80:	300022f3          	csrr	t0,mstatus
	RV_OP_STOREREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
  84:	04512423          	sw	t0,72(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
  88:	228000ef          	jal	ra,2b0 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
  8c:	00000313          	li	t1,0
	bnez a0, is_interrupt
  90:	02051e63          	bnez	a0,cc <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
  94:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
  98:	800003b7          	lui	t2,0x80000
  9c:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
  a0:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
  a4:	00b00313          	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	beq t0, t1, is_kernel_syscall
  a8:	00628a63          	beq	t0,t1,bc <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	addi a0, sp, 0
  ac:	00010513          	mv	a0,sp
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
	RV_OP_LOADREG t0, _thread_offset_to_priv_stack_start(t1)
	RV_OP_STOREREG sp, _thread_offset_to_user_sp(t1) /* Update user SP */
	addi sp, t0, CONFIG_PRIVILEGED_STACK_SIZE
#else
	la ra, no_reschedule
  b0:	00000097          	auipc	ra,0x0
  b4:	19408093          	addi	ra,ra,404 # 244 <no_reschedule>
#endif /* CONFIG_USERSPACE */

	tail _Fault
  b8:	0ad0106f          	j	1964 <_Fault>

000000bc <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
  bc:	04412283          	lw	t0,68(sp)
	addi t0, t0, 4
  c0:	00428293          	addi	t0,t0,4
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
  c4:	04512223          	sw	t0,68(sp)
	j z_riscv_user_mode_enter_syscall
#endif /* CONFIG_USERSPACE */
	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
  c8:	0800006f          	j	148 <reschedule>

000000cc <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
  cc:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
  d0:	00004397          	auipc	t2,0x4
  d4:	91838393          	addi	t2,t2,-1768 # 39e8 <_kernel>
	RV_OP_LOADREG sp, _kernel_offset_to_irq_stack(t2)
  d8:	0043a103          	lw	sp,4(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
  dc:	ff010113          	addi	sp,sp,-16
	RV_OP_STOREREG t0, 0x00(sp)
  e0:	00512023          	sw	t0,0(sp)

000000e4 <on_irq_stack>:
	la t2, _kernel
#endif /* !CONFIG_USERSPACE && !CONFIG_PMP_STACK_GUARD */

on_irq_stack:
	/* Increment _kernel.cpus[0].nested variable */
	lw t3, _kernel_offset_to_nested(t2)
  e4:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
  e8:	001e0e13          	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
  ec:	01c3a023          	sw	t3,0(t2)
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
  f0:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
  f4:	800002b7          	lui	t0,0x80000
  f8:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
  fc:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
 100:	1a0000ef          	jal	ra,2a0 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
 104:	00003297          	auipc	t0,0x3
 108:	27c28293          	addi	t0,t0,636 # 3380 <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
 10c:	00351513          	slli	a0,a0,0x3
	add t0, t0, a0
 110:	00a282b3          	add	t0,t0,a0

	/* Load argument in a0 register */
	RV_OP_LOADREG a0, 0x00(t0)
 114:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	RV_OP_LOADREG t1, RV_REGSIZE(t0)
 118:	0042a303          	lw	t1,4(t0)

	/* Call ISR function */
	jalr ra, t1
 11c:	000300e7          	jalr	t1

00000120 <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
 120:	00004317          	auipc	t1,0x4
 124:	8c830313          	addi	t1,t1,-1848 # 39e8 <_kernel>

	/* Decrement _kernel.cpus[0].nested variable */
	lw t2, _kernel_offset_to_nested(t1)
 128:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
 12c:	fff38393          	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
 130:	00732023          	sw	t2,0(t1)

#if !defined(CONFIG_USERSPACE) && !defined(CONFIG_PMP_STACK_GUARD)
	/* Restore thread stack pointer */
	RV_OP_LOADREG t0, 0x00(sp)
 134:	00012283          	lw	t0,0(sp)
	addi sp, t0, 0
 138:	00028113          	mv	sp,t0
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t2, _kernel_offset_to_current(t1)
 13c:	00832383          	lw	t2,8(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t1)
 140:	01832e03          	lw	t3,24(t1)
	beq t3, t2, no_reschedule
 144:	107e0063          	beq	t3,t2,244 <no_reschedule>

00000148 <reschedule>:
	 * Note:
	 *   Sometimes this code is execute back-to-back before the target thread
	 *   has a chance to run. If this happens, the current thread and the
	 *   target thread will be the same.
	 */
	la t0, _kernel
 148:	00004297          	auipc	t0,0x4
 14c:	8a028293          	addi	t0,t0,-1888 # 39e8 <_kernel>
	RV_OP_LOADREG t2, _kernel_offset_to_current(t0)
 150:	0082a383          	lw	t2,8(t0)
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t0)
 154:	0182ae03          	lw	t3,24(t0)
	beq t2, t3, no_reschedule
 158:	0fc38663          	beq	t2,t3,244 <no_reschedule>

#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	call z_thread_mark_switched_out
#endif
	/* Get reference to _kernel */
	la t0, _kernel
 15c:	00004297          	auipc	t0,0x4
 160:	88c28293          	addi	t0,t0,-1908 # 39e8 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
 164:	0082a303          	lw	t1,8(t0)

	/*
	 * Save callee-saved registers of current kernel thread
	 * prior to handle context-switching
	 */
	STORE_CALLEE_SAVED(t1)
 168:	02832a23          	sw	s0,52(t1)
 16c:	02932c23          	sw	s1,56(t1)
 170:	03232e23          	sw	s2,60(t1)
 174:	05332023          	sw	s3,64(t1)
 178:	05432223          	sw	s4,68(t1)
 17c:	05532423          	sw	s5,72(t1)
 180:	05632623          	sw	s6,76(t1)
 184:	05732823          	sw	s7,80(t1)
 188:	05832a23          	sw	s8,84(t1)
 18c:	05932c23          	sw	s9,88(t1)
 190:	05a32e23          	sw	s10,92(t1)
 194:	07b32023          	sw	s11,96(t1)

00000198 <skip_callee_saved_reg>:

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	RV_OP_STOREREG sp, _thread_offset_to_sp(t1)
 198:	02232823          	sw	sp,48(t1)
	la t2, _k_neg_eagain
 19c:	00003397          	auipc	t2,0x3
 1a0:	40438393          	addi	t2,t2,1028 # 35a0 <_k_neg_eagain>
	lw t3, 0x00(t2)
 1a4:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
 1a8:	07c32c23          	sw	t3,120(t1)

	/* Get next thread to schedule. */
	RV_OP_LOADREG t1, _kernel_offset_to_ready_q_cache(t0)
 1ac:	0182a303          	lw	t1,24(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	RV_OP_STOREREG t1, _kernel_offset_to_current(t0)
 1b0:	0062a423          	sw	t1,8(t0)

	/* Switch to new thread stack */
	RV_OP_LOADREG sp, _thread_offset_to_sp(t1)
 1b4:	03032103          	lw	sp,48(t1)

	/* Restore callee-saved registers of new thread */
	LOAD_CALLEE_SAVED(t1)
 1b8:	03432403          	lw	s0,52(t1)
 1bc:	03832483          	lw	s1,56(t1)
 1c0:	03c32903          	lw	s2,60(t1)
 1c4:	04032983          	lw	s3,64(t1)
 1c8:	04432a03          	lw	s4,68(t1)
 1cc:	04832a83          	lw	s5,72(t1)
 1d0:	04c32b03          	lw	s6,76(t1)
 1d4:	05032b83          	lw	s7,80(t1)
 1d8:	05432c03          	lw	s8,84(t1)
 1dc:	05832c83          	lw	s9,88(t1)
 1e0:	05c32d03          	lw	s10,92(t1)
 1e4:	06032d83          	lw	s11,96(t1)
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
 1e8:	04412283          	lw	t0,68(sp)
	csrw mepc, t0
 1ec:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
 1f0:	04812283          	lw	t0,72(sp)
	csrw mstatus, t0
 1f4:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved_resched:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
 1f8:	00012083          	lw	ra,0(sp)
 1fc:	00412203          	lw	tp,4(sp)
 200:	00812283          	lw	t0,8(sp)
 204:	00c12303          	lw	t1,12(sp)
 208:	01012383          	lw	t2,16(sp)
 20c:	01412e03          	lw	t3,20(sp)
 210:	01812e83          	lw	t4,24(sp)
 214:	01c12f03          	lw	t5,28(sp)
 218:	02012f83          	lw	t6,32(sp)
 21c:	02412503          	lw	a0,36(sp)
 220:	02812583          	lw	a1,40(sp)
 224:	02c12603          	lw	a2,44(sp)
 228:	03012683          	lw	a3,48(sp)
 22c:	03412703          	lw	a4,52(sp)
 230:	03812783          	lw	a5,56(sp)
 234:	03c12803          	lw	a6,60(sp)
 238:	04012883          	lw	a7,64(sp)
 23c:	05010113          	addi	sp,sp,80

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
 240:	30200073          	mret

00000244 <no_reschedule>:
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
 244:	04412283          	lw	t0,68(sp)
	csrw mepc, t0
 248:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
 24c:	04812283          	lw	t0,72(sp)
	csrw mstatus, t0
 250:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
 254:	00012083          	lw	ra,0(sp)
 258:	00412203          	lw	tp,4(sp)
 25c:	00812283          	lw	t0,8(sp)
 260:	00c12303          	lw	t1,12(sp)
 264:	01012383          	lw	t2,16(sp)
 268:	01412e03          	lw	t3,20(sp)
 26c:	01812e83          	lw	t4,24(sp)
 270:	01c12f03          	lw	t5,28(sp)
 274:	02012f83          	lw	t6,32(sp)
 278:	02412503          	lw	a0,36(sp)
 27c:	02812583          	lw	a1,40(sp)
 280:	02c12603          	lw	a2,44(sp)
 284:	03012683          	lw	a3,48(sp)
 288:	03412703          	lw	a4,52(sp)
 28c:	03812783          	lw	a5,56(sp)
 290:	03c12803          	lw	a6,60(sp)
 294:	04012883          	lw	a7,64(sp)
 298:	05010113          	addi	sp,sp,80

#ifdef CONFIG_PMP_STACK_GUARD
	csrrw sp, mscratch, sp
#endif /* CONFIG_PMP_STACK_GUARD */
	/* Call SOC_ERET to exit ISR */
	SOC_ERET
 29c:	30200073          	mret

000002a0 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
 2a0:	00100313          	li	t1,1
	sll t0, t1, a0
 2a4:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
 2a8:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
 2ac:	00008067          	ret

000002b0 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
 2b0:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
 2b4:	80000337          	lui	t1,0x80000
	and t0, t0, t1
 2b8:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
 2bc:	00000513          	li	a0,0
	beqz t0, not_interrupt
 2c0:	00028463          	beqz	t0,2c8 <not_interrupt>
	addi a0, a0, 1
 2c4:	00150513          	addi	a0,a0,1

000002c8 <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
 2c8:	00008067          	ret

000002cc <arch_swap>:
 * key is stored in a0 register
 */
SECTION_FUNC(exception.other, arch_swap)

	/* Make a system call to perform context switch */
	ecall
 2cc:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * arch_swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called arch_thread_return_value_set(..).
	 */
	la t0, _kernel
 2d0:	00003297          	auipc	t0,0x3
 2d4:	71828293          	addi	t0,t0,1816 # 39e8 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
 2d8:	0082a303          	lw	t1,8(t0)

	/* Load return value of arch_swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
 2dc:	07832383          	lw	t2,120(t1) # 80000078 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000079>

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, MSTATUS_IEN
 2e0:	00857513          	andi	a0,a0,8
	csrrs t0, mstatus, a0
 2e4:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
 2e8:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
 2ec:	00008067          	ret

Disassembly of section text:

000002f0 <__udivdi3>:
     2f0:	00050893          	mv	a7,a0
     2f4:	00058793          	mv	a5,a1
     2f8:	00060813          	mv	a6,a2
     2fc:	00068513          	mv	a0,a3
     300:	00088313          	mv	t1,a7
     304:	28069463          	bnez	a3,58c <CONFIG_MAIN_STACK_SIZE+0x18c>
     308:	000036b7          	lui	a3,0x3
     30c:	5a468693          	addi	a3,a3,1444 # 35a4 <__clz_tab>
     310:	0ec5f663          	bgeu	a1,a2,3fc <__udivdi3+0x10c>
     314:	00010737          	lui	a4,0x10
     318:	0ce67863          	bgeu	a2,a4,3e8 <__udivdi3+0xf8>
     31c:	0ff00713          	li	a4,255
     320:	00c73733          	sltu	a4,a4,a2
     324:	00371713          	slli	a4,a4,0x3
     328:	00e65533          	srl	a0,a2,a4
     32c:	00a686b3          	add	a3,a3,a0
     330:	0006c683          	lbu	a3,0(a3)
     334:	02000513          	li	a0,32
     338:	00e68733          	add	a4,a3,a4
     33c:	40e506b3          	sub	a3,a0,a4
     340:	00e50c63          	beq	a0,a4,358 <__udivdi3+0x68>
     344:	00d795b3          	sll	a1,a5,a3
     348:	00e8d733          	srl	a4,a7,a4
     34c:	00d61833          	sll	a6,a2,a3
     350:	00b765b3          	or	a1,a4,a1
     354:	00d89333          	sll	t1,a7,a3
     358:	01085893          	srli	a7,a6,0x10
     35c:	0315d6b3          	divu	a3,a1,a7
     360:	01081613          	slli	a2,a6,0x10
     364:	01065613          	srli	a2,a2,0x10
     368:	01035793          	srli	a5,t1,0x10
     36c:	0315f733          	remu	a4,a1,a7
     370:	00068513          	mv	a0,a3
     374:	02d605b3          	mul	a1,a2,a3
     378:	01071713          	slli	a4,a4,0x10
     37c:	00f767b3          	or	a5,a4,a5
     380:	00b7fe63          	bgeu	a5,a1,39c <__udivdi3+0xac>
     384:	010787b3          	add	a5,a5,a6
     388:	fff68513          	addi	a0,a3,-1
     38c:	0107e863          	bltu	a5,a6,39c <__udivdi3+0xac>
     390:	00b7f663          	bgeu	a5,a1,39c <__udivdi3+0xac>
     394:	ffe68513          	addi	a0,a3,-2
     398:	010787b3          	add	a5,a5,a6
     39c:	40b787b3          	sub	a5,a5,a1
     3a0:	0317f733          	remu	a4,a5,a7
     3a4:	01031313          	slli	t1,t1,0x10
     3a8:	01035313          	srli	t1,t1,0x10
     3ac:	0317d7b3          	divu	a5,a5,a7
     3b0:	01071713          	slli	a4,a4,0x10
     3b4:	00676333          	or	t1,a4,t1
     3b8:	02f606b3          	mul	a3,a2,a5
     3bc:	00078613          	mv	a2,a5
     3c0:	00d37c63          	bgeu	t1,a3,3d8 <__udivdi3+0xe8>
     3c4:	00680333          	add	t1,a6,t1
     3c8:	fff78613          	addi	a2,a5,-1
     3cc:	01036663          	bltu	t1,a6,3d8 <__udivdi3+0xe8>
     3d0:	00d37463          	bgeu	t1,a3,3d8 <__udivdi3+0xe8>
     3d4:	ffe78613          	addi	a2,a5,-2
     3d8:	01051513          	slli	a0,a0,0x10
     3dc:	00c56533          	or	a0,a0,a2
     3e0:	00000593          	li	a1,0
     3e4:	0e40006f          	j	4c8 <CONFIG_MAIN_STACK_SIZE+0xc8>
     3e8:	01000537          	lui	a0,0x1000
     3ec:	01000713          	li	a4,16
     3f0:	f2a66ce3          	bltu	a2,a0,328 <__udivdi3+0x38>
     3f4:	01800713          	li	a4,24
     3f8:	f31ff06f          	j	328 <__udivdi3+0x38>
     3fc:	00061663          	bnez	a2,408 <CONFIG_MAIN_STACK_SIZE+0x8>
     400:	00100713          	li	a4,1
     404:	02c75833          	divu	a6,a4,a2
     408:	00010737          	lui	a4,0x10
     40c:	0ce87063          	bgeu	a6,a4,4cc <CONFIG_MAIN_STACK_SIZE+0xcc>
     410:	0ff00713          	li	a4,255
     414:	01077463          	bgeu	a4,a6,41c <CONFIG_MAIN_STACK_SIZE+0x1c>
     418:	00800513          	li	a0,8
     41c:	00a85733          	srl	a4,a6,a0
     420:	00e686b3          	add	a3,a3,a4
     424:	0006c703          	lbu	a4,0(a3)
     428:	02000613          	li	a2,32
     42c:	00a70733          	add	a4,a4,a0
     430:	40e606b3          	sub	a3,a2,a4
     434:	0ae61663          	bne	a2,a4,4e0 <CONFIG_MAIN_STACK_SIZE+0xe0>
     438:	410787b3          	sub	a5,a5,a6
     43c:	00100593          	li	a1,1
     440:	01085893          	srli	a7,a6,0x10
     444:	01081613          	slli	a2,a6,0x10
     448:	01065613          	srli	a2,a2,0x10
     44c:	01035713          	srli	a4,t1,0x10
     450:	0317f6b3          	remu	a3,a5,a7
     454:	0317d7b3          	divu	a5,a5,a7
     458:	01069693          	slli	a3,a3,0x10
     45c:	00e6e733          	or	a4,a3,a4
     460:	02f60e33          	mul	t3,a2,a5
     464:	00078513          	mv	a0,a5
     468:	01c77e63          	bgeu	a4,t3,484 <CONFIG_MAIN_STACK_SIZE+0x84>
     46c:	01070733          	add	a4,a4,a6
     470:	fff78513          	addi	a0,a5,-1
     474:	01076863          	bltu	a4,a6,484 <CONFIG_MAIN_STACK_SIZE+0x84>
     478:	01c77663          	bgeu	a4,t3,484 <CONFIG_MAIN_STACK_SIZE+0x84>
     47c:	ffe78513          	addi	a0,a5,-2
     480:	01070733          	add	a4,a4,a6
     484:	41c70733          	sub	a4,a4,t3
     488:	031777b3          	remu	a5,a4,a7
     48c:	01031313          	slli	t1,t1,0x10
     490:	01035313          	srli	t1,t1,0x10
     494:	03175733          	divu	a4,a4,a7
     498:	01079793          	slli	a5,a5,0x10
     49c:	0067e333          	or	t1,a5,t1
     4a0:	02e606b3          	mul	a3,a2,a4
     4a4:	00070613          	mv	a2,a4
     4a8:	00d37c63          	bgeu	t1,a3,4c0 <CONFIG_MAIN_STACK_SIZE+0xc0>
     4ac:	00680333          	add	t1,a6,t1
     4b0:	fff70613          	addi	a2,a4,-1 # ffff <__data_region_end+0xb7c3>
     4b4:	01036663          	bltu	t1,a6,4c0 <CONFIG_MAIN_STACK_SIZE+0xc0>
     4b8:	00d37463          	bgeu	t1,a3,4c0 <CONFIG_MAIN_STACK_SIZE+0xc0>
     4bc:	ffe70613          	addi	a2,a4,-2
     4c0:	01051513          	slli	a0,a0,0x10
     4c4:	00c56533          	or	a0,a0,a2
     4c8:	00008067          	ret
     4cc:	01000737          	lui	a4,0x1000
     4d0:	01000513          	li	a0,16
     4d4:	f4e864e3          	bltu	a6,a4,41c <CONFIG_MAIN_STACK_SIZE+0x1c>
     4d8:	01800513          	li	a0,24
     4dc:	f41ff06f          	j	41c <CONFIG_MAIN_STACK_SIZE+0x1c>
     4e0:	00d81833          	sll	a6,a6,a3
     4e4:	00e7d533          	srl	a0,a5,a4
     4e8:	00d89333          	sll	t1,a7,a3
     4ec:	00d797b3          	sll	a5,a5,a3
     4f0:	00e8d733          	srl	a4,a7,a4
     4f4:	01085893          	srli	a7,a6,0x10
     4f8:	00f76633          	or	a2,a4,a5
     4fc:	03157733          	remu	a4,a0,a7
     500:	01081793          	slli	a5,a6,0x10
     504:	0107d793          	srli	a5,a5,0x10
     508:	01065593          	srli	a1,a2,0x10
     50c:	03155533          	divu	a0,a0,a7
     510:	01071713          	slli	a4,a4,0x10
     514:	00b76733          	or	a4,a4,a1
     518:	02a786b3          	mul	a3,a5,a0
     51c:	00050593          	mv	a1,a0
     520:	00d77e63          	bgeu	a4,a3,53c <CONFIG_MAIN_STACK_SIZE+0x13c>
     524:	01070733          	add	a4,a4,a6
     528:	fff50593          	addi	a1,a0,-1 # ffffff <__data_region_end+0xffb7c3>
     52c:	01076863          	bltu	a4,a6,53c <CONFIG_MAIN_STACK_SIZE+0x13c>
     530:	00d77663          	bgeu	a4,a3,53c <CONFIG_MAIN_STACK_SIZE+0x13c>
     534:	ffe50593          	addi	a1,a0,-2
     538:	01070733          	add	a4,a4,a6
     53c:	40d706b3          	sub	a3,a4,a3
     540:	0316f733          	remu	a4,a3,a7
     544:	01061613          	slli	a2,a2,0x10
     548:	01065613          	srli	a2,a2,0x10
     54c:	0316d6b3          	divu	a3,a3,a7
     550:	01071713          	slli	a4,a4,0x10
     554:	02d78533          	mul	a0,a5,a3
     558:	00c767b3          	or	a5,a4,a2
     55c:	00068713          	mv	a4,a3
     560:	00a7fe63          	bgeu	a5,a0,57c <CONFIG_MAIN_STACK_SIZE+0x17c>
     564:	010787b3          	add	a5,a5,a6
     568:	fff68713          	addi	a4,a3,-1
     56c:	0107e863          	bltu	a5,a6,57c <CONFIG_MAIN_STACK_SIZE+0x17c>
     570:	00a7f663          	bgeu	a5,a0,57c <CONFIG_MAIN_STACK_SIZE+0x17c>
     574:	ffe68713          	addi	a4,a3,-2
     578:	010787b3          	add	a5,a5,a6
     57c:	01059593          	slli	a1,a1,0x10
     580:	40a787b3          	sub	a5,a5,a0
     584:	00e5e5b3          	or	a1,a1,a4
     588:	eb9ff06f          	j	440 <CONFIG_MAIN_STACK_SIZE+0x40>
     58c:	18d5e663          	bltu	a1,a3,718 <CONFIG_MAIN_STACK_SIZE+0x318>
     590:	00010737          	lui	a4,0x10
     594:	04e6f463          	bgeu	a3,a4,5dc <CONFIG_MAIN_STACK_SIZE+0x1dc>
     598:	0ff00713          	li	a4,255
     59c:	00d735b3          	sltu	a1,a4,a3
     5a0:	00359593          	slli	a1,a1,0x3
     5a4:	00003737          	lui	a4,0x3
     5a8:	00b6d533          	srl	a0,a3,a1
     5ac:	5a470713          	addi	a4,a4,1444 # 35a4 <__clz_tab>
     5b0:	00a70733          	add	a4,a4,a0
     5b4:	00074703          	lbu	a4,0(a4)
     5b8:	02000513          	li	a0,32
     5bc:	00b70733          	add	a4,a4,a1
     5c0:	40e505b3          	sub	a1,a0,a4
     5c4:	02e51663          	bne	a0,a4,5f0 <CONFIG_MAIN_STACK_SIZE+0x1f0>
     5c8:	00100513          	li	a0,1
     5cc:	eef6eee3          	bltu	a3,a5,4c8 <CONFIG_MAIN_STACK_SIZE+0xc8>
     5d0:	00c8b533          	sltu	a0,a7,a2
     5d4:	00154513          	xori	a0,a0,1
     5d8:	ef1ff06f          	j	4c8 <CONFIG_MAIN_STACK_SIZE+0xc8>
     5dc:	01000737          	lui	a4,0x1000
     5e0:	01000593          	li	a1,16
     5e4:	fce6e0e3          	bltu	a3,a4,5a4 <CONFIG_MAIN_STACK_SIZE+0x1a4>
     5e8:	01800593          	li	a1,24
     5ec:	fb9ff06f          	j	5a4 <CONFIG_MAIN_STACK_SIZE+0x1a4>
     5f0:	00e65833          	srl	a6,a2,a4
     5f4:	00b696b3          	sll	a3,a3,a1
     5f8:	00d86833          	or	a6,a6,a3
     5fc:	00e7de33          	srl	t3,a5,a4
     600:	01085e93          	srli	t4,a6,0x10
     604:	03de76b3          	remu	a3,t3,t4
     608:	00b797b3          	sll	a5,a5,a1
     60c:	00e8d733          	srl	a4,a7,a4
     610:	00b61333          	sll	t1,a2,a1
     614:	00f76633          	or	a2,a4,a5
     618:	01081793          	slli	a5,a6,0x10
     61c:	0107d793          	srli	a5,a5,0x10
     620:	01065713          	srli	a4,a2,0x10
     624:	03de5e33          	divu	t3,t3,t4
     628:	01069693          	slli	a3,a3,0x10
     62c:	00e6e733          	or	a4,a3,a4
     630:	03c78f33          	mul	t5,a5,t3
     634:	000e0513          	mv	a0,t3
     638:	01e77e63          	bgeu	a4,t5,654 <CONFIG_MAIN_STACK_SIZE+0x254>
     63c:	01070733          	add	a4,a4,a6
     640:	fffe0513          	addi	a0,t3,-1
     644:	01076863          	bltu	a4,a6,654 <CONFIG_MAIN_STACK_SIZE+0x254>
     648:	01e77663          	bgeu	a4,t5,654 <CONFIG_MAIN_STACK_SIZE+0x254>
     64c:	ffee0513          	addi	a0,t3,-2
     650:	01070733          	add	a4,a4,a6
     654:	41e70733          	sub	a4,a4,t5
     658:	03d776b3          	remu	a3,a4,t4
     65c:	03d75733          	divu	a4,a4,t4
     660:	01069693          	slli	a3,a3,0x10
     664:	02e78e33          	mul	t3,a5,a4
     668:	01061793          	slli	a5,a2,0x10
     66c:	0107d793          	srli	a5,a5,0x10
     670:	00f6e7b3          	or	a5,a3,a5
     674:	00070613          	mv	a2,a4
     678:	01c7fe63          	bgeu	a5,t3,694 <CONFIG_MAIN_STACK_SIZE+0x294>
     67c:	010787b3          	add	a5,a5,a6
     680:	fff70613          	addi	a2,a4,-1 # ffffff <__data_region_end+0xffb7c3>
     684:	0107e863          	bltu	a5,a6,694 <CONFIG_MAIN_STACK_SIZE+0x294>
     688:	01c7f663          	bgeu	a5,t3,694 <CONFIG_MAIN_STACK_SIZE+0x294>
     68c:	ffe70613          	addi	a2,a4,-2
     690:	010787b3          	add	a5,a5,a6
     694:	01051513          	slli	a0,a0,0x10
     698:	00010eb7          	lui	t4,0x10
     69c:	00c56533          	or	a0,a0,a2
     6a0:	fffe8693          	addi	a3,t4,-1 # ffff <__data_region_end+0xb7c3>
     6a4:	00d57833          	and	a6,a0,a3
     6a8:	01055613          	srli	a2,a0,0x10
     6ac:	00d376b3          	and	a3,t1,a3
     6b0:	01035313          	srli	t1,t1,0x10
     6b4:	41c787b3          	sub	a5,a5,t3
     6b8:	02d80e33          	mul	t3,a6,a3
     6bc:	02d606b3          	mul	a3,a2,a3
     6c0:	010e5713          	srli	a4,t3,0x10
     6c4:	02680833          	mul	a6,a6,t1
     6c8:	00d80833          	add	a6,a6,a3
     6cc:	01070733          	add	a4,a4,a6
     6d0:	02660633          	mul	a2,a2,t1
     6d4:	00d77463          	bgeu	a4,a3,6dc <CONFIG_MAIN_STACK_SIZE+0x2dc>
     6d8:	01d60633          	add	a2,a2,t4
     6dc:	01075693          	srli	a3,a4,0x10
     6e0:	00c68633          	add	a2,a3,a2
     6e4:	02c7e663          	bltu	a5,a2,710 <CONFIG_MAIN_STACK_SIZE+0x310>
     6e8:	cec79ce3          	bne	a5,a2,3e0 <__udivdi3+0xf0>
     6ec:	000107b7          	lui	a5,0x10
     6f0:	fff78793          	addi	a5,a5,-1 # ffff <__data_region_end+0xb7c3>
     6f4:	00f77733          	and	a4,a4,a5
     6f8:	01071713          	slli	a4,a4,0x10
     6fc:	00fe7e33          	and	t3,t3,a5
     700:	00b898b3          	sll	a7,a7,a1
     704:	01c70733          	add	a4,a4,t3
     708:	00000593          	li	a1,0
     70c:	dae8fee3          	bgeu	a7,a4,4c8 <CONFIG_MAIN_STACK_SIZE+0xc8>
     710:	fff50513          	addi	a0,a0,-1
     714:	ccdff06f          	j	3e0 <__udivdi3+0xf0>
     718:	00000593          	li	a1,0
     71c:	00000513          	li	a0,0
     720:	da9ff06f          	j	4c8 <CONFIG_MAIN_STACK_SIZE+0xc8>

00000724 <__umoddi3>:
     724:	00050e93          	mv	t4,a0
     728:	00058313          	mv	t1,a1
     72c:	00060813          	mv	a6,a2
     730:	00068793          	mv	a5,a3
     734:	22069a63          	bnez	a3,968 <CONFIG_ISR_STACK_SIZE+0x168>
     738:	00003737          	lui	a4,0x3
     73c:	5a470713          	addi	a4,a4,1444 # 35a4 <__clz_tab>
     740:	0cc5fc63          	bgeu	a1,a2,818 <CONFIG_ISR_STACK_SIZE+0x18>
     744:	000106b7          	lui	a3,0x10
     748:	0ad67e63          	bgeu	a2,a3,804 <CONFIG_ISR_STACK_SIZE+0x4>
     74c:	0ff00693          	li	a3,255
     750:	00c6f463          	bgeu	a3,a2,758 <__umoddi3+0x34>
     754:	00800793          	li	a5,8
     758:	00f656b3          	srl	a3,a2,a5
     75c:	00d70733          	add	a4,a4,a3
     760:	00074703          	lbu	a4,0(a4)
     764:	00f707b3          	add	a5,a4,a5
     768:	02000713          	li	a4,32
     76c:	40f708b3          	sub	a7,a4,a5
     770:	00f70c63          	beq	a4,a5,788 <__umoddi3+0x64>
     774:	011315b3          	sll	a1,t1,a7
     778:	00fed7b3          	srl	a5,t4,a5
     77c:	01161833          	sll	a6,a2,a7
     780:	00b7e5b3          	or	a1,a5,a1
     784:	011e9533          	sll	a0,t4,a7
     788:	01085693          	srli	a3,a6,0x10
     78c:	02d5f7b3          	remu	a5,a1,a3
     790:	01081613          	slli	a2,a6,0x10
     794:	01065613          	srli	a2,a2,0x10
     798:	01055713          	srli	a4,a0,0x10
     79c:	02d5d5b3          	divu	a1,a1,a3
     7a0:	01079793          	slli	a5,a5,0x10
     7a4:	00e7e733          	or	a4,a5,a4
     7a8:	02b605b3          	mul	a1,a2,a1
     7ac:	00b77a63          	bgeu	a4,a1,7c0 <__umoddi3+0x9c>
     7b0:	01070733          	add	a4,a4,a6
     7b4:	01076663          	bltu	a4,a6,7c0 <__umoddi3+0x9c>
     7b8:	00b77463          	bgeu	a4,a1,7c0 <__umoddi3+0x9c>
     7bc:	01070733          	add	a4,a4,a6
     7c0:	40b70733          	sub	a4,a4,a1
     7c4:	02d777b3          	remu	a5,a4,a3
     7c8:	01051513          	slli	a0,a0,0x10
     7cc:	01055513          	srli	a0,a0,0x10
     7d0:	02d75733          	divu	a4,a4,a3
     7d4:	01079793          	slli	a5,a5,0x10
     7d8:	00a7e533          	or	a0,a5,a0
     7dc:	02e60733          	mul	a4,a2,a4
     7e0:	00e57a63          	bgeu	a0,a4,7f4 <__umoddi3+0xd0>
     7e4:	01050533          	add	a0,a0,a6
     7e8:	01056663          	bltu	a0,a6,7f4 <__umoddi3+0xd0>
     7ec:	00e57463          	bgeu	a0,a4,7f4 <__umoddi3+0xd0>
     7f0:	01050533          	add	a0,a0,a6
     7f4:	40e50533          	sub	a0,a0,a4
     7f8:	01155533          	srl	a0,a0,a7
     7fc:	00000593          	li	a1,0
     800:	00008067          	ret
     804:	010006b7          	lui	a3,0x1000
     808:	01000793          	li	a5,16
     80c:	f4d666e3          	bltu	a2,a3,758 <__umoddi3+0x34>
     810:	01800793          	li	a5,24
     814:	f45ff06f          	j	758 <__umoddi3+0x34>
     818:	00061663          	bnez	a2,824 <CONFIG_ISR_STACK_SIZE+0x24>
     81c:	00100693          	li	a3,1
     820:	02c6d833          	divu	a6,a3,a2
     824:	000106b7          	lui	a3,0x10
     828:	12d87663          	bgeu	a6,a3,954 <CONFIG_ISR_STACK_SIZE+0x154>
     82c:	0ff00693          	li	a3,255
     830:	0106f463          	bgeu	a3,a6,838 <CONFIG_ISR_STACK_SIZE+0x38>
     834:	00800793          	li	a5,8
     838:	00f856b3          	srl	a3,a6,a5
     83c:	00d70733          	add	a4,a4,a3
     840:	00074603          	lbu	a2,0(a4)
     844:	410305b3          	sub	a1,t1,a6
     848:	00f60633          	add	a2,a2,a5
     84c:	02000793          	li	a5,32
     850:	40c788b3          	sub	a7,a5,a2
     854:	08c78663          	beq	a5,a2,8e0 <CONFIG_ISR_STACK_SIZE+0xe0>
     858:	01181833          	sll	a6,a6,a7
     85c:	00c357b3          	srl	a5,t1,a2
     860:	011315b3          	sll	a1,t1,a7
     864:	01085313          	srli	t1,a6,0x10
     868:	00ced633          	srl	a2,t4,a2
     86c:	00b66633          	or	a2,a2,a1
     870:	01081593          	slli	a1,a6,0x10
     874:	0105d593          	srli	a1,a1,0x10
     878:	011e9533          	sll	a0,t4,a7
     87c:	0267d6b3          	divu	a3,a5,t1
     880:	0267f733          	remu	a4,a5,t1
     884:	01065793          	srli	a5,a2,0x10
     888:	02d586b3          	mul	a3,a1,a3
     88c:	01071713          	slli	a4,a4,0x10
     890:	00f76733          	or	a4,a4,a5
     894:	00d77a63          	bgeu	a4,a3,8a8 <CONFIG_ISR_STACK_SIZE+0xa8>
     898:	01070733          	add	a4,a4,a6
     89c:	01076663          	bltu	a4,a6,8a8 <CONFIG_ISR_STACK_SIZE+0xa8>
     8a0:	00d77463          	bgeu	a4,a3,8a8 <CONFIG_ISR_STACK_SIZE+0xa8>
     8a4:	01070733          	add	a4,a4,a6
     8a8:	40d706b3          	sub	a3,a4,a3
     8ac:	0266f733          	remu	a4,a3,t1
     8b0:	01061613          	slli	a2,a2,0x10
     8b4:	01065613          	srli	a2,a2,0x10
     8b8:	0266d6b3          	divu	a3,a3,t1
     8bc:	01071713          	slli	a4,a4,0x10
     8c0:	02d586b3          	mul	a3,a1,a3
     8c4:	00c765b3          	or	a1,a4,a2
     8c8:	00d5fa63          	bgeu	a1,a3,8dc <CONFIG_ISR_STACK_SIZE+0xdc>
     8cc:	010585b3          	add	a1,a1,a6
     8d0:	0105e663          	bltu	a1,a6,8dc <CONFIG_ISR_STACK_SIZE+0xdc>
     8d4:	00d5f463          	bgeu	a1,a3,8dc <CONFIG_ISR_STACK_SIZE+0xdc>
     8d8:	010585b3          	add	a1,a1,a6
     8dc:	40d585b3          	sub	a1,a1,a3
     8e0:	01085693          	srli	a3,a6,0x10
     8e4:	02d5f733          	remu	a4,a1,a3
     8e8:	01081793          	slli	a5,a6,0x10
     8ec:	0107d793          	srli	a5,a5,0x10
     8f0:	01055613          	srli	a2,a0,0x10
     8f4:	02d5d5b3          	divu	a1,a1,a3
     8f8:	01071713          	slli	a4,a4,0x10
     8fc:	00c76733          	or	a4,a4,a2
     900:	02b785b3          	mul	a1,a5,a1
     904:	00b77a63          	bgeu	a4,a1,918 <CONFIG_ISR_STACK_SIZE+0x118>
     908:	01070733          	add	a4,a4,a6
     90c:	01076663          	bltu	a4,a6,918 <CONFIG_ISR_STACK_SIZE+0x118>
     910:	00b77463          	bgeu	a4,a1,918 <CONFIG_ISR_STACK_SIZE+0x118>
     914:	01070733          	add	a4,a4,a6
     918:	40b705b3          	sub	a1,a4,a1
     91c:	02d5f733          	remu	a4,a1,a3
     920:	01051513          	slli	a0,a0,0x10
     924:	01055513          	srli	a0,a0,0x10
     928:	02d5d5b3          	divu	a1,a1,a3
     92c:	02b785b3          	mul	a1,a5,a1
     930:	01071793          	slli	a5,a4,0x10
     934:	00a7e533          	or	a0,a5,a0
     938:	00b57a63          	bgeu	a0,a1,94c <CONFIG_ISR_STACK_SIZE+0x14c>
     93c:	01050533          	add	a0,a0,a6
     940:	01056663          	bltu	a0,a6,94c <CONFIG_ISR_STACK_SIZE+0x14c>
     944:	00b57463          	bgeu	a0,a1,94c <CONFIG_ISR_STACK_SIZE+0x14c>
     948:	01050533          	add	a0,a0,a6
     94c:	40b50533          	sub	a0,a0,a1
     950:	ea9ff06f          	j	7f8 <__umoddi3+0xd4>
     954:	010006b7          	lui	a3,0x1000
     958:	01000793          	li	a5,16
     95c:	ecd86ee3          	bltu	a6,a3,838 <CONFIG_ISR_STACK_SIZE+0x38>
     960:	01800793          	li	a5,24
     964:	ed5ff06f          	j	838 <CONFIG_ISR_STACK_SIZE+0x38>
     968:	e8d5ece3          	bltu	a1,a3,800 <CONFIG_ISR_STACK_SIZE>
     96c:	000107b7          	lui	a5,0x10
     970:	04f6f863          	bgeu	a3,a5,9c0 <CONFIG_ISR_STACK_SIZE+0x1c0>
     974:	0ff00893          	li	a7,255
     978:	00d8b7b3          	sltu	a5,a7,a3
     97c:	00379793          	slli	a5,a5,0x3
     980:	00003737          	lui	a4,0x3
     984:	00f6d833          	srl	a6,a3,a5
     988:	5a470713          	addi	a4,a4,1444 # 35a4 <__clz_tab>
     98c:	01070733          	add	a4,a4,a6
     990:	00074883          	lbu	a7,0(a4)
     994:	00f888b3          	add	a7,a7,a5
     998:	02000793          	li	a5,32
     99c:	41178833          	sub	a6,a5,a7
     9a0:	03179a63          	bne	a5,a7,9d4 <CONFIG_ISR_STACK_SIZE+0x1d4>
     9a4:	0066e463          	bltu	a3,t1,9ac <CONFIG_ISR_STACK_SIZE+0x1ac>
     9a8:	e4ceece3          	bltu	t4,a2,800 <CONFIG_ISR_STACK_SIZE>
     9ac:	40ce8533          	sub	a0,t4,a2
     9b0:	40d305b3          	sub	a1,t1,a3
     9b4:	00aebeb3          	sltu	t4,t4,a0
     9b8:	41d585b3          	sub	a1,a1,t4
     9bc:	e45ff06f          	j	800 <CONFIG_ISR_STACK_SIZE>
     9c0:	01000737          	lui	a4,0x1000
     9c4:	01000793          	li	a5,16
     9c8:	fae6ece3          	bltu	a3,a4,980 <CONFIG_ISR_STACK_SIZE+0x180>
     9cc:	01800793          	li	a5,24
     9d0:	fb1ff06f          	j	980 <CONFIG_ISR_STACK_SIZE+0x180>
     9d4:	011657b3          	srl	a5,a2,a7
     9d8:	010696b3          	sll	a3,a3,a6
     9dc:	00d7ee33          	or	t3,a5,a3
     9e0:	01135f33          	srl	t5,t1,a7
     9e4:	011ed7b3          	srl	a5,t4,a7
     9e8:	010e9533          	sll	a0,t4,a6
     9ec:	010e5e93          	srli	t4,t3,0x10
     9f0:	010315b3          	sll	a1,t1,a6
     9f4:	03df5333          	divu	t1,t5,t4
     9f8:	00b7e7b3          	or	a5,a5,a1
     9fc:	010e1593          	slli	a1,t3,0x10
     a00:	0105d593          	srli	a1,a1,0x10
     a04:	0107d713          	srli	a4,a5,0x10
     a08:	01061633          	sll	a2,a2,a6
     a0c:	03df76b3          	remu	a3,t5,t4
     a10:	02658f33          	mul	t5,a1,t1
     a14:	01069693          	slli	a3,a3,0x10
     a18:	00e6e733          	or	a4,a3,a4
     a1c:	00030693          	mv	a3,t1
     a20:	01e77e63          	bgeu	a4,t5,a3c <CONFIG_ISR_STACK_SIZE+0x23c>
     a24:	01c70733          	add	a4,a4,t3
     a28:	fff30693          	addi	a3,t1,-1
     a2c:	01c76863          	bltu	a4,t3,a3c <CONFIG_ISR_STACK_SIZE+0x23c>
     a30:	01e77663          	bgeu	a4,t5,a3c <CONFIG_ISR_STACK_SIZE+0x23c>
     a34:	ffe30693          	addi	a3,t1,-2
     a38:	01c70733          	add	a4,a4,t3
     a3c:	41e70733          	sub	a4,a4,t5
     a40:	03d77333          	remu	t1,a4,t4
     a44:	01079793          	slli	a5,a5,0x10
     a48:	0107d793          	srli	a5,a5,0x10
     a4c:	03d75733          	divu	a4,a4,t4
     a50:	01031313          	slli	t1,t1,0x10
     a54:	00f36333          	or	t1,t1,a5
     a58:	02e585b3          	mul	a1,a1,a4
     a5c:	00070793          	mv	a5,a4
     a60:	00b37e63          	bgeu	t1,a1,a7c <CONFIG_ISR_STACK_SIZE+0x27c>
     a64:	01c30333          	add	t1,t1,t3
     a68:	fff70793          	addi	a5,a4,-1 # ffffff <__data_region_end+0xffb7c3>
     a6c:	01c36863          	bltu	t1,t3,a7c <CONFIG_ISR_STACK_SIZE+0x27c>
     a70:	00b37663          	bgeu	t1,a1,a7c <CONFIG_ISR_STACK_SIZE+0x27c>
     a74:	ffe70793          	addi	a5,a4,-2
     a78:	01c30333          	add	t1,t1,t3
     a7c:	01069693          	slli	a3,a3,0x10
     a80:	00010f37          	lui	t5,0x10
     a84:	00f6e6b3          	or	a3,a3,a5
     a88:	40b305b3          	sub	a1,t1,a1
     a8c:	ffff0313          	addi	t1,t5,-1 # ffff <__data_region_end+0xb7c3>
     a90:	0066feb3          	and	t4,a3,t1
     a94:	01065713          	srli	a4,a2,0x10
     a98:	0106d693          	srli	a3,a3,0x10
     a9c:	00667333          	and	t1,a2,t1
     aa0:	026e87b3          	mul	a5,t4,t1
     aa4:	02668333          	mul	t1,a3,t1
     aa8:	02ee8eb3          	mul	t4,t4,a4
     aac:	02e686b3          	mul	a3,a3,a4
     ab0:	006e8eb3          	add	t4,t4,t1
     ab4:	0107d713          	srli	a4,a5,0x10
     ab8:	01d70733          	add	a4,a4,t4
     abc:	00677463          	bgeu	a4,t1,ac4 <CONFIG_ISR_STACK_SIZE+0x2c4>
     ac0:	01e686b3          	add	a3,a3,t5
     ac4:	01075313          	srli	t1,a4,0x10
     ac8:	00d306b3          	add	a3,t1,a3
     acc:	00010337          	lui	t1,0x10
     ad0:	fff30313          	addi	t1,t1,-1 # ffff <__data_region_end+0xb7c3>
     ad4:	00677733          	and	a4,a4,t1
     ad8:	01071713          	slli	a4,a4,0x10
     adc:	0067f7b3          	and	a5,a5,t1
     ae0:	00f707b3          	add	a5,a4,a5
     ae4:	00d5e663          	bltu	a1,a3,af0 <CONFIG_ISR_STACK_SIZE+0x2f0>
     ae8:	00d59e63          	bne	a1,a3,b04 <CONFIG_ISR_STACK_SIZE+0x304>
     aec:	00f57c63          	bgeu	a0,a5,b04 <CONFIG_ISR_STACK_SIZE+0x304>
     af0:	40c78633          	sub	a2,a5,a2
     af4:	00c7b7b3          	sltu	a5,a5,a2
     af8:	01c787b3          	add	a5,a5,t3
     afc:	40f686b3          	sub	a3,a3,a5
     b00:	00060793          	mv	a5,a2
     b04:	40f507b3          	sub	a5,a0,a5
     b08:	00f53533          	sltu	a0,a0,a5
     b0c:	40d585b3          	sub	a1,a1,a3
     b10:	40a585b3          	sub	a1,a1,a0
     b14:	011598b3          	sll	a7,a1,a7
     b18:	0107d533          	srl	a0,a5,a6
     b1c:	00a8e533          	or	a0,a7,a0
     b20:	0105d5b3          	srl	a1,a1,a6
     b24:	cddff06f          	j	800 <CONFIG_ISR_STACK_SIZE>

00000b28 <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
     b28:	00008067          	ret

00000b2c <main>:
#include <zephyr.h>
#include <sys/printk.h>

void main(void)
{
	printk("Hello World! %s\n", CONFIG_BOARD);
     b2c:	000035b7          	lui	a1,0x3
     b30:	00003537          	lui	a0,0x3
     b34:	6a458593          	addi	a1,a1,1700 # 36a4 <__clz_tab+0x100>
     b38:	6b450513          	addi	a0,a0,1716 # 36b4 <__clz_tab+0x110>
     b3c:	0600006f          	j	b9c <printk>

00000b40 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
     b40:	00000513          	li	a0,0
     b44:	00008067          	ret

00000b48 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
     b48:	0005a783          	lw	a5,0(a1)
     b4c:	00178793          	addi	a5,a5,1 # 10001 <__data_region_end+0xb7c5>
     b50:	00f5a023          	sw	a5,0(a1)
	return _char_out(c);
     b54:	000057b7          	lui	a5,0x5
     b58:	8107a783          	lw	a5,-2032(a5) # 4810 <_char_out>
     b5c:	00078067          	jr	a5

00000b60 <__printk_hook_install>:
	_char_out = fn;
     b60:	000057b7          	lui	a5,0x5
     b64:	80a7a823          	sw	a0,-2032(a5) # 4810 <_char_out>
}
     b68:	00008067          	ret

00000b6c <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
     b6c:	fe010113          	addi	sp,sp,-32
     b70:	00050613          	mv	a2,a0
		struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
		k_spinlock_key_t key = k_spin_lock(&lock);
#endif

		cbvprintf(char_out, &ctx, fmt, ap);
     b74:	00001537          	lui	a0,0x1
{
     b78:	00058693          	mv	a3,a1
		cbvprintf(char_out, &ctx, fmt, ap);
     b7c:	b4850513          	addi	a0,a0,-1208 # b48 <char_out>
     b80:	00c10593          	addi	a1,sp,12
{
     b84:	00112e23          	sw	ra,28(sp)
		struct out_context ctx = { 0 };
     b88:	00012623          	sw	zero,12(sp)
		cbvprintf(char_out, &ctx, fmt, ap);
     b8c:	244000ef          	jal	ra,dd0 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
     b90:	01c12083          	lw	ra,28(sp)
     b94:	02010113          	addi	sp,sp,32
     b98:	00008067          	ret

00000b9c <printk>:
 *
 * @return N/A
 */

void printk(const char *fmt, ...)
{
     b9c:	fc010113          	addi	sp,sp,-64
     ba0:	02b12223          	sw	a1,36(sp)
	va_list ap;

	va_start(ap, fmt);
     ba4:	02410593          	addi	a1,sp,36
{
     ba8:	00112e23          	sw	ra,28(sp)
     bac:	02c12423          	sw	a2,40(sp)
     bb0:	02d12623          	sw	a3,44(sp)
     bb4:	02e12823          	sw	a4,48(sp)
     bb8:	02f12a23          	sw	a5,52(sp)
     bbc:	03012c23          	sw	a6,56(sp)
     bc0:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
     bc4:	00b12623          	sw	a1,12(sp)

	vprintk(fmt, ap);
     bc8:	fa5ff0ef          	jal	ra,b6c <vprintk>

	va_end(ap);
}
     bcc:	01c12083          	lw	ra,28(sp)
     bd0:	04010113          	addi	sp,sp,64
     bd4:	00008067          	ret

00000bd8 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
     bd8:	ff010113          	addi	sp,sp,-16
     bdc:	00050793          	mv	a5,a0
     be0:	00058513          	mv	a0,a1
     be4:	00060593          	mv	a1,a2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
     be8:	00068613          	mv	a2,a3
{
     bec:	00112623          	sw	ra,12(sp)
	entry(p1, p2, p3);
     bf0:	000780e7          	jalr	a5
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
     bf4:	14c020ef          	jal	ra,2d40 <z_impl_z_current_get>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
     bf8:	248020ef          	jal	ra,2e40 <z_impl_k_thread_abort>

00000bfc <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
     bfc:	fd010113          	addi	sp,sp,-48
     c00:	02812423          	sw	s0,40(sp)
     c04:	02912223          	sw	s1,36(sp)
     c08:	03212023          	sw	s2,32(sp)
     c0c:	01312e23          	sw	s3,28(sp)
     c10:	01712623          	sw	s7,12(sp)
     c14:	01812423          	sw	s8,8(sp)
     c18:	01912223          	sw	s9,4(sp)
     c1c:	02112623          	sw	ra,44(sp)
     c20:	01412c23          	sw	s4,24(sp)
     c24:	01512a23          	sw	s5,20(sp)
     c28:	01612823          	sw	s6,16(sp)
	bool upcase = isupper((int)conv->specifier);
     c2c:	00364783          	lbu	a5,3(a2)
{
     c30:	00070413          	mv	s0,a4
	switch (specifier) {
     c34:	06f00713          	li	a4,111
{
     c38:	00050c13          	mv	s8,a0
     c3c:	00058c93          	mv	s9,a1
     c40:	00060b93          	mv	s7,a2
     c44:	00068913          	mv	s2,a3
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
     c48:	fbf78993          	addi	s3,a5,-65
	switch (specifier) {
     c4c:	00800493          	li	s1,8
     c50:	00e78c63          	beq	a5,a4,c68 <encode_uint+0x6c>
     c54:	0cf76263          	bltu	a4,a5,d18 <encode_uint+0x11c>
     c58:	05800713          	li	a4,88
		return 10;
     c5c:	00a00493          	li	s1,10
	switch (specifier) {
     c60:	00e79463          	bne	a5,a4,c68 <encode_uint+0x6c>
		return 16;
     c64:	01000493          	li	s1,16
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
     c68:	00000a93          	li	s5,0

		*--bp = (lsv <= 9) ? ('0' + lsv)
     c6c:	00900a13          	li	s4,9
     c70:	01900b13          	li	s6,25
		unsigned int lsv = (unsigned int)(value % radix);
     c74:	00048613          	mv	a2,s1
     c78:	00000693          	li	a3,0
     c7c:	000c0513          	mv	a0,s8
     c80:	000c8593          	mv	a1,s9
     c84:	aa1ff0ef          	jal	ra,724 <__umoddi3>
		*--bp = (lsv <= 9) ? ('0' + lsv)
     c88:	0ff57793          	andi	a5,a0,255
     c8c:	0aaa6263          	bltu	s4,a0,d30 <encode_uint+0x134>
     c90:	03078793          	addi	a5,a5,48
     c94:	0ff7f793          	andi	a5,a5,255
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
     c98:	00048613          	mv	a2,s1
     c9c:	00000693          	li	a3,0
     ca0:	000c0513          	mv	a0,s8
     ca4:	000c8593          	mv	a1,s9
		*--bp = (lsv <= 9) ? ('0' + lsv)
     ca8:	fef40fa3          	sb	a5,-1(s0)
     cac:	fff40413          	addi	s0,s0,-1
		value /= radix;
     cb0:	e40ff0ef          	jal	ra,2f0 <__udivdi3>
	} while ((value != 0) && (bps < bp));
     cb4:	019a9463          	bne	s5,s9,cbc <encode_uint+0xc0>
     cb8:	009c6463          	bltu	s8,s1,cc0 <encode_uint+0xc4>
     cbc:	06896463          	bltu	s2,s0,d24 <encode_uint+0x128>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
     cc0:	000bd783          	lhu	a5,0(s7)
     cc4:	0207f793          	andi	a5,a5,32
     cc8:	00078c63          	beqz	a5,ce0 <encode_uint+0xe4>
		if (radix == 8) {
     ccc:	00800793          	li	a5,8
     cd0:	06f49a63          	bne	s1,a5,d44 <encode_uint+0x148>
			conv->altform_0 = true;
     cd4:	002bc783          	lbu	a5,2(s7)
     cd8:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
     cdc:	00fb8123          	sb	a5,2(s7)
			;
		}
	}

	return bp;
}
     ce0:	02c12083          	lw	ra,44(sp)
     ce4:	00040513          	mv	a0,s0
     ce8:	02812403          	lw	s0,40(sp)
     cec:	02412483          	lw	s1,36(sp)
     cf0:	02012903          	lw	s2,32(sp)
     cf4:	01c12983          	lw	s3,28(sp)
     cf8:	01812a03          	lw	s4,24(sp)
     cfc:	01412a83          	lw	s5,20(sp)
     d00:	01012b03          	lw	s6,16(sp)
     d04:	00c12b83          	lw	s7,12(sp)
     d08:	00812c03          	lw	s8,8(sp)
     d0c:	00412c83          	lw	s9,4(sp)
     d10:	03010113          	addi	sp,sp,48
     d14:	00008067          	ret
	switch (specifier) {
     d18:	0f77f793          	andi	a5,a5,247
     d1c:	07000713          	li	a4,112
     d20:	f3dff06f          	j	c5c <encode_uint+0x60>
		value /= radix;
     d24:	00050c13          	mv	s8,a0
     d28:	00058c93          	mv	s9,a1
     d2c:	f49ff06f          	j	c74 <encode_uint+0x78>
		*--bp = (lsv <= 9) ? ('0' + lsv)
     d30:	013b6663          	bltu	s6,s3,d3c <encode_uint+0x140>
     d34:	03778793          	addi	a5,a5,55
     d38:	f5dff06f          	j	c94 <encode_uint+0x98>
     d3c:	05778793          	addi	a5,a5,87
     d40:	f55ff06f          	j	c94 <encode_uint+0x98>
		} else if (radix == 16) {
     d44:	01000793          	li	a5,16
     d48:	f8f49ce3          	bne	s1,a5,ce0 <encode_uint+0xe4>
			conv->altform_0c = true;
     d4c:	002bc783          	lbu	a5,2(s7)
     d50:	0107e793          	ori	a5,a5,16
     d54:	f89ff06f          	j	cdc <encode_uint+0xe0>

00000d58 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
     d58:	fe010113          	addi	sp,sp,-32
     d5c:	00812c23          	sw	s0,24(sp)
     d60:	00912a23          	sw	s1,20(sp)
     d64:	01212823          	sw	s2,16(sp)
     d68:	01312623          	sw	s3,12(sp)
     d6c:	01412423          	sw	s4,8(sp)
     d70:	00112e23          	sw	ra,28(sp)
     d74:	00050993          	mv	s3,a0
     d78:	00058a13          	mv	s4,a1
     d7c:	00060493          	mv	s1,a2
     d80:	00068913          	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
     d84:	00060413          	mv	s0,a2
     d88:	40940533          	sub	a0,s0,s1
     d8c:	01246863          	bltu	s0,s2,d9c <outs+0x44>
     d90:	02091063          	bnez	s2,db0 <outs+0x58>
     d94:	00044783          	lbu	a5,0(s0)
     d98:	00078c63          	beqz	a5,db0 <outs+0x58>
		int rc = out((int)*sp++, ctx);
     d9c:	00044503          	lbu	a0,0(s0)
     da0:	000a0593          	mv	a1,s4
     da4:	00140413          	addi	s0,s0,1
     da8:	000980e7          	jalr	s3

		if (rc < 0) {
     dac:	fc055ee3          	bgez	a0,d88 <outs+0x30>
		}
		++count;
	}

	return (int)count;
}
     db0:	01c12083          	lw	ra,28(sp)
     db4:	01812403          	lw	s0,24(sp)
     db8:	01412483          	lw	s1,20(sp)
     dbc:	01012903          	lw	s2,16(sp)
     dc0:	00c12983          	lw	s3,12(sp)
     dc4:	00812a03          	lw	s4,8(sp)
     dc8:	02010113          	addi	sp,sp,32
     dcc:	00008067          	ret

00000dd0 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
     dd0:	f7010113          	addi	sp,sp,-144
     dd4:	07512a23          	sw	s5,116(sp)
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
     dd8:	00003ab7          	lui	s5,0x3
     ddc:	754a8793          	addi	a5,s5,1876 # 3754 <__clz_tab+0x1b0>
{
     de0:	07612823          	sw	s6,112(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
     de4:	00003b37          	lui	s6,0x3
{
     de8:	07712623          	sw	s7,108(sp)
     dec:	07812423          	sw	s8,104(sp)
		switch (conv->specifier) {
     df0:	00f12223          	sw	a5,4(sp)
				conv->specifier = 'x';

				goto prec_int_pad0;
			}

			bps = "(nil)";
     df4:	00003bb7          	lui	s7,0x3
	switch ((enum length_mod_enum)conv->length_mod) {
     df8:	7acb0793          	addi	a5,s6,1964 # 37ac <__clz_tab+0x208>
			bpe = bps + 5;
     dfc:	00003c37          	lui	s8,0x3
{
     e00:	09212023          	sw	s2,128(sp)
     e04:	07312e23          	sw	s3,124(sp)
     e08:	07912223          	sw	s9,100(sp)
     e0c:	07a12023          	sw	s10,96(sp)
     e10:	05b12e23          	sw	s11,92(sp)
     e14:	08112623          	sw	ra,140(sp)
     e18:	08812423          	sw	s0,136(sp)
     e1c:	08912223          	sw	s1,132(sp)
     e20:	07412c23          	sw	s4,120(sp)
     e24:	00050913          	mv	s2,a0
     e28:	00058993          	mv	s3,a1
     e2c:	00060d13          	mv	s10,a2
     e30:	00068c93          	mv	s9,a3
	size_t count = 0;
     e34:	00000d93          	li	s11,0
	switch ((enum length_mod_enum)conv->length_mod) {
     e38:	00f12423          	sw	a5,8(sp)
			bps = "(nil)";
     e3c:	6c8b8b93          	addi	s7,s7,1736 # 36c8 <__clz_tab+0x124>
			bpe = bps + 5;
     e40:	6cdc0c13          	addi	s8,s8,1741 # 36cd <__clz_tab+0x129>
	while (*fp != 0) {
     e44:	000d4403          	lbu	s0,0(s10)
     e48:	00041663          	bnez	s0,e54 <cbvprintf+0x84>
			OUTC(' ');
			--width;
		}
	}

	return count;
     e4c:	000d8513          	mv	a0,s11
     e50:	2290006f          	j	1878 <__kernel_ram_size+0x8ec>
		if (*fp != '%') {
     e54:	02500793          	li	a5,37
			OUTC(*fp++);
     e58:	001d0a13          	addi	s4,s10,1
		if (*fp != '%') {
     e5c:	02f40463          	beq	s0,a5,e84 <cbvprintf+0xb4>
			OUTC(*fp++);
     e60:	00098593          	mv	a1,s3
     e64:	00040513          	mv	a0,s0
     e68:	000900e7          	jalr	s2
     e6c:	200546e3          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
     e70:	001d8d93          	addi	s11,s11,1
			continue;
     e74:	000c8413          	mv	s0,s9
     e78:	00040c93          	mv	s9,s0
     e7c:	000a0d13          	mv	s10,s4
     e80:	fc5ff06f          	j	e44 <cbvprintf+0x74>
		} state = {
     e84:	02000613          	li	a2,32
     e88:	00000593          	li	a1,0
     e8c:	03010513          	addi	a0,sp,48
     e90:	3c9000ef          	jal	ra,1a58 <memset>
	if (*sp == '%') {
     e94:	001d4783          	lbu	a5,1(s10)
     e98:	0e879263          	bne	a5,s0,f7c <cbvprintf+0x1ac>
		conv->specifier = *sp++;
     e9c:	002d0a13          	addi	s4,s10,2
     ea0:	04f101a3          	sb	a5,67(sp)
		if (conv->width_star) {
     ea4:	04015783          	lhu	a5,64(sp)
     ea8:	1007f713          	andi	a4,a5,256
     eac:	52070e63          	beqz	a4,13e8 <__kernel_ram_size+0x45c>
			width = va_arg(ap, int);
     eb0:	000ca483          	lw	s1,0(s9)
     eb4:	004c8413          	addi	s0,s9,4
			if (width < 0) {
     eb8:	0004d863          	bgez	s1,ec8 <cbvprintf+0xf8>
				conv->flag_dash = true;
     ebc:	0047e793          	ori	a5,a5,4
     ec0:	04f11023          	sh	a5,64(sp)
				width = -width;
     ec4:	409004b3          	neg	s1,s1
		if (conv->prec_star) {
     ec8:	04015703          	lhu	a4,64(sp)
     ecc:	40077793          	andi	a5,a4,1024
     ed0:	52078c63          	beqz	a5,1408 <__kernel_ram_size+0x47c>
			int arg = va_arg(ap, int);
     ed4:	00042a83          	lw	s5,0(s0)
     ed8:	00440413          	addi	s0,s0,4
			if (arg < 0) {
     edc:	000ad863          	bgez	s5,eec <cbvprintf+0x11c>
				conv->prec_present = false;
     ee0:	dff77713          	andi	a4,a4,-513
     ee4:	04e11023          	sh	a4,64(sp)
		int precision = -1;
     ee8:	fff00a93          	li	s5,-1
			= (enum specifier_cat_enum)conv->specifier_cat;
     eec:	04012583          	lw	a1,64(sp)
		conv->pad0_value = 0;
     ef0:	04012223          	sw	zero,68(sp)
		conv->pad0_pre_exp = 0;
     ef4:	04012423          	sw	zero,72(sp)
			= (enum specifier_cat_enum)conv->specifier_cat;
     ef8:	0105d693          	srli	a3,a1,0x10
			= (enum length_mod_enum)conv->length_mod;
     efc:	00b5d713          	srli	a4,a1,0xb
		enum specifier_cat_enum specifier_cat
     f00:	0076f693          	andi	a3,a3,7
		if (specifier_cat == SPECIFIER_SINT) {
     f04:	00100613          	li	a2,1
			= (enum length_mod_enum)conv->length_mod;
     f08:	00f77713          	andi	a4,a4,15
		if (specifier_cat == SPECIFIER_SINT) {
     f0c:	56c69263          	bne	a3,a2,1470 <__kernel_ram_size+0x4e4>
			switch (length_mod) {
     f10:	00500613          	li	a2,5
     f14:	50c70e63          	beq	a4,a2,1430 <__kernel_ram_size+0x4a4>
     f18:	00e66a63          	bltu	a2,a4,f2c <cbvprintf+0x15c>
     f1c:	00300693          	li	a3,3
     f20:	4ed70e63          	beq	a4,a3,141c <__kernel_ram_size+0x490>
     f24:	00400693          	li	a3,4
     f28:	50d70463          	beq	a4,a3,1430 <__kernel_ram_size+0x4a4>
					(sint_value_type)va_arg(ap, ptrdiff_t);
     f2c:	00042683          	lw	a3,0(s0)
     f30:	00440413          	addi	s0,s0,4
     f34:	02d12823          	sw	a3,48(sp)
     f38:	41f6d693          	srai	a3,a3,0x1f
     f3c:	02d12a23          	sw	a3,52(sp)
			if (length_mod == LENGTH_HH) {
     f40:	00100693          	li	a3,1
     f44:	50d71863          	bne	a4,a3,1454 <__kernel_ram_size+0x4c8>
				value->uint = (unsigned char)value->uint;
     f48:	03014683          	lbu	a3,48(sp)
				value->uint = (unsigned short)value->uint;
     f4c:	02d12823          	sw	a3,48(sp)
     f50:	02012a23          	sw	zero,52(sp)
		if (conv->invalid || conv->unsupported) {
     f54:	0035f593          	andi	a1,a1,3
     f58:	5e058863          	beqz	a1,1548 <__kernel_ram_size+0x5bc>
			OUTS(sp, fp);
     f5c:	000a0693          	mv	a3,s4
     f60:	000d0613          	mv	a2,s10
     f64:	00098593          	mv	a1,s3
     f68:	00090513          	mv	a0,s2
     f6c:	dedff0ef          	jal	ra,d58 <outs>
     f70:	100544e3          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
     f74:	00ad8db3          	add	s11,s11,a0
			continue;
     f78:	f01ff06f          	j	e78 <cbvprintf+0xa8>
     f7c:	00000513          	li	a0,0
     f80:	00000693          	li	a3,0
     f84:	00000593          	li	a1,0
     f88:	00000613          	li	a2,0
     f8c:	00000713          	li	a4,0
		switch (*sp) {
     f90:	02b00813          	li	a6,43
     f94:	02d00893          	li	a7,45
     f98:	03000313          	li	t1,48
     f9c:	02000e13          	li	t3,32
     fa0:	02300e93          	li	t4,35
     fa4:	000a4783          	lbu	a5,0(s4)
     fa8:	13078863          	beq	a5,a6,10d8 <__kernel_ram_size+0x14c>
     fac:	10f86e63          	bltu	a6,a5,10c8 <__kernel_ram_size+0x13c>
     fb0:	13c78a63          	beq	a5,t3,10e4 <__kernel_ram_size+0x158>
     fb4:	13d78c63          	beq	a5,t4,10ec <__kernel_ram_size+0x160>
     fb8:	00070863          	beqz	a4,fc8 <__kernel_ram_size+0x3c>
     fbc:	04015703          	lhu	a4,64(sp)
     fc0:	00476713          	ori	a4,a4,4
     fc4:	04e11023          	sh	a4,64(sp)
     fc8:	00060863          	beqz	a2,fd8 <__kernel_ram_size+0x4c>
     fcc:	04015703          	lhu	a4,64(sp)
     fd0:	00876713          	ori	a4,a4,8
     fd4:	04e11023          	sh	a4,64(sp)
     fd8:	00058863          	beqz	a1,fe8 <__kernel_ram_size+0x5c>
     fdc:	04015703          	lhu	a4,64(sp)
     fe0:	01076713          	ori	a4,a4,16
     fe4:	04e11023          	sh	a4,64(sp)
     fe8:	00068863          	beqz	a3,ff8 <__kernel_ram_size+0x6c>
     fec:	04015703          	lhu	a4,64(sp)
     ff0:	02076713          	ori	a4,a4,32
     ff4:	04e11023          	sh	a4,64(sp)
     ff8:	00050863          	beqz	a0,1008 <__kernel_ram_size+0x7c>
     ffc:	04015703          	lhu	a4,64(sp)
    1000:	04076713          	ori	a4,a4,64
    1004:	04e11023          	sh	a4,64(sp)
	if (conv->flag_zero && conv->flag_dash) {
    1008:	04012703          	lw	a4,64(sp)
    100c:	04400693          	li	a3,68
    1010:	04477713          	andi	a4,a4,68
    1014:	00d71863          	bne	a4,a3,1024 <__kernel_ram_size+0x98>
		conv->flag_zero = false;
    1018:	04015703          	lhu	a4,64(sp)
    101c:	fbf77713          	andi	a4,a4,-65
    1020:	04e11023          	sh	a4,64(sp)
	conv->width_present = true;
    1024:	04015703          	lhu	a4,64(sp)
    1028:	08076693          	ori	a3,a4,128
    102c:	04d11023          	sh	a3,64(sp)
	if (*sp == '*') {
    1030:	02a00693          	li	a3,42
    1034:	10d79463          	bne	a5,a3,113c <__kernel_ram_size+0x1b0>
			++sp;
    1038:	001a0793          	addi	a5,s4,1
		conv->width_star = true;
    103c:	18076713          	ori	a4,a4,384
		conv->unsupported |= ((conv->width_value < 0)
    1040:	04e11023          	sh	a4,64(sp)
	conv->prec_present = (*sp == '.');
    1044:	0007c603          	lbu	a2,0(a5)
    1048:	fd260713          	addi	a4,a2,-46
    104c:	00173713          	seqz	a4,a4
    1050:	00971693          	slli	a3,a4,0x9
    1054:	04015703          	lhu	a4,64(sp)
    1058:	dff77713          	andi	a4,a4,-513
    105c:	00d76733          	or	a4,a4,a3
    1060:	04e11023          	sh	a4,64(sp)
	if (!conv->prec_present) {
    1064:	02e00693          	li	a3,46
    1068:	0ed61a63          	bne	a2,a3,115c <__kernel_ram_size+0x1d0>
	if (*sp == '*') {
    106c:	0017c603          	lbu	a2,1(a5)
    1070:	02a00693          	li	a3,42
    1074:	0cd60e63          	beq	a2,a3,1150 <__kernel_ram_size+0x1c4>
	++sp;
    1078:	00178793          	addi	a5,a5,1
	size_t val = 0;
    107c:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
    1080:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
    1084:	00a00813          	li	a6,10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    1088:	0007c683          	lbu	a3,0(a5)
    108c:	00178513          	addi	a0,a5,1
    1090:	fd068593          	addi	a1,a3,-48 # ffffd0 <__data_region_end+0xffb794>
	while (isdigit((int)(unsigned char)*sp)) {
    1094:	16b67463          	bgeu	a2,a1,11fc <__kernel_ram_size+0x270>
	conv->unsupported |= ((conv->prec_value < 0)
    1098:	04012683          	lw	a3,64(sp)
	conv->prec_value = prec;
    109c:	04e12423          	sw	a4,72(sp)
			      || (prec != (size_t)conv->prec_value));
    10a0:	01f75713          	srli	a4,a4,0x1f
	conv->unsupported |= ((conv->prec_value < 0)
    10a4:	0016d693          	srli	a3,a3,0x1
    10a8:	0016f693          	andi	a3,a3,1
    10ac:	00e6e733          	or	a4,a3,a4
    10b0:	04015683          	lhu	a3,64(sp)
    10b4:	00171713          	slli	a4,a4,0x1
    10b8:	ffd6f693          	andi	a3,a3,-3
    10bc:	00e6e733          	or	a4,a3,a4
    10c0:	04e11023          	sh	a4,64(sp)
	return sp;
    10c4:	0980006f          	j	115c <__kernel_ram_size+0x1d0>
		switch (*sp) {
    10c8:	03178663          	beq	a5,a7,10f4 <__kernel_ram_size+0x168>
    10cc:	ee6796e3          	bne	a5,t1,fb8 <__kernel_ram_size+0x2c>
			conv->flag_zero = true;
    10d0:	00100513          	li	a0,1
    10d4:	0080006f          	j	10dc <__kernel_ram_size+0x150>
			conv->flag_plus = true;
    10d8:	00100613          	li	a2,1
			++sp;
    10dc:	001a0a13          	addi	s4,s4,1
	} while (loop);
    10e0:	ec5ff06f          	j	fa4 <__kernel_ram_size+0x18>
			conv->flag_space = true;
    10e4:	00100593          	li	a1,1
    10e8:	ff5ff06f          	j	10dc <__kernel_ram_size+0x150>
			conv->flag_hash = true;
    10ec:	00100693          	li	a3,1
    10f0:	fedff06f          	j	10dc <__kernel_ram_size+0x150>
		switch (*sp) {
    10f4:	00100713          	li	a4,1
    10f8:	fe5ff06f          	j	10dc <__kernel_ram_size+0x150>
		val = 10U * val + *sp++ - '0';
    10fc:	03070733          	mul	a4,a4,a6
    1100:	00050793          	mv	a5,a0
    1104:	fd070713          	addi	a4,a4,-48
    1108:	00d70733          	add	a4,a4,a3
    110c:	0007c683          	lbu	a3,0(a5)
    1110:	00178513          	addi	a0,a5,1
    1114:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp)) {
    1118:	feb672e3          	bgeu	a2,a1,10fc <__kernel_ram_size+0x170>
	if (sp != wp) {
    111c:	f2fa04e3          	beq	s4,a5,1044 <__kernel_ram_size+0xb8>
		conv->unsupported |= ((conv->width_value < 0)
    1120:	04015683          	lhu	a3,64(sp)
		conv->width_value = width;
    1124:	04e12223          	sw	a4,68(sp)
		conv->unsupported |= ((conv->width_value < 0)
    1128:	01f75713          	srli	a4,a4,0x1f
    112c:	00171713          	slli	a4,a4,0x1
    1130:	ffd6f693          	andi	a3,a3,-3
    1134:	00e6e733          	or	a4,a3,a4
    1138:	f09ff06f          	j	1040 <__kernel_ram_size+0xb4>
    113c:	000a0793          	mv	a5,s4
	size_t val = 0;
    1140:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
    1144:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
    1148:	00a00813          	li	a6,10
    114c:	fc1ff06f          	j	110c <__kernel_ram_size+0x180>
		conv->prec_star = true;
    1150:	40076713          	ori	a4,a4,1024
    1154:	04e11023          	sh	a4,64(sp)
		return ++sp;
    1158:	00278793          	addi	a5,a5,2
	switch (*sp) {
    115c:	0007c603          	lbu	a2,0(a5)
    1160:	06c00713          	li	a4,108
		if (*++sp == 'h') {
    1164:	00178593          	addi	a1,a5,1
	switch (*sp) {
    1168:	10e60c63          	beq	a2,a4,1280 <__kernel_ram_size+0x2f4>
    116c:	0ac76263          	bltu	a4,a2,1210 <__kernel_ram_size+0x284>
    1170:	06800713          	li	a4,104
    1174:	0ce60663          	beq	a2,a4,1240 <__kernel_ram_size+0x2b4>
    1178:	06a00713          	li	a4,106
    117c:	12e60863          	beq	a2,a4,12ac <__kernel_ram_size+0x320>
    1180:	04c00713          	li	a4,76
    1184:	14e60e63          	beq	a2,a4,12e0 <__kernel_ram_size+0x354>
    1188:	00078593          	mv	a1,a5
	conv->specifier = *sp++;
    118c:	0005c703          	lbu	a4,0(a1)
	switch (conv->specifier) {
    1190:	07800793          	li	a5,120
	conv->specifier = *sp++;
    1194:	00158a13          	addi	s4,a1,1
    1198:	04e101a3          	sb	a4,67(sp)
	switch (conv->specifier) {
    119c:	22e7ec63          	bltu	a5,a4,13d4 <__kernel_ram_size+0x448>
    11a0:	05700793          	li	a5,87
    11a4:	14e7ec63          	bltu	a5,a4,12fc <__kernel_ram_size+0x370>
    11a8:	04100793          	li	a5,65
    11ac:	00f70a63          	beq	a4,a5,11c0 <__kernel_ram_size+0x234>
    11b0:	fbb70713          	addi	a4,a4,-69
    11b4:	0ff77713          	andi	a4,a4,255
    11b8:	00200793          	li	a5,2
    11bc:	20e7ec63          	bltu	a5,a4,13d4 <__kernel_ram_size+0x448>
		conv->specifier_cat = SPECIFIER_FP;
    11c0:	04214783          	lbu	a5,66(sp)
    11c4:	ff87f793          	andi	a5,a5,-8
    11c8:	0047e793          	ori	a5,a5,4
    11cc:	04f10123          	sb	a5,66(sp)
			unsupported = true;
    11d0:	00100793          	li	a5,1
	conv->unsupported |= unsupported;
    11d4:	04012703          	lw	a4,64(sp)
    11d8:	00175713          	srli	a4,a4,0x1
    11dc:	00177713          	andi	a4,a4,1
    11e0:	00e7e7b3          	or	a5,a5,a4
    11e4:	04015703          	lhu	a4,64(sp)
    11e8:	00179793          	slli	a5,a5,0x1
    11ec:	ffd77713          	andi	a4,a4,-3
    11f0:	00f767b3          	or	a5,a4,a5
    11f4:	04f11023          	sh	a5,64(sp)
	return sp;
    11f8:	cadff06f          	j	ea4 <cbvprintf+0xd4>
		val = 10U * val + *sp++ - '0';
    11fc:	03070733          	mul	a4,a4,a6
    1200:	00050793          	mv	a5,a0
    1204:	fd070713          	addi	a4,a4,-48
    1208:	00e68733          	add	a4,a3,a4
    120c:	e7dff06f          	j	1088 <__kernel_ram_size+0xfc>
	switch (*sp) {
    1210:	07400713          	li	a4,116
    1214:	0ae60a63          	beq	a2,a4,12c8 <__kernel_ram_size+0x33c>
    1218:	07a00713          	li	a4,122
    121c:	f6e616e3          	bne	a2,a4,1188 <__kernel_ram_size+0x1fc>
		conv->length_mod = LENGTH_Z;
    1220:	04015783          	lhu	a5,64(sp)
    1224:	ffff8737          	lui	a4,0xffff8
    1228:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
    122c:	00e7f7b3          	and	a5,a5,a4
    1230:	00003737          	lui	a4,0x3
		conv->unsupported = true;
    1234:	00e7e7b3          	or	a5,a5,a4
    1238:	04f11023          	sh	a5,64(sp)
		break;
    123c:	f51ff06f          	j	118c <__kernel_ram_size+0x200>
		if (*++sp == 'h') {
    1240:	04015503          	lhu	a0,64(sp)
    1244:	0017c803          	lbu	a6,1(a5)
    1248:	ffff86b7          	lui	a3,0xffff8
    124c:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_HH;
    1250:	00a77733          	and	a4,a4,a0
		if (*++sp == 'h') {
    1254:	00c81e63          	bne	a6,a2,1270 <__kernel_ram_size+0x2e4>
			conv->length_mod = LENGTH_HH;
    1258:	000016b7          	lui	a3,0x1
    125c:	80068693          	addi	a3,a3,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
    1260:	00d76733          	or	a4,a4,a3
    1264:	04e11023          	sh	a4,64(sp)
			++sp;
    1268:	00278593          	addi	a1,a5,2
    126c:	f21ff06f          	j	118c <__kernel_ram_size+0x200>
			conv->length_mod = LENGTH_H;
    1270:	000017b7          	lui	a5,0x1
			conv->length_mod = LENGTH_L;
    1274:	00f76733          	or	a4,a4,a5
    1278:	04e11023          	sh	a4,64(sp)
    127c:	f11ff06f          	j	118c <__kernel_ram_size+0x200>
		if (*++sp == 'l') {
    1280:	04015503          	lhu	a0,64(sp)
    1284:	0017c803          	lbu	a6,1(a5) # 1001 <__kernel_ram_size+0x75>
    1288:	ffff86b7          	lui	a3,0xffff8
    128c:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_LL;
    1290:	00a77733          	and	a4,a4,a0
		if (*++sp == 'l') {
    1294:	00c81663          	bne	a6,a2,12a0 <__kernel_ram_size+0x314>
			conv->length_mod = LENGTH_LL;
    1298:	000026b7          	lui	a3,0x2
    129c:	fc5ff06f          	j	1260 <__kernel_ram_size+0x2d4>
			conv->length_mod = LENGTH_L;
    12a0:	000027b7          	lui	a5,0x2
    12a4:	80078793          	addi	a5,a5,-2048 # 1800 <__kernel_ram_size+0x874>
    12a8:	fcdff06f          	j	1274 <__kernel_ram_size+0x2e8>
		conv->length_mod = LENGTH_J;
    12ac:	04015783          	lhu	a5,64(sp)
    12b0:	ffff8737          	lui	a4,0xffff8
    12b4:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
    12b8:	00e7f7b3          	and	a5,a5,a4
    12bc:	00003737          	lui	a4,0x3
		conv->length_mod = LENGTH_T;
    12c0:	80070713          	addi	a4,a4,-2048 # 2800 <z_reset_time_slice+0x10>
    12c4:	f71ff06f          	j	1234 <__kernel_ram_size+0x2a8>
    12c8:	04015783          	lhu	a5,64(sp)
    12cc:	ffff8737          	lui	a4,0xffff8
    12d0:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
    12d4:	00e7f7b3          	and	a5,a5,a4
    12d8:	00004737          	lui	a4,0x4
    12dc:	fe5ff06f          	j	12c0 <__kernel_ram_size+0x334>
		conv->unsupported = true;
    12e0:	04015783          	lhu	a5,64(sp)
    12e4:	ffff8737          	lui	a4,0xffff8
    12e8:	7fd70713          	addi	a4,a4,2045 # ffff87fd <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff87fe>
    12ec:	00e7f7b3          	and	a5,a5,a4
    12f0:	00004737          	lui	a4,0x4
    12f4:	00270713          	addi	a4,a4,2 # 4002 <z_idle_stacks+0x1f2>
    12f8:	f3dff06f          	j	1234 <__kernel_ram_size+0x2a8>
	switch (conv->specifier) {
    12fc:	fa870793          	addi	a5,a4,-88
    1300:	0ff7f793          	andi	a5,a5,255
    1304:	02000693          	li	a3,32
    1308:	0cf6e663          	bltu	a3,a5,13d4 <__kernel_ram_size+0x448>
    130c:	000036b7          	lui	a3,0x3
    1310:	00279793          	slli	a5,a5,0x2
    1314:	6d068693          	addi	a3,a3,1744 # 36d0 <__clz_tab+0x12c>
    1318:	00d787b3          	add	a5,a5,a3
    131c:	0007a783          	lw	a5,0(a5)
    1320:	00078067          	jr	a5
		conv->specifier_cat = SPECIFIER_SINT;
    1324:	04214783          	lbu	a5,66(sp)
    1328:	ff87f793          	andi	a5,a5,-8
    132c:	0017e793          	ori	a5,a5,1
		if (conv->length_mod == LENGTH_UPPER_L) {
    1330:	04015683          	lhu	a3,64(sp)
		conv->specifier_cat = SPECIFIER_UINT;
    1334:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    1338:	000087b7          	lui	a5,0x8
    133c:	80078793          	addi	a5,a5,-2048 # 7800 <__data_region_end+0x2fc4>
    1340:	00f6f7b3          	and	a5,a3,a5
    1344:	01079793          	slli	a5,a5,0x10
    1348:	0107d793          	srli	a5,a5,0x10
    134c:	00004637          	lui	a2,0x4
    1350:	00c79663          	bne	a5,a2,135c <__kernel_ram_size+0x3d0>
			conv->invalid = true;
    1354:	0016e693          	ori	a3,a3,1
    1358:	04d11023          	sh	a3,64(sp)
		if (conv->specifier == 'c') {
    135c:	06300693          	li	a3,99
	bool unsupported = false;
    1360:	00000793          	li	a5,0
		if (conv->specifier == 'c') {
    1364:	e6d718e3          	bne	a4,a3,11d4 <__kernel_ram_size+0x248>
		if (conv->length_mod != LENGTH_NONE) {
    1368:	04015703          	lhu	a4,64(sp)
    136c:	000087b7          	lui	a5,0x8
    1370:	80078793          	addi	a5,a5,-2048 # 7800 <__data_region_end+0x2fc4>
    1374:	00e7f7b3          	and	a5,a5,a4
    1378:	00f037b3          	snez	a5,a5
    137c:	e59ff06f          	j	11d4 <__kernel_ram_size+0x248>
		conv->specifier_cat = SPECIFIER_UINT;
    1380:	04214783          	lbu	a5,66(sp)
    1384:	ff87f793          	andi	a5,a5,-8
    1388:	0027e793          	ori	a5,a5,2
    138c:	fa5ff06f          	j	1330 <__kernel_ram_size+0x3a4>
		conv->specifier_cat = SPECIFIER_PTR;
    1390:	04214783          	lbu	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    1394:	04015703          	lhu	a4,64(sp)
		conv->specifier_cat = SPECIFIER_PTR;
    1398:	ff87f793          	andi	a5,a5,-8
    139c:	0037e793          	ori	a5,a5,3
    13a0:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    13a4:	000087b7          	lui	a5,0x8
    13a8:	80078793          	addi	a5,a5,-2048 # 7800 <__data_region_end+0x2fc4>
    13ac:	00e7f7b3          	and	a5,a5,a4
    13b0:	ffffc737          	lui	a4,0xffffc
    13b4:	00e787b3          	add	a5,a5,a4
    13b8:	0017b793          	seqz	a5,a5
    13bc:	e19ff06f          	j	11d4 <__kernel_ram_size+0x248>
		conv->specifier_cat = SPECIFIER_PTR;
    13c0:	04214783          	lbu	a5,66(sp)
    13c4:	ff87f793          	andi	a5,a5,-8
    13c8:	0037e793          	ori	a5,a5,3
    13cc:	04f10123          	sb	a5,66(sp)
    13d0:	f99ff06f          	j	1368 <__kernel_ram_size+0x3dc>
		conv->invalid = true;
    13d4:	04015783          	lhu	a5,64(sp)
    13d8:	0017e793          	ori	a5,a5,1
    13dc:	04f11023          	sh	a5,64(sp)
	bool unsupported = false;
    13e0:	00000793          	li	a5,0
		break;
    13e4:	df1ff06f          	j	11d4 <__kernel_ram_size+0x248>
		} else if (conv->width_present) {
    13e8:	0807f793          	andi	a5,a5,128
    13ec:	00078863          	beqz	a5,13fc <__kernel_ram_size+0x470>
			width = conv->width_value;
    13f0:	04412483          	lw	s1,68(sp)
    13f4:	000c8413          	mv	s0,s9
    13f8:	ad1ff06f          	j	ec8 <cbvprintf+0xf8>
    13fc:	000c8413          	mv	s0,s9
		int width = -1;
    1400:	fff00493          	li	s1,-1
    1404:	ac5ff06f          	j	ec8 <cbvprintf+0xf8>
		} else if (conv->prec_present) {
    1408:	20077713          	andi	a4,a4,512
		int precision = -1;
    140c:	fff00a93          	li	s5,-1
		} else if (conv->prec_present) {
    1410:	ac070ee3          	beqz	a4,eec <cbvprintf+0x11c>
			precision = conv->prec_value;
    1414:	04812a83          	lw	s5,72(sp)
    1418:	ad5ff06f          	j	eec <cbvprintf+0x11c>
					value->sint = va_arg(ap, long);
    141c:	00440513          	addi	a0,s0,4
					value->uint = (wchar_t)va_arg(ap,
    1420:	00042683          	lw	a3,0(s0)
    1424:	02d12823          	sw	a3,48(sp)
    1428:	41f6d693          	srai	a3,a3,0x1f
    142c:	01c0006f          	j	1448 <__kernel_ram_size+0x4bc>
					(sint_value_type)va_arg(ap, long long);
    1430:	00740413          	addi	s0,s0,7
    1434:	ff847413          	andi	s0,s0,-8
				value->sint =
    1438:	00042603          	lw	a2,0(s0)
    143c:	00442683          	lw	a3,4(s0)
					(sint_value_type)va_arg(ap, long long);
    1440:	00840513          	addi	a0,s0,8
				value->sint =
    1444:	02c12823          	sw	a2,48(sp)
    1448:	02d12a23          	sw	a3,52(sp)
					(uint_value_type)va_arg(ap, size_t);
    144c:	00050413          	mv	s0,a0
    1450:	b05ff06f          	j	f54 <cbvprintf+0x184>
			} else if (length_mod == LENGTH_H) {
    1454:	00200693          	li	a3,2
    1458:	aed71ee3          	bne	a4,a3,f54 <cbvprintf+0x184>
				value->sint = (short)value->sint;
    145c:	03011683          	lh	a3,48(sp)
    1460:	02d12823          	sw	a3,48(sp)
    1464:	41f6d693          	srai	a3,a3,0x1f
				value->dbl = va_arg(ap, double);
    1468:	02d12a23          	sw	a3,52(sp)
    146c:	ae9ff06f          	j	f54 <cbvprintf+0x184>
		} else if (specifier_cat == SPECIFIER_UINT) {
    1470:	00200513          	li	a0,2
    1474:	06a69463          	bne	a3,a0,14dc <__kernel_ram_size+0x550>
			switch (length_mod) {
    1478:	00500693          	li	a3,5
    147c:	fad70ae3          	beq	a4,a3,1430 <__kernel_ram_size+0x4a4>
    1480:	00e6ea63          	bltu	a3,a4,1494 <__kernel_ram_size+0x508>
    1484:	00300693          	li	a3,3
    1488:	02d70a63          	beq	a4,a3,14bc <__kernel_ram_size+0x530>
    148c:	00400693          	li	a3,4
    1490:	fad700e3          	beq	a4,a3,1430 <__kernel_ram_size+0x4a4>
					(uint_value_type)va_arg(ap, size_t);
    1494:	00042683          	lw	a3,0(s0)
    1498:	02012a23          	sw	zero,52(sp)
    149c:	00440413          	addi	s0,s0,4
    14a0:	02d12823          	sw	a3,48(sp)
			if (length_mod == LENGTH_HH) {
    14a4:	00100693          	li	a3,1
    14a8:	aad700e3          	beq	a4,a3,f48 <cbvprintf+0x178>
			} else if (length_mod == LENGTH_H) {
    14ac:	00200693          	li	a3,2
    14b0:	aad712e3          	bne	a4,a3,f54 <cbvprintf+0x184>
				value->uint = (unsigned short)value->uint;
    14b4:	03015683          	lhu	a3,48(sp)
    14b8:	a95ff06f          	j	f4c <cbvprintf+0x17c>
				if ((!WCHAR_IS_SIGNED)
    14bc:	04314603          	lbu	a2,67(sp)
    14c0:	06300693          	li	a3,99
				value->sint = va_arg(ap, int);
    14c4:	00440513          	addi	a0,s0,4
				if ((!WCHAR_IS_SIGNED)
    14c8:	f4d60ce3          	beq	a2,a3,1420 <__kernel_ram_size+0x494>
					value->uint = va_arg(ap, unsigned long);
    14cc:	00042683          	lw	a3,0(s0)
    14d0:	02012a23          	sw	zero,52(sp)
    14d4:	02d12823          	sw	a3,48(sp)
    14d8:	f75ff06f          	j	144c <__kernel_ram_size+0x4c0>
		} else if (specifier_cat == SPECIFIER_FP) {
    14dc:	00400613          	li	a2,4
    14e0:	04c69a63          	bne	a3,a2,1534 <__kernel_ram_size+0x5a8>
			if (length_mod == LENGTH_UPPER_L) {
    14e4:	00800693          	li	a3,8
    14e8:	02d71863          	bne	a4,a3,1518 <__kernel_ram_size+0x58c>
				value->ldbl = va_arg(ap, long double);
    14ec:	00042683          	lw	a3,0(s0)
    14f0:	0006a803          	lw	a6,0(a3)
    14f4:	0046a503          	lw	a0,4(a3)
    14f8:	0086a603          	lw	a2,8(a3)
    14fc:	00c6a683          	lw	a3,12(a3)
    1500:	03012823          	sw	a6,48(sp)
    1504:	02a12a23          	sw	a0,52(sp)
    1508:	02c12c23          	sw	a2,56(sp)
    150c:	02d12e23          	sw	a3,60(sp)
			value->ptr = va_arg(ap, void *);
    1510:	00440413          	addi	s0,s0,4
    1514:	a41ff06f          	j	f54 <cbvprintf+0x184>
				value->dbl = va_arg(ap, double);
    1518:	00740693          	addi	a3,s0,7
    151c:	ff86f693          	andi	a3,a3,-8
    1520:	0006a603          	lw	a2,0(a3)
    1524:	00868413          	addi	s0,a3,8
    1528:	0046a683          	lw	a3,4(a3)
    152c:	02c12823          	sw	a2,48(sp)
    1530:	f39ff06f          	j	1468 <__kernel_ram_size+0x4dc>
		} else if (specifier_cat == SPECIFIER_PTR) {
    1534:	00300613          	li	a2,3
    1538:	a0c69ee3          	bne	a3,a2,f54 <cbvprintf+0x184>
			value->ptr = va_arg(ap, void *);
    153c:	00042683          	lw	a3,0(s0)
    1540:	02d12823          	sw	a3,48(sp)
    1544:	fcdff06f          	j	1510 <__kernel_ram_size+0x584>
		switch (conv->specifier) {
    1548:	04314683          	lbu	a3,67(sp)
    154c:	07800613          	li	a2,120
    1550:	92d664e3          	bltu	a2,a3,e78 <cbvprintf+0xa8>
    1554:	06200613          	li	a2,98
    1558:	00d66e63          	bltu	a2,a3,1574 <__kernel_ram_size+0x5e8>
    155c:	02500713          	li	a4,37
    1560:	02e68c63          	beq	a3,a4,1598 <__kernel_ram_size+0x60c>
    1564:	05800713          	li	a4,88
    1568:	90e698e3          	bne	a3,a4,e78 <cbvprintf+0xa8>
    156c:	00000b13          	li	s6,0
    1570:	2080006f          	j	1778 <__kernel_ram_size+0x7ec>
    1574:	f9d68693          	addi	a3,a3,-99
    1578:	0ff6f693          	andi	a3,a3,255
    157c:	01500613          	li	a2,21
    1580:	8ed66ce3          	bltu	a2,a3,e78 <cbvprintf+0xa8>
    1584:	00412783          	lw	a5,4(sp)
    1588:	00269693          	slli	a3,a3,0x2
    158c:	00f686b3          	add	a3,a3,a5
    1590:	0006a683          	lw	a3,0(a3)
    1594:	00068067          	jr	a3
			OUTC('%');
    1598:	00098593          	mv	a1,s3
    159c:	02500513          	li	a0,37
    15a0:	000900e7          	jalr	s2
    15a4:	2c054a63          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
    15a8:	001d8d93          	addi	s11,s11,1
			break;
    15ac:	8cdff06f          	j	e78 <cbvprintf+0xa8>
			bps = (const char *)value->ptr;
    15b0:	03012c83          	lw	s9,48(sp)
			if (precision >= 0) {
    15b4:	160ac063          	bltz	s5,1714 <__kernel_ram_size+0x788>
				len = strnlen(bps, precision);
    15b8:	000a8593          	mv	a1,s5
    15bc:	000c8513          	mv	a0,s9
    15c0:	474000ef          	jal	ra,1a34 <strnlen>
			bpe = bps + len;
    15c4:	00ac8d33          	add	s10,s9,a0
		char sign = 0;
    15c8:	00000b13          	li	s6,0
		if (bps == NULL) {
    15cc:	8a0c86e3          	beqz	s9,e78 <cbvprintf+0xa8>
		size_t nj_len = (bpe - bps);
    15d0:	419d07b3          	sub	a5,s10,s9
		if (sign != 0) {
    15d4:	000b0463          	beqz	s6,15dc <__kernel_ram_size+0x650>
			nj_len += 1U;
    15d8:	00178793          	addi	a5,a5,1
		if (conv->altform_0c) {
    15dc:	04214703          	lbu	a4,66(sp)
    15e0:	01077693          	andi	a3,a4,16
    15e4:	26068663          	beqz	a3,1850 <__kernel_ram_size+0x8c4>
			nj_len += 2U;
    15e8:	00278793          	addi	a5,a5,2
		nj_len += conv->pad0_value;
    15ec:	04412683          	lw	a3,68(sp)
		if (conv->pad_fp) {
    15f0:	04077713          	andi	a4,a4,64
		nj_len += conv->pad0_value;
    15f4:	00d787b3          	add	a5,a5,a3
		if (conv->pad_fp) {
    15f8:	00070663          	beqz	a4,1604 <__kernel_ram_size+0x678>
			nj_len += conv->pad0_pre_exp;
    15fc:	04812703          	lw	a4,72(sp)
    1600:	00e787b3          	add	a5,a5,a4
		if (width > 0) {
    1604:	04905c63          	blez	s1,165c <__kernel_ram_size+0x6d0>
			width -= (int)nj_len;
    1608:	40f484b3          	sub	s1,s1,a5
			if (!conv->flag_dash) {
    160c:	04012783          	lw	a5,64(sp)
    1610:	0027d793          	srli	a5,a5,0x2
    1614:	0017f793          	andi	a5,a5,1
    1618:	04079263          	bnez	a5,165c <__kernel_ram_size+0x6d0>
				if (conv->flag_zero) {
    161c:	04015783          	lhu	a5,64(sp)
    1620:	0407f793          	andi	a5,a5,64
    1624:	28078863          	beqz	a5,18b4 <__kernel_ram_size+0x928>
					if (sign != 0) {
    1628:	280b0a63          	beqz	s6,18bc <__kernel_ram_size+0x930>
						OUTC(sign);
    162c:	00098593          	mv	a1,s3
    1630:	000b0513          	mv	a0,s6
    1634:	000900e7          	jalr	s2
    1638:	24054063          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
    163c:	001d8d93          	addi	s11,s11,1
					pad = '0';
    1640:	03000793          	li	a5,48
						sign = 0;
    1644:	00000b13          	li	s6,0
    1648:	01b48ab3          	add	s5,s1,s11
    164c:	00048713          	mv	a4,s1
    1650:	409a8db3          	sub	s11,s5,s1
				while (width-- > 0) {
    1654:	fff48493          	addi	s1,s1,-1
    1658:	20e04463          	bgtz	a4,1860 <__kernel_ram_size+0x8d4>
		if (sign != 0) {
    165c:	000b0c63          	beqz	s6,1674 <__kernel_ram_size+0x6e8>
			OUTC(sign);
    1660:	00098593          	mv	a1,s3
    1664:	000b0513          	mv	a0,s6
    1668:	000900e7          	jalr	s2
    166c:	20054663          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
    1670:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c | conv->altform_0) {
    1674:	04012783          	lw	a5,64(sp)
    1678:	0147d713          	srli	a4,a5,0x14
    167c:	00177713          	andi	a4,a4,1
    1680:	00071863          	bnez	a4,1690 <__kernel_ram_size+0x704>
    1684:	0137d793          	srli	a5,a5,0x13
    1688:	0017f793          	andi	a5,a5,1
    168c:	00078c63          	beqz	a5,16a4 <__kernel_ram_size+0x718>
				OUTC('0');
    1690:	00098593          	mv	a1,s3
    1694:	03000513          	li	a0,48
    1698:	000900e7          	jalr	s2
    169c:	1c054e63          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
    16a0:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c) {
    16a4:	04214783          	lbu	a5,66(sp)
    16a8:	0107f793          	andi	a5,a5,16
    16ac:	00078c63          	beqz	a5,16c4 <__kernel_ram_size+0x738>
				OUTC(conv->specifier);
    16b0:	04314503          	lbu	a0,67(sp)
    16b4:	00098593          	mv	a1,s3
    16b8:	000900e7          	jalr	s2
    16bc:	1a054e63          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
    16c0:	001d8d93          	addi	s11,s11,1
			while (pad_len-- > 0) {
    16c4:	04412783          	lw	a5,68(sp)
    16c8:	01b78ab3          	add	s5,a5,s11
    16cc:	41ba8733          	sub	a4,s5,s11
    16d0:	1ee04a63          	bgtz	a4,18c4 <__kernel_ram_size+0x938>
			OUTS(bps, bpe);
    16d4:	000d0693          	mv	a3,s10
    16d8:	000c8613          	mv	a2,s9
    16dc:	00098593          	mv	a1,s3
    16e0:	00090513          	mv	a0,s2
    16e4:	e74ff0ef          	jal	ra,d58 <outs>
    16e8:	18054863          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
    16ec:	01b50db3          	add	s11,a0,s11
		while (width > 0) {
    16f0:	01b484b3          	add	s1,s1,s11
    16f4:	41b487b3          	sub	a5,s1,s11
    16f8:	f8f05063          	blez	a5,e78 <cbvprintf+0xa8>
			OUTC(' ');
    16fc:	00098593          	mv	a1,s3
    1700:	02000513          	li	a0,32
    1704:	000900e7          	jalr	s2
    1708:	16054863          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
    170c:	001d8d93          	addi	s11,s11,1
			--width;
    1710:	fe5ff06f          	j	16f4 <__kernel_ram_size+0x768>
				len = strlen(bps);
    1714:	000c8513          	mv	a0,s9
    1718:	2fc000ef          	jal	ra,1a14 <strlen>
    171c:	ea9ff06f          	j	15c4 <__kernel_ram_size+0x638>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    1720:	03012783          	lw	a5,48(sp)
			bps = buf;
    1724:	01810c93          	addi	s9,sp,24
			bpe = buf + 1;
    1728:	01910d13          	addi	s10,sp,25
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    172c:	00f10c23          	sb	a5,24(sp)
			break;
    1730:	00000b13          	li	s6,0
    1734:	e9dff06f          	j	15d0 <__kernel_ram_size+0x644>
			if (conv->flag_plus) {
    1738:	04015703          	lhu	a4,64(sp)
				sign = '+';
    173c:	02b00b13          	li	s6,43
			if (conv->flag_plus) {
    1740:	00877693          	andi	a3,a4,8
    1744:	00069663          	bnez	a3,1750 <__kernel_ram_size+0x7c4>
				sign = ' ';
    1748:	00171b13          	slli	s6,a4,0x1
    174c:	020b7b13          	andi	s6,s6,32
			sint = value->sint;
    1750:	03412703          	lw	a4,52(sp)
    1754:	03012683          	lw	a3,48(sp)
			if (sint < 0) {
    1758:	02075063          	bgez	a4,1778 <__kernel_ram_size+0x7ec>
				value->uint = (uint_value_type)-sint;
    175c:	40d00633          	neg	a2,a3
    1760:	40e00733          	neg	a4,a4
    1764:	00d036b3          	snez	a3,a3
    1768:	40d70733          	sub	a4,a4,a3
    176c:	02c12823          	sw	a2,48(sp)
    1770:	02e12a23          	sw	a4,52(sp)
				sign = '-';
    1774:	02d00b13          	li	s6,45
			bps = encode_uint(value->uint, conv, buf, bpe);
    1778:	03012503          	lw	a0,48(sp)
    177c:	03412583          	lw	a1,52(sp)
    1780:	02e10713          	addi	a4,sp,46
    1784:	01810693          	addi	a3,sp,24
    1788:	04010613          	addi	a2,sp,64
    178c:	c70ff0ef          	jal	ra,bfc <encode_uint>
    1790:	00050c93          	mv	s9,a0
			if (precision >= 0) {
    1794:	02e10d13          	addi	s10,sp,46
    1798:	e20acae3          	bltz	s5,15cc <__kernel_ram_size+0x640>
				conv->flag_zero = false;
    179c:	04015683          	lhu	a3,64(sp)
				size_t len = bpe - bps;
    17a0:	419d0733          	sub	a4,s10,s9
				conv->flag_zero = false;
    17a4:	fbf6f693          	andi	a3,a3,-65
    17a8:	04d11023          	sh	a3,64(sp)
				if (len < (size_t)precision) {
    17ac:	e35770e3          	bgeu	a4,s5,15cc <__kernel_ram_size+0x640>
					conv->pad0_value = precision - (int)len;
    17b0:	40ea87b3          	sub	a5,s5,a4
    17b4:	04f12223          	sw	a5,68(sp)
    17b8:	e15ff06f          	j	15cc <__kernel_ram_size+0x640>
			if (value->ptr != NULL) {
    17bc:	03012503          	lw	a0,48(sp)
    17c0:	08050263          	beqz	a0,1844 <__kernel_ram_size+0x8b8>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    17c4:	02e10713          	addi	a4,sp,46
    17c8:	01810693          	addi	a3,sp,24
    17cc:	04010613          	addi	a2,sp,64
    17d0:	00000593          	li	a1,0
    17d4:	c28ff0ef          	jal	ra,bfc <encode_uint>
				conv->altform_0c = true;
    17d8:	04215703          	lhu	a4,66(sp)
    17dc:	000086b7          	lui	a3,0x8
    17e0:	81068693          	addi	a3,a3,-2032 # 7810 <__data_region_end+0x2fd4>
    17e4:	0ef77713          	andi	a4,a4,239
    17e8:	00d76733          	or	a4,a4,a3
				bps = encode_uint((uintptr_t)value->ptr, conv,
    17ec:	00050c93          	mv	s9,a0
				conv->altform_0c = true;
    17f0:	04e11123          	sh	a4,66(sp)
		char sign = 0;
    17f4:	00000b13          	li	s6,0
				goto prec_int_pad0;
    17f8:	f9dff06f          	j	1794 <__kernel_ram_size+0x808>
	switch ((enum length_mod_enum)conv->length_mod) {
    17fc:	00700693          	li	a3,7
				store_count(conv, value->ptr, count);
    1800:	03012783          	lw	a5,48(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
    1804:	e6e6ea63          	bltu	a3,a4,e78 <cbvprintf+0xa8>
    1808:	00812683          	lw	a3,8(sp)
    180c:	00271713          	slli	a4,a4,0x2
    1810:	00d70733          	add	a4,a4,a3
    1814:	00072703          	lw	a4,0(a4) # ffffc000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffffc001>
    1818:	00070067          	jr	a4
		*(signed char *)dp = (signed char)count;
    181c:	01b78023          	sb	s11,0(a5)
		break;
    1820:	e58ff06f          	j	e78 <cbvprintf+0xa8>
		*(short *)dp = (short)count;
    1824:	01b79023          	sh	s11,0(a5)
		break;
    1828:	e50ff06f          	j	e78 <cbvprintf+0xa8>
		*(intmax_t *)dp = (intmax_t)count;
    182c:	41fdd713          	srai	a4,s11,0x1f
    1830:	01b7a023          	sw	s11,0(a5)
    1834:	00e7a223          	sw	a4,4(a5)
		break;
    1838:	e40ff06f          	j	e78 <cbvprintf+0xa8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    183c:	01b7a023          	sw	s11,0(a5)
		break;
    1840:	e38ff06f          	j	e78 <cbvprintf+0xa8>
			bps = "(nil)";
    1844:	000b8c93          	mv	s9,s7
			bpe = bps + 5;
    1848:	000c0d13          	mv	s10,s8
    184c:	ee5ff06f          	j	1730 <__kernel_ram_size+0x7a4>
		} else if (conv->altform_0) {
    1850:	00877693          	andi	a3,a4,8
    1854:	d8068ce3          	beqz	a3,15ec <__kernel_ram_size+0x660>
			nj_len += 1U;
    1858:	00178793          	addi	a5,a5,1
    185c:	d91ff06f          	j	15ec <__kernel_ram_size+0x660>
					OUTC(pad);
    1860:	00078513          	mv	a0,a5
    1864:	00098593          	mv	a1,s3
    1868:	00f12623          	sw	a5,12(sp)
    186c:	000900e7          	jalr	s2
    1870:	00c12783          	lw	a5,12(sp)
    1874:	dc055ce3          	bgez	a0,164c <__kernel_ram_size+0x6c0>
#undef OUTS
#undef OUTC
}
    1878:	08c12083          	lw	ra,140(sp)
    187c:	08812403          	lw	s0,136(sp)
    1880:	08412483          	lw	s1,132(sp)
    1884:	08012903          	lw	s2,128(sp)
    1888:	07c12983          	lw	s3,124(sp)
    188c:	07812a03          	lw	s4,120(sp)
    1890:	07412a83          	lw	s5,116(sp)
    1894:	07012b03          	lw	s6,112(sp)
    1898:	06c12b83          	lw	s7,108(sp)
    189c:	06812c03          	lw	s8,104(sp)
    18a0:	06412c83          	lw	s9,100(sp)
    18a4:	06012d03          	lw	s10,96(sp)
    18a8:	05c12d83          	lw	s11,92(sp)
    18ac:	09010113          	addi	sp,sp,144
    18b0:	00008067          	ret
				char pad = ' ';
    18b4:	02000793          	li	a5,32
    18b8:	d91ff06f          	j	1648 <__kernel_ram_size+0x6bc>
					pad = '0';
    18bc:	03000793          	li	a5,48
    18c0:	d89ff06f          	j	1648 <__kernel_ram_size+0x6bc>
				OUTC('0');
    18c4:	00098593          	mv	a1,s3
    18c8:	03000513          	li	a0,48
    18cc:	000900e7          	jalr	s2
    18d0:	fa0544e3          	bltz	a0,1878 <__kernel_ram_size+0x8ec>
    18d4:	001d8d93          	addi	s11,s11,1
    18d8:	df5ff06f          	j	16cc <__kernel_ram_size+0x740>

000018dc <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    18dc:	00008067          	ret

000018e0 <soc_interrupt_init>:
static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	unsigned int key;
	ulong_t mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
    18e0:	00800793          	li	a5,8
    18e4:	3007b7f3          	csrrc	a5,mstatus,a5
void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
    18e8:	30405073          	csrwi	mie,0
    18ec:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
    18f0:	00008067          	ret

000018f4 <fix_baud_rate>:
	*(volatile uint16_t *)addr = data;
}

static ALWAYS_INLINE uint32_t sys_read32(mem_addr_t addr)
{
	return *(volatile uint32_t *)addr;
    18f4:	800017b7          	lui	a5,0x80001
    18f8:	03c7a783          	lw	a5,60(a5) # 8000103c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000103d>

	/*
	 * calculate baud rate divisor. a variant of
	 * (uint32_t)(dev_cfg->sys_clk_freq / (16.0 * baud_rate) + 0.5)
	 */
	divisor = ((sys_clk_freq + (baud_rate << 3))
    18fc:	000e1737          	lui	a4,0xe1
	return *(volatile uint8_t *)addr;
    1900:	800026b7          	lui	a3,0x80002
    1904:	00e787b3          	add	a5,a5,a4
		   / baud_rate) >> 4;
    1908:	0001c737          	lui	a4,0x1c
    190c:	20070713          	addi	a4,a4,512 # 1c200 <__data_region_end+0x179c4>
    1910:	02e7d7b3          	divu	a5,a5,a4
    1914:	00c6c703          	lbu	a4,12(a3) # 8000200c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000200d>
	sys_write8((divisor >> 8) & 0xff, REG_BRDH);

	sys_write8(lcr_cache, REG_LCR);

	return 0;
}
    1918:	00000513          	li	a0,0
    191c:	0ff77613          	andi	a2,a4,255
	sys_write8(lcr_cache | LCR_DLAB, REG_LCR);
    1920:	f8076713          	ori	a4,a4,-128
    1924:	0ff77713          	andi	a4,a4,255
	*(volatile uint8_t *)addr = data;
    1928:	00e68623          	sb	a4,12(a3)
	divisor = ((sys_clk_freq + (baud_rate << 3))
    192c:	0047d713          	srli	a4,a5,0x4
	sys_write8( divisor       & 0xff, REG_BRDL);
    1930:	0ff77713          	andi	a4,a4,255
	sys_write8((divisor >> 8) & 0xff, REG_BRDH);
    1934:	00c7d793          	srli	a5,a5,0xc
    1938:	00e68023          	sb	a4,0(a3)
    193c:	0ff7f793          	andi	a5,a5,255
    1940:	00f68223          	sb	a5,4(a3)
    1944:	00c68623          	sb	a2,12(a3)
}
    1948:	00008067          	ret

0000194c <arch_cpu_idle>:
 */
static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	ulong_t mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
    194c:	00800793          	li	a5,8
    1950:	3007a7f3          	csrrs	a5,mstatus,a5
 */

void __weak arch_cpu_idle(void)
{
	irq_unlock(MSTATUS_IEN);
}
    1954:	00008067          	ret

00001958 <z_riscv_fatal_error>:
 #define NO_REG "                "
#endif

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
    1958:	ff010113          	addi	sp,sp,-16
    195c:	00112623          	sw	ra,12(sp)
		LOG_ERR("   mepc: " PR_REG, esf->mepc);
		LOG_ERR("mstatus: " PR_REG, esf->mstatus);
		LOG_ERR("");
	}

	z_fatal_error(reason, esf);
    1960:	25d000ef          	jal	ra,23bc <z_fatal_error>

00001964 <_Fault>:
		return "unknown";
	}
}

void _Fault(z_arch_esf_t *esf)
{
    1964:	ff010113          	addi	sp,sp,-16
    1968:	00112623          	sw	ra,12(sp)
    196c:	00050593          	mv	a1,a0
		}
	}
#endif /* CONFIG_USERSPACE */
	ulong_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
    1970:	342027f3          	csrr	a5,mcause

#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	ulong_t mtval;
	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
    1974:	343027f3          	csrr	a5,mtval
	z_fatal_error(reason, esf);
    1978:	00000513          	li	a0,0
    197c:	241000ef          	jal	ra,23bc <z_fatal_error>

00001980 <z_irq_spurious>:
#include <kernel_internal.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
    1980:	ff010113          	addi	sp,sp,-16
    1984:	00112623          	sw	ra,12(sp)
	ulong_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
    1988:	342027f3          	csrr	a5,mcause
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    198c:	00000593          	li	a1,0
    1990:	00100513          	li	a0,1
    1994:	fc5ff0ef          	jal	ra,1958 <z_riscv_fatal_error>

00001998 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
    1998:	ff010113          	addi	sp,sp,-16
    199c:	00112623          	sw	ra,12(sp)
	z_bss_zero();
    19a0:	351000ef          	jal	ra,24f0 <z_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
    19a4:	f3dff0ef          	jal	ra,18e0 <soc_interrupt_init>
#endif
#ifdef CONFIG_PMP_STACK_GUARD
	z_riscv_configure_interrupt_stack_guard();
#endif
	z_cstart();
    19a8:	369000ef          	jal	ra,2510 <z_cstart>

000019ac <__initialize>:
SECTION_FUNC(TEXT, __initialize)
	/*
	 * This will boot master core, just halt other cores.
	 * Note: need to be updated for complete SMP support
	 */
	csrr a0, mhartid
    19ac:	f1402573          	csrr	a0,mhartid
	beqz a0, boot_master_core
    19b0:	00050663          	beqz	a0,19bc <boot_master_core>

000019b4 <loop_slave_core>:

loop_slave_core:
	wfi
    19b4:	10500073          	wfi
	j loop_slave_core
    19b8:	ffdff06f          	j	19b4 <loop_slave_core>

000019bc <boot_master_core>:

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + CONFIG_ISR_STACK_SIZE
	 */
	la sp, z_interrupt_stacks
    19bc:	00002117          	auipc	sp,0x2
    19c0:	65410113          	addi	sp,sp,1620 # 4010 <z_interrupt_stacks>
	li t0, CONFIG_ISR_STACK_SIZE
    19c4:	000012b7          	lui	t0,0x1
    19c8:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
    19cc:	00510133          	add	sp,sp,t0

	csrw mscratch, sp
    19d0:	34011073          	csrw	mscratch,sp

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
    19d4:	fc5ff0ef          	jal	ra,1998 <_PrepC>

000019d8 <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
    19d8:	a00ff06f          	j	bd8 <z_thread_entry>

000019dc <arch_new_thread>:
#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	const struct soc_esf soc_esf_init = {SOC_ESF_INIT};
#endif

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)Z_STACK_PTR_ALIGN(
    19dc:	fb460613          	addi	a2,a2,-76 # 3fb4 <z_idle_stacks+0x1a4>
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
    19e0:	ff067613          	andi	a2,a2,-16
				);

	/* Setup the initial stack frame */
	stack_init->a0 = (ulong_t)entry;
	stack_init->a1 = (ulong_t)p1;
	stack_init->a2 = (ulong_t)p2;
    19e4:	02f62623          	sw	a5,44(a2)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = MSTATUS_DEF_RESTORE;
    19e8:	000027b7          	lui	a5,0x2
    19ec:	88078793          	addi	a5,a5,-1920 # 1880 <__kernel_ram_size+0x8f4>
    19f0:	04f62423          	sw	a5,72(a2)
#elif defined(CONFIG_FPU)
	/* Unshared FP mode: enable FPU of each thread. */
	stack_init->mstatus |= MSTATUS_FS_INIT;
#endif

	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
    19f4:	000027b7          	lui	a5,0x2
    19f8:	9d878793          	addi	a5,a5,-1576 # 19d8 <z_thread_entry_wrapper>
	stack_init->a0 = (ulong_t)entry;
    19fc:	02d62223          	sw	a3,36(a2)
	stack_init->a1 = (ulong_t)p1;
    1a00:	02e62423          	sw	a4,40(a2)
	stack_init->a3 = (ulong_t)p3;
    1a04:	03062823          	sw	a6,48(a2)
	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
    1a08:	04f62223          	sw	a5,68(a2)

#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	stack_init->soc_context = soc_esf_init;
#endif

	thread->callee_saved.sp = (ulong_t)stack_init;
    1a0c:	02c52823          	sw	a2,48(a0)
}
    1a10:	00008067          	ret

00001a14 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    1a14:	00050793          	mv	a5,a0
	size_t n = 0;
    1a18:	00000513          	li	a0,0

	while (*s != '\0') {
    1a1c:	00a78733          	add	a4,a5,a0
    1a20:	00074703          	lbu	a4,0(a4)
    1a24:	00071463          	bnez	a4,1a2c <strlen+0x18>
		s++;
		n++;
	}

	return n;
}
    1a28:	00008067          	ret
		n++;
    1a2c:	00150513          	addi	a0,a0,1
    1a30:	fedff06f          	j	1a1c <strlen+0x8>

00001a34 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    1a34:	00050793          	mv	a5,a0
	size_t n = 0;
    1a38:	00000513          	li	a0,0

	while (*s != '\0' && n < maxlen) {
    1a3c:	00a78733          	add	a4,a5,a0
    1a40:	00074703          	lbu	a4,0(a4)
    1a44:	00070463          	beqz	a4,1a4c <strnlen+0x18>
    1a48:	00b51463          	bne	a0,a1,1a50 <strnlen+0x1c>
		s++;
		n++;
	}

	return n;
}
    1a4c:	00008067          	ret
		n++;
    1a50:	00150513          	addi	a0,a0,1
    1a54:	fe9ff06f          	j	1a3c <strnlen+0x8>

00001a58 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    1a58:	0ff5f593          	andi	a1,a1,255
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    1a5c:	00c50633          	add	a2,a0,a2
	unsigned char *d_byte = (unsigned char *)buf;
    1a60:	00050793          	mv	a5,a0
	while (n > 0) {
    1a64:	00c79463          	bne	a5,a2,1a6c <memset+0x14>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    1a68:	00008067          	ret
		*(d_byte++) = c_byte;
    1a6c:	00178793          	addi	a5,a5,1
    1a70:	feb78fa3          	sb	a1,-1(a5)
		n--;
    1a74:	ff1ff06f          	j	1a64 <memset+0xc>

00001a78 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
    1a78:	fff00513          	li	a0,-1
    1a7c:	00008067          	ret

00001a80 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    1a80:	000057b7          	lui	a5,0x5
    1a84:	80a7aa23          	sw	a0,-2028(a5) # 4814 <_stdout_hook>
}
    1a88:	00008067          	ret

00001a8c <swerv_pic_init>:
	return *(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg);
}

static void swerv_pic_write(uint32_t reg, uint32_t val)
{
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1a8c:	f00c37b7          	lui	a5,0xf00c3
    1a90:	0007a023          	sw	zero,0(a5) # f00c3000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c3001>
    1a94:	f00c27b7          	lui	a5,0xf00c2
    1a98:	00478713          	addi	a4,a5,4 # f00c2004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c2005>

	/* Init priority order to 0, 0=lowest to 15=highest */
	swerv_pic_write(SWERV_PIC_mpiccfg, 0);

	/* Ensure that all interrupts are disabled initially */
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    1a9c:	12c78793          	addi	a5,a5,300
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1aa0:	00072023          	sw	zero,0(a4)
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    1aa4:	00470713          	addi	a4,a4,4
    1aa8:	fef71ce3          	bne	a4,a5,1aa0 <swerv_pic_init+0x14>
    1aac:	f00c07b7          	lui	a5,0xf00c0
    1ab0:	00478713          	addi	a4,a5,4 # f00c0004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c0005>
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1ab4:	00f00693          	li	a3,15
		swerv_pic_write(SWERV_PIC_meie(i), 0);
	}

	/* Set priority of each interrupt line to 0 initially */
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    1ab8:	12c78793          	addi	a5,a5,300
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1abc:	00d72023          	sw	a3,0(a4)
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    1ac0:	00470713          	addi	a4,a4,4
    1ac4:	fef71ce3          	bne	a4,a5,1abc <swerv_pic_init+0x30>
    1ac8:	f00c47b7          	lui	a5,0xf00c4
    1acc:	00478713          	addi	a4,a5,4 # f00c4004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c4005>
		swerv_pic_write(SWERV_PIC_meipl(i), 15);
	}

	/* Set property of each interrupt line to level-triggered/high */
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    1ad0:	12c78793          	addi	a5,a5,300
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1ad4:	00072023          	sw	zero,0(a4)
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    1ad8:	00470713          	addi	a4,a4,4
    1adc:	fef71ce3          	bne	a4,a5,1ad4 <swerv_pic_init+0x48>
    1ae0:	f00c57b7          	lui	a5,0xf00c5
    1ae4:	00478713          	addi	a4,a5,4 # f00c5004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c5005>
		swerv_pic_write(SWERV_PIC_meigwctrl(i), (0<<1)|(0<<0));
	}

	/* clear pending of each interrupt line */
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    1ae8:	12c78793          	addi	a5,a5,300
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1aec:	00072023          	sw	zero,0(a4)
	for (i = 1; i < SWERV_PIC_MAX_ID; i++) {
    1af0:	00470713          	addi	a4,a4,4
    1af4:	fef71ce3          	bne	a4,a5,1aec <swerv_pic_init+0x60>
		swerv_pic_write(SWERV_PIC_meigwclr(i), 0);
	}

	/* No interrupts masked */
	__asm__ swerv_pic_writecsr(meipt, 0);
    1af8:	bc905073          	csrwi	0xbc9,0
	__asm__ swerv_pic_writecsr(meicidpl, 0);
    1afc:	bcb05073          	csrwi	0xbcb,0
	__asm__ swerv_pic_writecsr(meicurpl, 0);
    1b00:	bcc05073          	csrwi	0xbcc,0

	/*
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
    1b04:	000017b7          	lui	a5,0x1
    1b08:	80078793          	addi	a5,a5,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
    1b0c:	3047a7f3          	csrrs	a5,mie,a5
}
    1b10:	00000513          	li	a0,0
    1b14:	00008067          	ret

00001b18 <swerv_pic_irq_handler>:
{
    1b18:	ff010113          	addi	sp,sp,-16
    1b1c:	00112623          	sw	ra,12(sp)
    1b20:	00812423          	sw	s0,8(sp)
	__asm__ swerv_pic_writecsr(meicpct, 0);
    1b24:	bca05073          	csrwi	0xbca,0
	__asm__ swerv_pic_readcsr(meihap, tmp);
    1b28:	fc802473          	csrr	s0,0xfc8
	irq = (tmp >> 2) & 0xff;
    1b2c:	00245413          	srli	s0,s0,0x2
    1b30:	0ff47413          	andi	s0,s0,255
	save_irq = irq;
    1b34:	000047b7          	lui	a5,0x4
    1b38:	8c87a423          	sw	s0,-1848(a5) # 38c8 <save_irq>
	if (irq == 0U || irq >= 64) {
    1b3c:	fff40713          	addi	a4,s0,-1
    1b40:	03e00793          	li	a5,62
    1b44:	00e7f663          	bgeu	a5,a4,1b50 <swerv_pic_irq_handler+0x38>
		z_irq_spurious(NULL);
    1b48:	00000513          	li	a0,0
    1b4c:	e35ff0ef          	jal	ra,1980 <z_irq_spurious>
	irq += RISCV_MAX_GENERIC_IRQ;
    1b50:	00b40713          	addi	a4,s0,11
	if (ite->isr)
    1b54:	000037b7          	lui	a5,0x3
    1b58:	00371713          	slli	a4,a4,0x3
    1b5c:	38078793          	addi	a5,a5,896 # 3380 <_sw_isr_table>
    1b60:	00e787b3          	add	a5,a5,a4
    1b64:	0047a703          	lw	a4,4(a5)
    1b68:	00070663          	beqz	a4,1b74 <swerv_pic_irq_handler+0x5c>
		ite->isr(ite->arg);
    1b6c:	0007a503          	lw	a0,0(a5)
    1b70:	000700e7          	jalr	a4
	swerv_pic_write(SWERV_PIC_meigwclr(irq), 0);
    1b74:	000017b7          	lui	a5,0x1
    1b78:	40b78793          	addi	a5,a5,1035 # 140b <__kernel_ram_size+0x47f>
    1b7c:	00f40433          	add	s0,s0,a5
    1b80:	00241413          	slli	s0,s0,0x2
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1b84:	f00c07b7          	lui	a5,0xf00c0
    1b88:	00f40433          	add	s0,s0,a5
}
    1b8c:	00c12083          	lw	ra,12(sp)
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1b90:	00042023          	sw	zero,0(s0)
}
    1b94:	00812403          	lw	s0,8(sp)
    1b98:	01010113          	addi	sp,sp,16
    1b9c:	00008067          	ret

00001ba0 <swerv_pic_irq_enable>:
	if ((irq >= SWERV_PIC_MAX_ID) || (irq < RISCV_MAX_GENERIC_IRQ)) {
    1ba0:	ff550713          	addi	a4,a0,-11
    1ba4:	03f00793          	li	a5,63
    1ba8:	02e7e663          	bltu	a5,a4,1bd4 <swerv_pic_irq_enable+0x34>
	__asm__ volatile ("csrrc %0, mstatus, %1"
    1bac:	00800793          	li	a5,8
    1bb0:	3007b7f3          	csrrc	a5,mstatus,a5
	swerv_pic_write(SWERV_PIC_meie(irq - RISCV_MAX_GENERIC_IRQ), 1);
    1bb4:	7f550513          	addi	a0,a0,2037
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1bb8:	f00c0737          	lui	a4,0xf00c0
	swerv_pic_write(SWERV_PIC_meie(irq - RISCV_MAX_GENERIC_IRQ), 1);
    1bbc:	00251513          	slli	a0,a0,0x2
	*(volatile uint32_t *)(DT_INST_REG_ADDR(0) + reg) = val;
    1bc0:	00e50533          	add	a0,a0,a4
    1bc4:	00100713          	li	a4,1
    1bc8:	00e52023          	sw	a4,0(a0)
	key = (mstatus & MSTATUS_IEN);
    1bcc:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    1bd0:	3007a7f3          	csrrs	a5,mstatus,a5
}
    1bd4:	00008067          	ret

00001bd8 <arch_irq_enable>:
	if (irq > RISCV_MAX_GENERIC_IRQ) {
    1bd8:	00b00793          	li	a5,11
    1bdc:	00a7f463          	bgeu	a5,a0,1be4 <arch_irq_enable+0xc>
		swerv_pic_irq_enable(irq);
    1be0:	fc1ff06f          	j	1ba0 <swerv_pic_irq_enable>
			  : "=r" (mie)
			  : "r" (1 << irq));
    1be4:	00100793          	li	a5,1
    1be8:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
    1bec:	30452573          	csrrs	a0,mie,a0
}
    1bf0:	00008067          	ret

00001bf4 <uart_console_init>:
{

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    1bf4:	00003537          	lui	a0,0x3
{
    1bf8:	ff010113          	addi	sp,sp,-16
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    1bfc:	33850713          	addi	a4,a0,824 # 3338 <__device_dts_ord_11>
    1c00:	000047b7          	lui	a5,0x4
{
    1c04:	00112623          	sw	ra,12(sp)
    1c08:	00812423          	sw	s0,8(sp)
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    1c0c:	8ce7a623          	sw	a4,-1844(a5) # 38cc <uart_console_dev>
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    1c10:	33850513          	addi	a0,a0,824
    1c14:	76c000ef          	jal	ra,2380 <z_device_ready>
    1c18:	fed00793          	li	a5,-19
    1c1c:	00050e63          	beqz	a0,1c38 <uart_console_init+0x44>
	__stdout_hook_install(console_out);
    1c20:	00002437          	lui	s0,0x2
    1c24:	c4c40513          	addi	a0,s0,-948 # 1c4c <console_out>
    1c28:	e59ff0ef          	jal	ra,1a80 <__stdout_hook_install>
	__printk_hook_install(console_out);
    1c2c:	c4c40513          	addi	a0,s0,-948
    1c30:	f31fe0ef          	jal	ra,b60 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
    1c34:	00000793          	li	a5,0
}
    1c38:	00c12083          	lw	ra,12(sp)
    1c3c:	00812403          	lw	s0,8(sp)
    1c40:	00078513          	mv	a0,a5
    1c44:	01010113          	addi	sp,sp,16
    1c48:	00008067          	ret

00001c4c <console_out>:
{
    1c4c:	ff010113          	addi	sp,sp,-16
    1c50:	00812423          	sw	s0,8(sp)
    1c54:	00912223          	sw	s1,4(sp)
    1c58:	00112623          	sw	ra,12(sp)
    1c5c:	000044b7          	lui	s1,0x4
	if ('\n' == c) {
    1c60:	00a00793          	li	a5,10
{
    1c64:	00050413          	mv	s0,a0
    1c68:	8cc48493          	addi	s1,s1,-1844 # 38cc <uart_console_dev>
	if ('\n' == c) {
    1c6c:	00f51c63          	bne	a0,a5,1c84 <console_out+0x38>
		uart_poll_out(uart_console_dev, '\r');
    1c70:	0004a503          	lw	a0,0(s1)
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    1c74:	00852783          	lw	a5,8(a0)
    1c78:	00d00593          	li	a1,13
    1c7c:	0047a783          	lw	a5,4(a5)
    1c80:	000780e7          	jalr	a5
	uart_poll_out(uart_console_dev, c);
    1c84:	0004a503          	lw	a0,0(s1)
    1c88:	00852783          	lw	a5,8(a0)
    1c8c:	0ff47593          	andi	a1,s0,255
    1c90:	0047a783          	lw	a5,4(a5)
    1c94:	000780e7          	jalr	a5
}
    1c98:	00c12083          	lw	ra,12(sp)
    1c9c:	00040513          	mv	a0,s0
    1ca0:	00812403          	lw	s0,8(sp)
    1ca4:	00412483          	lw	s1,4(sp)
    1ca8:	01010113          	addi	sp,sp,16
    1cac:	00008067          	ret

00001cb0 <gpio_mmio32_config>:

static int gpio_mmio32_config(const struct device *dev,
			      gpio_pin_t pin, gpio_flags_t flags)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    1cb0:	01052783          	lw	a5,16(a0)
    1cb4:	0047a683          	lw	a3,4(a5)

	if ((config->mask & (1 << pin)) == 0) {
    1cb8:	00100793          	li	a5,1
    1cbc:	00b795b3          	sll	a1,a5,a1
    1cc0:	0086a783          	lw	a5,8(a3)
    1cc4:	00f5f7b3          	and	a5,a1,a5
    1cc8:	06078c63          	beqz	a5,1d40 <gpio_mmio32_config+0x90>
		return -EINVAL; /* Pin not in our validity mask */
	}

	if (flags & ~(GPIO_INPUT | GPIO_OUTPUT |
    1ccc:	fffff7b7          	lui	a5,0xfffff
    1cd0:	0fe78793          	addi	a5,a5,254 # fffff0fe <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffff0ff>
    1cd4:	00f677b3          	and	a5,a2,a5
		      GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH |
		      GPIO_ACTIVE_LOW)) {
		/* We ignore direction and fake polarity, rest is unsupported */
		return -ENOTSUP;
    1cd8:	f7a00513          	li	a0,-134
	if (flags & ~(GPIO_INPUT | GPIO_OUTPUT |
    1cdc:	06079463          	bnez	a5,1d44 <gpio_mmio32_config+0x94>
	}

	if ((flags & GPIO_OUTPUT) != 0) {
    1ce0:	20067793          	andi	a5,a2,512
			*reg = (*reg & (config->mask & ~(1 << pin)));
		}
		irq_unlock(key);
	}

	return 0;
    1ce4:	00000513          	li	a0,0
	if ((flags & GPIO_OUTPUT) != 0) {
    1ce8:	04078e63          	beqz	a5,1d44 <gpio_mmio32_config+0x94>
		volatile uint32_t *reg = config->reg;
    1cec:	0046a703          	lw	a4,4(a3)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    1cf0:	00800793          	li	a5,8
    1cf4:	3007b7f3          	csrrc	a5,mstatus,a5
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    1cf8:	00b65513          	srli	a0,a2,0xb
    1cfc:	00157513          	andi	a0,a0,1
	key = (mstatus & MSTATUS_IEN);
    1d00:	0087f793          	andi	a5,a5,8
    1d04:	00050e63          	beqz	a0,1d20 <gpio_mmio32_config+0x70>
			*reg = (*reg | (1 << pin));
    1d08:	00072683          	lw	a3,0(a4) # f00c0000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf00c0001>
    1d0c:	00d5e5b3          	or	a1,a1,a3
			*reg = (*reg & (config->mask & ~(1 << pin)));
    1d10:	00b72023          	sw	a1,0(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    1d14:	3007a7f3          	csrrs	a5,mstatus,a5
	return 0;
    1d18:	00000513          	li	a0,0
			  : "=r" (mstatus)
			  : "r" (key & MSTATUS_IEN)
			  : "memory");
}
    1d1c:	00008067          	ret
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    1d20:	40067613          	andi	a2,a2,1024
    1d24:	fe0608e3          	beqz	a2,1d14 <gpio_mmio32_config+0x64>
			*reg = (*reg & (config->mask & ~(1 << pin)));
    1d28:	0086a683          	lw	a3,8(a3)
    1d2c:	00072603          	lw	a2,0(a4)
    1d30:	fff5c593          	not	a1,a1
    1d34:	00d5f5b3          	and	a1,a1,a3
    1d38:	00c5f5b3          	and	a1,a1,a2
    1d3c:	fd5ff06f          	j	1d10 <gpio_mmio32_config+0x60>
		return -EINVAL; /* Pin not in our validity mask */
    1d40:	fea00513          	li	a0,-22
}
    1d44:	00008067          	ret

00001d48 <gpio_mmio32_port_get_raw>:

static int gpio_mmio32_port_get_raw(const struct device *dev, uint32_t *value)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    1d48:	01052783          	lw	a5,16(a0)

	*value = *config->reg & config->mask;

	return 0;
}
    1d4c:	00000513          	li	a0,0
	const struct gpio_mmio32_config *config = context->config;
    1d50:	0047a703          	lw	a4,4(a5)
	*value = *config->reg & config->mask;
    1d54:	00472783          	lw	a5,4(a4)
    1d58:	0007a683          	lw	a3,0(a5)
    1d5c:	00872783          	lw	a5,8(a4)
    1d60:	00d7f7b3          	and	a5,a5,a3
    1d64:	00f5a023          	sw	a5,0(a1)
}
    1d68:	00008067          	ret

00001d6c <gpio_mmio32_port_set_masked_raw>:
static int gpio_mmio32_port_set_masked_raw(const struct device *dev,
					   uint32_t mask,
					   uint32_t value)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    1d6c:	01052783          	lw	a5,16(a0)
    1d70:	0047a783          	lw	a5,4(a5)
	volatile uint32_t *reg = config->reg;
    1d74:	0047a703          	lw	a4,4(a5)
	unsigned int key;

	mask &= config->mask;
    1d78:	0087a783          	lw	a5,8(a5)
    1d7c:	00f5f5b3          	and	a1,a1,a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
    1d80:	00800793          	li	a5,8
    1d84:	3007b7f3          	csrrc	a5,mstatus,a5
	value &= mask;

	/* Update pin state atomically */
	key = irq_lock();
	*reg = (*reg & ~mask) | value;
    1d88:	00072683          	lw	a3,0(a4)
	key = (mstatus & MSTATUS_IEN);
    1d8c:	0087f793          	andi	a5,a5,8
    1d90:	00c6c633          	xor	a2,a3,a2
    1d94:	00b67633          	and	a2,a2,a1
    1d98:	00d64633          	xor	a2,a2,a3
    1d9c:	00c72023          	sw	a2,0(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    1da0:	3007a7f3          	csrrs	a5,mstatus,a5
	irq_unlock(key);

	return 0;
}
    1da4:	00000513          	li	a0,0
    1da8:	00008067          	ret

00001dac <gpio_mmio32_port_set_bits_raw>:

static int gpio_mmio32_port_set_bits_raw(const struct device *dev,
					 uint32_t mask)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    1dac:	01052783          	lw	a5,16(a0)
    1db0:	0047a783          	lw	a5,4(a5)
	volatile uint32_t *reg = config->reg;
	unsigned int key;

	mask &= config->mask;
    1db4:	0087a703          	lw	a4,8(a5)
	volatile uint32_t *reg = config->reg;
    1db8:	0047a683          	lw	a3,4(a5)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    1dbc:	00800793          	li	a5,8
	mask &= config->mask;
    1dc0:	00e5f733          	and	a4,a1,a4
    1dc4:	3007b7f3          	csrrc	a5,mstatus,a5

	/* Update pin state atomically */
	key = irq_lock();
	*reg = (*reg | mask);
    1dc8:	0006a583          	lw	a1,0(a3)
	key = (mstatus & MSTATUS_IEN);
    1dcc:	0087f793          	andi	a5,a5,8
    1dd0:	00e5e5b3          	or	a1,a1,a4
    1dd4:	00b6a023          	sw	a1,0(a3)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    1dd8:	3007a7f3          	csrrs	a5,mstatus,a5
	irq_unlock(key);

	return 0;
}
    1ddc:	00000513          	li	a0,0
    1de0:	00008067          	ret

00001de4 <gpio_mmio32_port_clear_bits_raw>:

static int gpio_mmio32_port_clear_bits_raw(const struct device *dev,
					   uint32_t mask)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    1de4:	01052783          	lw	a5,16(a0)
    1de8:	0047a783          	lw	a5,4(a5)
	volatile uint32_t *reg = config->reg;
    1dec:	0047a703          	lw	a4,4(a5)
	unsigned int key;

	mask &= config->mask;
    1df0:	0087a783          	lw	a5,8(a5)
    1df4:	00f5f5b3          	and	a1,a1,a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
    1df8:	00800793          	li	a5,8
    1dfc:	3007b7f3          	csrrc	a5,mstatus,a5

	/* Update pin state atomically */
	key = irq_lock();
	*reg = (*reg & ~mask);
    1e00:	00072683          	lw	a3,0(a4)
    1e04:	fff5c593          	not	a1,a1
	key = (mstatus & MSTATUS_IEN);
    1e08:	0087f793          	andi	a5,a5,8
    1e0c:	00d5f5b3          	and	a1,a1,a3
    1e10:	00b72023          	sw	a1,0(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    1e14:	3007a7f3          	csrrs	a5,mstatus,a5
	irq_unlock(key);

	return 0;
}
    1e18:	00000513          	li	a0,0
    1e1c:	00008067          	ret

00001e20 <gpio_mmio32_port_toggle_bits>:

static int gpio_mmio32_port_toggle_bits(const struct device *dev,
					uint32_t mask)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = context->config;
    1e20:	01052783          	lw	a5,16(a0)
    1e24:	0047a783          	lw	a5,4(a5)
	volatile uint32_t *reg = config->reg;
	unsigned int key;

	mask &= config->mask;
    1e28:	0087a703          	lw	a4,8(a5)
	volatile uint32_t *reg = config->reg;
    1e2c:	0047a683          	lw	a3,4(a5)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    1e30:	00800793          	li	a5,8
	mask &= config->mask;
    1e34:	00e5f733          	and	a4,a1,a4
    1e38:	3007b7f3          	csrrc	a5,mstatus,a5

	/* Update pin state atomically */
	key = irq_lock();
	*reg = (*reg ^ mask);
    1e3c:	0006a583          	lw	a1,0(a3)
	key = (mstatus & MSTATUS_IEN);
    1e40:	0087f793          	andi	a5,a5,8
    1e44:	00e5c5b3          	xor	a1,a1,a4
    1e48:	00b6a023          	sw	a1,0(a3)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    1e4c:	3007a7f3          	csrrs	a5,mstatus,a5
	irq_unlock(key);

	return 0;
}
    1e50:	00000513          	li	a0,0
    1e54:	00008067          	ret

00001e58 <gpio_mmio32_pin_interrupt_configure>:
static int gpio_mmio32_pin_interrupt_configure(const struct device *dev,
					       gpio_pin_t pin,
					       enum gpio_int_mode mode,
					       enum gpio_int_trig trig)
{
	if (mode != GPIO_INT_MODE_DISABLED) {
    1e58:	000027b7          	lui	a5,0x2
		return -ENOTSUP;
	}

	return 0;
    1e5c:	00000513          	li	a0,0
	if (mode != GPIO_INT_MODE_DISABLED) {
    1e60:	00f60463          	beq	a2,a5,1e68 <gpio_mmio32_pin_interrupt_configure+0x10>
		return -ENOTSUP;
    1e64:	f7a00513          	li	a0,-134
}
    1e68:	00008067          	ret

00001e6c <gpio_mmio32_init>:
int gpio_mmio32_init(const struct device *dev)
{
	struct gpio_mmio32_context *context = dev->data;
	const struct gpio_mmio32_config *config = dev->config;

	context->config = config;
    1e6c:	01052783          	lw	a5,16(a0)
    1e70:	00452703          	lw	a4,4(a0)

	return 0;
}
    1e74:	00000513          	li	a0,0
	context->config = config;
    1e78:	00e7a223          	sw	a4,4(a5) # 2004 <CONFIG_SRAM_SIZE+0x4>
}
    1e7c:	00008067          	ret

00001e80 <gpio_veerwolf_init>:
/* Driver functions */

static int gpio_veerwolf_init(const struct device *dev)
{
	return 0;
}
    1e80:	00000513          	li	a0,0
    1e84:	00008067          	ret

00001e88 <gpio_veerwolf_configure>:

static int gpio_veerwolf_configure(const struct device *dev,
				gpio_pin_t pin, gpio_flags_t flags)
{
	return 0;
}
    1e88:	00000513          	li	a0,0
    1e8c:	00008067          	ret

00001e90 <gpio_veerwolf_port_get_raw>:

static int gpio_veerwolf_port_get_raw(const struct device *dev,
				   gpio_port_value_t *value)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1e90:	00452783          	lw	a5,4(a0)

	*value = sys_read32(addr);
	return 0;
}
    1e94:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1e98:	0007a783          	lw	a5,0(a5)
	return *(volatile uint32_t *)addr;
    1e9c:	0007a783          	lw	a5,0(a5)
	*value = sys_read32(addr);
    1ea0:	00f5a023          	sw	a5,0(a1)
}
    1ea4:	00008067          	ret

00001ea8 <gpio_veerwolf_port_set_masked_raw>:

static int gpio_veerwolf_port_set_masked_raw(const struct device *dev,
					  gpio_port_pins_t mask,
					  gpio_port_value_t value)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1ea8:	00452783          	lw	a5,4(a0)
	port_val = sys_read32(addr);
	port_val = (port_val & ~mask) | (value & mask);
	sys_write32(port_val, addr);

	return 0;
}
    1eac:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1eb0:	0007a783          	lw	a5,0(a5)
    1eb4:	0007a703          	lw	a4,0(a5)
	port_val = (port_val & ~mask) | (value & mask);
    1eb8:	00e64633          	xor	a2,a2,a4
    1ebc:	00b67633          	and	a2,a2,a1
    1ec0:	00e64633          	xor	a2,a2,a4
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	*(volatile uint32_t *)addr = data;
    1ec4:	00c7a023          	sw	a2,0(a5)
}
    1ec8:	00008067          	ret

00001ecc <gpio_veerwolf_port_set_bits_raw>:

static int gpio_veerwolf_port_set_bits_raw(const struct device *dev,
					gpio_port_pins_t pins)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1ecc:	00452783          	lw	a5,4(a0)

	port_val = sys_read32(addr) | pins;
	sys_write32(port_val, addr);

	return 0;
}
    1ed0:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1ed4:	0007a783          	lw	a5,0(a5)
	return *(volatile uint32_t *)addr;
    1ed8:	0007a703          	lw	a4,0(a5)
	port_val = sys_read32(addr) | pins;
    1edc:	00e5e5b3          	or	a1,a1,a4
	*(volatile uint32_t *)addr = data;
    1ee0:	00b7a023          	sw	a1,0(a5)
}
    1ee4:	00008067          	ret

00001ee8 <gpio_veerwolf_port_clear_bits_raw>:

static int gpio_veerwolf_port_clear_bits_raw(const struct device *dev,
					  gpio_port_pins_t pins)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1ee8:	00452783          	lw	a5,4(a0)
	uint32_t port_val;

	port_val = sys_read32(addr) & ~pins;
    1eec:	fff5c593          	not	a1,a1
	sys_write32(port_val, addr);

	return 0;
}
    1ef0:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1ef4:	0007a783          	lw	a5,0(a5)
	return *(volatile uint32_t *)addr;
    1ef8:	0007a703          	lw	a4,0(a5)
	port_val = sys_read32(addr) & ~pins;
    1efc:	00e5f5b3          	and	a1,a1,a4
	*(volatile uint32_t *)addr = data;
    1f00:	00b7a023          	sw	a1,0(a5)
}
    1f04:	00008067          	ret

00001f08 <gpio_veerwolf_port_toggle_bits>:

static int gpio_veerwolf_port_toggle_bits(const struct device *dev,
				       gpio_port_pins_t pins)
{
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1f08:	00452783          	lw	a5,4(a0)

	port_val = sys_read32(addr) ^ pins;
	sys_write32(port_val, addr);

	return 0;
}
    1f0c:	00000513          	li	a0,0
	mem_addr_t addr = DEV_GPIO_ADDR(dev);
    1f10:	0007a783          	lw	a5,0(a5)
	return *(volatile uint32_t *)addr;
    1f14:	0007a703          	lw	a4,0(a5)
	port_val = sys_read32(addr) ^ pins;
    1f18:	00e5c5b3          	xor	a1,a1,a4
	*(volatile uint32_t *)addr = data;
    1f1c:	00b7a023          	sw	a1,0(a5)
}
    1f20:	00008067          	ret

00001f24 <gpio_veerwolf_pin_interrupt_configure>:
					      enum gpio_int_mode mode,
					      enum gpio_int_trig trig)
{
	int ret = 0;

	if (mode != GPIO_INT_MODE_DISABLED) {
    1f24:	000027b7          	lui	a5,0x2
	int ret = 0;
    1f28:	00000513          	li	a0,0
	if (mode != GPIO_INT_MODE_DISABLED) {
    1f2c:	00f60463          	beq	a2,a5,1f34 <gpio_veerwolf_pin_interrupt_configure+0x10>
		ret = -ENOTSUP;
    1f30:	f7a00513          	li	a0,-134
	}
	return ret;
}
    1f34:	00008067          	ret

00001f38 <uart_ns16550_configure>:
}

static int uart_ns16550_configure(const struct device *dev,
				  const struct uart_config *cfg)
{
	struct uart_ns16550_dev_data * const dev_data = DEV_DATA(dev);
    1f38:	01052883          	lw	a7,16(a0)
{
    1f3c:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
    1f40:	00800693          	li	a3,8
    1f44:	3006b6f3          	csrrc	a3,mstatus,a3
		OUTWORD(PCP(dev), pcp & ~PCP_UPDATE);
		OUTWORD(PCP(dev), pcp | PCP_UPDATE);
	}
#endif

	set_baud_rate(dev, cfg->baudrate);
    1f48:	0005a503          	lw	a0,0(a1)
	key = (mstatus & MSTATUS_IEN);
    1f4c:	0086f693          	andi	a3,a3,8
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
    1f50:	06050863          	beqz	a0,1fc0 <uart_ns16550_configure+0x88>
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
    1f54:	0047a603          	lw	a2,4(a5) # 2004 <CONFIG_SRAM_SIZE+0x4>
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
    1f58:	00462803          	lw	a6,4(a2)
    1f5c:	06080263          	beqz	a6,1fc0 <uart_ns16550_configure+0x88>
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
    1f60:	00351713          	slli	a4,a0,0x3
    1f64:	01070733          	add	a4,a4,a6
					/ baud_rate) >> 4;
    1f68:	02a75733          	divu	a4,a4,a0
		lcr_cache = INBYTE(LCR(dev));
    1f6c:	00062803          	lw	a6,0(a2)
	struct uart_ns16550_dev_data * const dev_data = DEV_DATA(dev);
    1f70:	0107a303          	lw	t1,16(a5)
	return *(volatile uint8_t *)addr;
    1f74:	00c84603          	lbu	a2,12(a6)
    1f78:	0ff67e13          	andi	t3,a2,255
		OUTBYTE(LCR(dev), LCR_DLAB | lcr_cache);
    1f7c:	f8066613          	ori	a2,a2,-128
    1f80:	0ff67613          	andi	a2,a2,255
	*(volatile uint8_t *)addr = data;
    1f84:	00c80623          	sb	a2,12(a6)
	return DEVICE_MMIO_GET(dev);
    1f88:	0047a803          	lw	a6,4(a5)
    1f8c:	00082803          	lw	a6,0(a6)
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
    1f90:	00475613          	srli	a2,a4,0x4
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
    1f94:	0ff67613          	andi	a2,a2,255
    1f98:	00c80023          	sb	a2,0(a6)
	return DEVICE_MMIO_GET(dev);
    1f9c:	0047a603          	lw	a2,4(a5)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
    1fa0:	00c75713          	srli	a4,a4,0xc
    1fa4:	0ff77713          	andi	a4,a4,255
    1fa8:	00062603          	lw	a2,0(a2)
    1fac:	00e60223          	sb	a4,4(a2)
	return DEVICE_MMIO_GET(dev);
    1fb0:	0047a703          	lw	a4,4(a5)
		OUTBYTE(LCR(dev), lcr_cache);
    1fb4:	00072703          	lw	a4,0(a4)
    1fb8:	01c70623          	sb	t3,12(a4)
		dev_data->uart_config.baudrate = baud_rate;
    1fbc:	00a32023          	sw	a0,0(t1)

	/* Local structure to hold temporary values to pass to OUTBYTE() */
	struct uart_config uart_cfg;

	switch (cfg->data_bits) {
    1fc0:	0065c603          	lbu	a2,6(a1)
    1fc4:	00300713          	li	a4,3
		break;
	case UART_CFG_DATA_BITS_8:
		uart_cfg.data_bits = LCR_CS8;
		break;
	default:
		ret = -ENOTSUP;
    1fc8:	f7a00513          	li	a0,-134
    1fcc:	08c76663          	bltu	a4,a2,2058 <CONFIG_SRAM_SIZE+0x58>
		goto out;
	}

	switch (cfg->stop_bits) {
    1fd0:	0055c803          	lbu	a6,5(a1)
    1fd4:	00100513          	li	a0,1
    1fd8:	08a80463          	beq	a6,a0,2060 <CONFIG_SRAM_SIZE+0x60>
    1fdc:	f7a00513          	li	a0,-134
    1fe0:	06e81c63          	bne	a6,a4,2058 <CONFIG_SRAM_SIZE+0x58>
    1fe4:	00400813          	li	a6,4
	default:
		ret = -ENOTSUP;
		goto out;
	}

	switch (cfg->parity) {
    1fe8:	0045c703          	lbu	a4,4(a1)
    1fec:	00070a63          	beqz	a4,2000 <CONFIG_SRAM_SIZE>
    1ff0:	00200313          	li	t1,2
    1ff4:	f7a00513          	li	a0,-134
    1ff8:	06671063          	bne	a4,t1,2058 <CONFIG_SRAM_SIZE+0x58>
    1ffc:	01000713          	li	a4,16
	default:
		ret = -ENOTSUP;
		goto out;
	}

	dev_data->uart_config = *cfg;
    2000:	0005a503          	lw	a0,0(a1)

	/* data bits, stop bits, parity, clear DLAB */
	OUTBYTE(LCR(dev),
    2004:	01066633          	or	a2,a2,a6
    2008:	00c76733          	or	a4,a4,a2
	return DEVICE_MMIO_GET(dev);
    200c:	0047a603          	lw	a2,4(a5)
	dev_data->uart_config = *cfg;
    2010:	00a8a023          	sw	a0,0(a7)
    2014:	0045a583          	lw	a1,4(a1)
	OUTBYTE(LCR(dev),
    2018:	00062603          	lw	a2,0(a2)
	int ret = 0;
    201c:	00000513          	li	a0,0
	dev_data->uart_config = *cfg;
    2020:	00b8a223          	sw	a1,4(a7)
    2024:	00e60623          	sb	a4,12(a2)
	return DEVICE_MMIO_GET(dev);
    2028:	0047a703          	lw	a4,4(a5)
    202c:	00b00613          	li	a2,11
	if (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS) {
		mdc |= MCR_AFCE;
	}
#endif

	OUTBYTE(MDC(dev), mdc);
    2030:	00072703          	lw	a4,0(a4)
    2034:	00c70823          	sb	a2,16(a4)
	return DEVICE_MMIO_GET(dev);
    2038:	0047a703          	lw	a4,4(a5)
    203c:	f8700613          	li	a2,-121
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
    2040:	00072703          	lw	a4,0(a4)
    2044:	00c70423          	sb	a2,8(a4)
	return DEVICE_MMIO_GET(dev);
    2048:	0047a783          	lw	a5,4(a5)
    204c:	0007a783          	lw	a5,0(a5)
	return *(volatile uint8_t *)addr;
    2050:	0007c703          	lbu	a4,0(a5)
	*(volatile uint8_t *)addr = data;
    2054:	00078223          	sb	zero,4(a5)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2058:	3006a6f3          	csrrs	a3,mstatus,a3
	OUTBYTE(IER(dev), 0x00);

out:
	k_spin_unlock(&dev_data->lock, key);
	return ret;
};
    205c:	00008067          	ret
		uart_cfg.stop_bits = LCR_1_STB;
    2060:	00000813          	li	a6,0
    2064:	f85ff06f          	j	1fe8 <uart_ns16550_configure+0xb0>

00002068 <uart_ns16550_config_get>:

#ifdef CONFIG_UART_USE_RUNTIME_CONFIGURE
static int uart_ns16550_config_get(const struct device *dev,
				   struct uart_config *cfg)
{
	struct uart_ns16550_dev_data *data = DEV_DATA(dev);
    2068:	01052783          	lw	a5,16(a0)
	cfg->stop_bits = data->uart_config.stop_bits;
	cfg->data_bits = data->uart_config.data_bits;
	cfg->flow_ctrl = data->uart_config.flow_ctrl;

	return 0;
}
    206c:	00000513          	li	a0,0
	cfg->baudrate = data->uart_config.baudrate;
    2070:	0007a703          	lw	a4,0(a5)
    2074:	00e5a023          	sw	a4,0(a1)
	cfg->parity = data->uart_config.parity;
    2078:	0047c703          	lbu	a4,4(a5)
    207c:	00e58223          	sb	a4,4(a1)
	cfg->stop_bits = data->uart_config.stop_bits;
    2080:	0057c703          	lbu	a4,5(a5)
    2084:	00e582a3          	sb	a4,5(a1)
	cfg->data_bits = data->uart_config.data_bits;
    2088:	0067c703          	lbu	a4,6(a5)
    208c:	00e58323          	sb	a4,6(a1)
	cfg->flow_ctrl = data->uart_config.flow_ctrl;
    2090:	0077c783          	lbu	a5,7(a5)
    2094:	00f583a3          	sb	a5,7(a1)
}
    2098:	00008067          	ret

0000209c <uart_ns16550_init>:
 */
static int uart_ns16550_init(const struct device *dev)
{
	int ret;

	ret = uart_ns16550_configure(dev, &DEV_DATA(dev)->uart_config);
    209c:	01052583          	lw	a1,16(a0)
    20a0:	e99ff06f          	j	1f38 <uart_ns16550_configure>

000020a4 <uart_ns16550_poll_in>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    20a4:	00800793          	li	a5,8
    20a8:	3007b7f3          	csrrc	a5,mstatus,a5
	return DEVICE_MMIO_GET(dev);
    20ac:	00452703          	lw	a4,4(a0)
	key = (mstatus & MSTATUS_IEN);
    20b0:	0087f793          	andi	a5,a5,8
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(const struct device *dev, unsigned char *c)
{
	int ret = -1;
    20b4:	fff00513          	li	a0,-1
	return DEVICE_MMIO_GET(dev);
    20b8:	00072683          	lw	a3,0(a4)
	return *(volatile uint8_t *)addr;
    20bc:	0146c703          	lbu	a4,20(a3)
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	if ((INBYTE(LSR(dev)) & LSR_RXRDY) != 0) {
    20c0:	00177713          	andi	a4,a4,1
    20c4:	00070863          	beqz	a4,20d4 <uart_ns16550_poll_in+0x30>
    20c8:	0006c703          	lbu	a4,0(a3)
		/* got a character */
		*c = INBYTE(RDR(dev));
		ret = 0;
    20cc:	00000513          	li	a0,0
		*c = INBYTE(RDR(dev));
    20d0:	00e58023          	sb	a4,0(a1)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    20d4:	3007a7f3          	csrrs	a5,mstatus,a5
	}

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return ret;
}
    20d8:	00008067          	ret

000020dc <uart_ns16550_poll_out>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    20dc:	00800793          	li	a5,8
    20e0:	3007b7f3          	csrrc	a5,mstatus,a5
	return DEVICE_MMIO_GET(dev);
    20e4:	00452703          	lw	a4,4(a0)
	key = (mstatus & MSTATUS_IEN);
    20e8:	0087f793          	andi	a5,a5,8
    20ec:	00072683          	lw	a3,0(a4)
static void uart_ns16550_poll_out(const struct device *dev,
					   unsigned char c)
{
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0) {
    20f0:	01468613          	addi	a2,a3,20
    20f4:	00064703          	lbu	a4,0(a2)
    20f8:	02077713          	andi	a4,a4,32
    20fc:	fe070ce3          	beqz	a4,20f4 <uart_ns16550_poll_out+0x18>
	*(volatile uint8_t *)addr = data;
    2100:	00b68023          	sb	a1,0(a3)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2104:	3007a7f3          	csrrs	a5,mstatus,a5
	}

	OUTBYTE(THR(dev), c);

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
}
    2108:	00008067          	ret

0000210c <uart_ns16550_err_check>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    210c:	00800793          	li	a5,8
    2110:	3007b7f3          	csrrc	a5,mstatus,a5
	return DEVICE_MMIO_GET(dev);
    2114:	00452703          	lw	a4,4(a0)
	key = (mstatus & MSTATUS_IEN);
    2118:	0087f793          	andi	a5,a5,8
 * UART_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(const struct device *dev)
{
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);
	int check = (INBYTE(LSR(dev)) & LSR_EOB_MASK);
    211c:	00072703          	lw	a4,0(a4)
	return *(volatile uint8_t *)addr;
    2120:	01474503          	lbu	a0,20(a4)
    2124:	0ff57513          	andi	a0,a0,255
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2128:	3007a7f3          	csrrs	a5,mstatus,a5
    212c:	01e57513          	andi	a0,a0,30

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return check >> 1;
}
    2130:	00155513          	srli	a0,a0,0x1
    2134:	00008067          	ret

00002138 <mtime>:
	volatile uint32_t *r = (uint32_t *)RISCV_MTIME_BASE;
	uint32_t lo, hi;

	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
    2138:	800017b7          	lui	a5,0x80001
    213c:	0247a703          	lw	a4,36(a5) # 80001024 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001025>
		lo = r[0];
    2140:	0207a503          	lw	a0,32(a5)
	} while (r[1] != hi);
    2144:	0247a583          	lw	a1,36(a5)
    2148:	fee59ae3          	bne	a1,a4,213c <mtime+0x4>

	return (((uint64_t)hi) << 32) | lo;
#endif
}
    214c:	00008067          	ret

00002150 <timer_isr>:

static void timer_isr(const void *arg)
{
    2150:	fe010113          	addi	sp,sp,-32
    2154:	01312623          	sw	s3,12(sp)
    2158:	00112e23          	sw	ra,28(sp)
    215c:	00812c23          	sw	s0,24(sp)
    2160:	00912a23          	sw	s1,20(sp)
    2164:	01212823          	sw	s2,16(sp)
    2168:	01412423          	sw	s4,8(sp)
    216c:	01512223          	sw	s5,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    2170:	00800993          	li	s3,8
    2174:	3009b9f3          	csrrc	s3,mstatus,s3
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = mtime();
    2178:	fc1ff0ef          	jal	ra,2138 <mtime>
	key = (mstatus & MSTATUS_IEN);
    217c:	0089f993          	andi	s3,s3,8
    2180:	00050a13          	mv	s4,a0
    2184:	00058913          	mv	s2,a1
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);

	last_count = now;
    2188:	00004437          	lui	s0,0x4
    218c:	8b040413          	addi	s0,s0,-1872 # 38b0 <last_count>
    2190:	00a42023          	sw	a0,0(s0)
    2194:	00b42223          	sw	a1,4(s0)

static inline int z_impl_sys_clock_hw_cycles_per_sec_runtime_get(void)
{
	extern int z_clock_hw_cycles_per_sec;

	return z_clock_hw_cycles_per_sec;
    2198:	00005ab7          	lui	s5,0x5

	if (!TICKLESS) {
		uint64_t next = last_count + CYC_PER_TICK;
    219c:	828aa503          	lw	a0,-2008(s5) # 4828 <z_clock_hw_cycles_per_sec>
    21a0:	00000693          	li	a3,0
    21a4:	06400613          	li	a2,100
    21a8:	41f55593          	srai	a1,a0,0x1f
    21ac:	944fe0ef          	jal	ra,2f0 <__udivdi3>
    21b0:	00042483          	lw	s1,0(s0)
    21b4:	00442783          	lw	a5,4(s0)
    21b8:	009504b3          	add	s1,a0,s1
    21bc:	00a4b433          	sltu	s0,s1,a0
    21c0:	00f40433          	add	s0,s0,a5

		if ((int64_t)(next - now) < MIN_DELAY) {
    21c4:	41448a33          	sub	s4,s1,s4
    21c8:	0144b5b3          	sltu	a1,s1,s4
    21cc:	41240933          	sub	s2,s0,s2
    21d0:	40b90933          	sub	s2,s2,a1
		uint64_t next = last_count + CYC_PER_TICK;
    21d4:	00048793          	mv	a5,s1
    21d8:	00040693          	mv	a3,s0
		if ((int64_t)(next - now) < MIN_DELAY) {
    21dc:	03204863          	bgtz	s2,220c <timer_isr+0xbc>
    21e0:	00091663          	bnez	s2,21ec <timer_isr+0x9c>
    21e4:	3e700713          	li	a4,999
    21e8:	03476263          	bltu	a4,s4,220c <timer_isr+0xbc>
			next += CYC_PER_TICK;
    21ec:	828aa503          	lw	a0,-2008(s5)
    21f0:	00000693          	li	a3,0
    21f4:	06400613          	li	a2,100
    21f8:	41f55593          	srai	a1,a0,0x1f
    21fc:	8f4fe0ef          	jal	ra,2f0 <__udivdi3>
    2200:	00a487b3          	add	a5,s1,a0
    2204:	0097b4b3          	sltu	s1,a5,s1
    2208:	008486b3          	add	a3,s1,s0
	r[1] = 0xffffffff;
    220c:	80001737          	lui	a4,0x80001
    2210:	fff00613          	li	a2,-1
    2214:	02c72623          	sw	a2,44(a4) # 8000102c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000102d>
	r[0] = (uint32_t)time;
    2218:	02f72423          	sw	a5,40(a4)
	r[1] = (uint32_t)(time >> 32);
    221c:	02d72623          	sw	a3,44(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2220:	3009a9f3          	csrrs	s3,mstatus,s3
		set_mtimecmp(next);
	}

	k_spin_unlock(&lock, key);
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
    2224:	01812403          	lw	s0,24(sp)
    2228:	01c12083          	lw	ra,28(sp)
    222c:	01412483          	lw	s1,20(sp)
    2230:	01012903          	lw	s2,16(sp)
    2234:	00c12983          	lw	s3,12(sp)
    2238:	00812a03          	lw	s4,8(sp)
    223c:	00412a83          	lw	s5,4(sp)
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    2240:	00100513          	li	a0,1
}
    2244:	02010113          	addi	sp,sp,32
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    2248:	7490006f          	j	3190 <sys_clock_announce>

0000224c <sys_clock_driver_init>:

int sys_clock_driver_init(const struct device *dev)
{
    224c:	ff010113          	addi	sp,sp,-16
    2250:	00812423          	sw	s0,8(sp)
	ARG_UNUSED(dev);

	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
	last_count = mtime();
    2254:	00004437          	lui	s0,0x4
{
    2258:	00112623          	sw	ra,12(sp)
	last_count = mtime();
    225c:	8b040413          	addi	s0,s0,-1872 # 38b0 <last_count>
    2260:	ed9ff0ef          	jal	ra,2138 <mtime>
    2264:	00a42023          	sw	a0,0(s0)
    2268:	00b42223          	sw	a1,4(s0)
    226c:	000057b7          	lui	a5,0x5
	set_mtimecmp(last_count + CYC_PER_TICK);
    2270:	8287a503          	lw	a0,-2008(a5) # 4828 <z_clock_hw_cycles_per_sec>
    2274:	06400613          	li	a2,100
    2278:	00000693          	li	a3,0
    227c:	41f55593          	srai	a1,a0,0x1f
    2280:	870fe0ef          	jal	ra,2f0 <__udivdi3>
    2284:	00042783          	lw	a5,0(s0)
    2288:	00442703          	lw	a4,4(s0)
	r[1] = 0xffffffff;
    228c:	fff00693          	li	a3,-1
	set_mtimecmp(last_count + CYC_PER_TICK);
    2290:	00f507b3          	add	a5,a0,a5
    2294:	00a7b533          	sltu	a0,a5,a0
    2298:	00e50533          	add	a0,a0,a4
	r[1] = 0xffffffff;
    229c:	80001737          	lui	a4,0x80001
    22a0:	02d72623          	sw	a3,44(a4) # 8000102c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000102d>
	r[0] = (uint32_t)time;
    22a4:	02f72423          	sw	a5,40(a4)
	r[1] = (uint32_t)(time >> 32);
    22a8:	02a72623          	sw	a0,44(a4)
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
    22ac:	00700513          	li	a0,7
    22b0:	929ff0ef          	jal	ra,1bd8 <arch_irq_enable>
	return 0;
}
    22b4:	00c12083          	lw	ra,12(sp)
    22b8:	00812403          	lw	s0,8(sp)
    22bc:	00000513          	li	a0,0
    22c0:	01010113          	addi	sp,sp,16
    22c4:	00008067          	ret

000022c8 <sys_clock_set_timeout>:
	}

	set_mtimecmp(cyc + last_count);
	k_spin_unlock(&lock, key);
#endif
}
    22c8:	00008067          	ret

000022cc <sys_clock_elapsed>:
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = ((uint32_t)mtime() - (uint32_t)last_count) / CYC_PER_TICK;

	k_spin_unlock(&lock, key);
	return ret;
}
    22cc:	00000513          	li	a0,0
    22d0:	00008067          	ret

000022d4 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
    22d4:	00008067          	ret

000022d8 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    22d8:	00251713          	slli	a4,a0,0x2
    22dc:	000047b7          	lui	a5,0x4
    22e0:	00150513          	addi	a0,a0,1
    22e4:	86478793          	addi	a5,a5,-1948 # 3864 <levels.0>
    22e8:	00251513          	slli	a0,a0,0x2
{
    22ec:	fe010113          	addi	sp,sp,-32
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    22f0:	00e78733          	add	a4,a5,a4
    22f4:	00a78533          	add	a0,a5,a0
{
    22f8:	00812c23          	sw	s0,24(sp)
    22fc:	01212823          	sw	s2,16(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    2300:	00072403          	lw	s0,0(a4)
    2304:	00052903          	lw	s2,0(a0)
{
    2308:	01312623          	sw	s3,12(sp)
    230c:	00112e23          	sw	ra,28(sp)
    2310:	00912a23          	sw	s1,20(sp)
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    2314:	0ff00993          	li	s3,255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    2318:	03246063          	bltu	s0,s2,2338 <z_sys_init_run_level+0x60>
			}
			dev->state->initialized = true;
		}
	}
}
    231c:	01c12083          	lw	ra,28(sp)
    2320:	01812403          	lw	s0,24(sp)
    2324:	01412483          	lw	s1,20(sp)
    2328:	01012903          	lw	s2,16(sp)
    232c:	00c12983          	lw	s3,12(sp)
    2330:	02010113          	addi	sp,sp,32
    2334:	00008067          	ret
		const struct device *dev = entry->dev;
    2338:	00442483          	lw	s1,4(s0)
		int rc = entry->init(dev);
    233c:	00042783          	lw	a5,0(s0)
    2340:	00048513          	mv	a0,s1
    2344:	000780e7          	jalr	a5
		if (dev != NULL) {
    2348:	02048863          	beqz	s1,2378 <z_sys_init_run_level+0xa0>
				dev->state->init_res = rc;
    234c:	00c4a783          	lw	a5,12(s1)
			if (rc != 0) {
    2350:	00050e63          	beqz	a0,236c <z_sys_init_run_level+0x94>
				if (rc < 0) {
    2354:	41f55713          	srai	a4,a0,0x1f
    2358:	00a74533          	xor	a0,a4,a0
    235c:	40e50533          	sub	a0,a0,a4
				dev->state->init_res = rc;
    2360:	00a9d463          	bge	s3,a0,2368 <z_sys_init_run_level+0x90>
    2364:	0ff00513          	li	a0,255
    2368:	00a78023          	sb	a0,0(a5)
			dev->state->initialized = true;
    236c:	0007d703          	lhu	a4,0(a5)
    2370:	10076713          	ori	a4,a4,256
    2374:	00e79023          	sh	a4,0(a5)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    2378:	00840413          	addi	s0,s0,8
    237c:	f9dff06f          	j	2318 <z_sys_init_run_level+0x40>

00002380 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    2380:	00050e63          	beqz	a0,239c <z_device_ready+0x1c>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    2384:	00c52783          	lw	a5,12(a0)
    2388:	0007a503          	lw	a0,0(a5)
    238c:	1ff57513          	andi	a0,a0,511
    2390:	f0050513          	addi	a0,a0,-256
    2394:	00153513          	seqz	a0,a0
    2398:	00008067          	ret
		return false;
    239c:	00000513          	li	a0,0
}
    23a0:	00008067          	ret

000023a4 <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    23a4:	00800793          	li	a5,8
    23a8:	3007b7f3          	csrrc	a5,mstatus,a5
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    23ac:	0000006f          	j	23ac <arch_system_halt+0x8>

000023b0 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    23b0:	ff010113          	addi	sp,sp,-16
    23b4:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
    23b8:	fedff0ef          	jal	ra,23a4 <arch_system_halt>

000023bc <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    23bc:	fe010113          	addi	sp,sp,-32
    23c0:	00812c23          	sw	s0,24(sp)
    23c4:	01212823          	sw	s2,16(sp)
    23c8:	00112e23          	sw	ra,28(sp)
    23cc:	00912a23          	sw	s1,20(sp)
    23d0:	00050913          	mv	s2,a0
    23d4:	00b12623          	sw	a1,12(sp)
    23d8:	00800413          	li	s0,8
    23dc:	30043473          	csrrc	s0,mstatus,s0
	return z_impl_z_current_get();
    23e0:	161000ef          	jal	ra,2d40 <z_impl_z_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    23e4:	00c12583          	lw	a1,12(sp)
    23e8:	00050493          	mv	s1,a0
    23ec:	00090513          	mv	a0,s2
    23f0:	fc1ff0ef          	jal	ra,23b0 <k_sys_fatal_error_handler>
	key = (mstatus & MSTATUS_IEN);
    23f4:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    23f8:	30042473          	csrrs	s0,mstatus,s0
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    23fc:	01812403          	lw	s0,24(sp)
    2400:	01c12083          	lw	ra,28(sp)
    2404:	01012903          	lw	s2,16(sp)
	z_impl_k_thread_abort(thread);
    2408:	00048513          	mv	a0,s1
    240c:	01412483          	lw	s1,20(sp)
    2410:	02010113          	addi	sp,sp,32
    2414:	22d0006f          	j	2e40 <z_impl_k_thread_abort>

00002418 <init_idle_thread>:
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    2418:	01800693          	li	a3,24
    241c:	02d506b3          	mul	a3,a0,a3
{
    2420:	fe010113          	addi	sp,sp,-32
    2424:	00812c23          	sw	s0,24(sp)
	z_setup_new_thread(thread, stack,
    2428:	00004737          	lui	a4,0x4
	struct k_thread *thread = &z_idle_threads[i];
    242c:	00004437          	lui	s0,0x4
	k_thread_stack_t *stack = z_idle_stacks[i];
    2430:	00951313          	slli	t1,a0,0x9
	struct k_thread *thread = &z_idle_threads[i];
    2434:	8e840413          	addi	s0,s0,-1816 # 38e8 <z_idle_threads>
    2438:	00751513          	slli	a0,a0,0x7
	z_setup_new_thread(thread, stack,
    243c:	9e870713          	addi	a4,a4,-1560 # 39e8 <_kernel>
    2440:	000045b7          	lui	a1,0x4
	struct k_thread *thread = &z_idle_threads[i];
    2444:	00a40433          	add	s0,s0,a0
	z_setup_new_thread(thread, stack,
    2448:	00100793          	li	a5,1
    244c:	00d70733          	add	a4,a4,a3
    2450:	e1058593          	addi	a1,a1,-496 # 3e10 <z_idle_stacks>
    2454:	000026b7          	lui	a3,0x2
    2458:	00f12023          	sw	a5,0(sp)
    245c:	00012223          	sw	zero,4(sp)
    2460:	00000793          	li	a5,0
    2464:	00040513          	mv	a0,s0
    2468:	00f00893          	li	a7,15
    246c:	00000813          	li	a6,0
    2470:	78468693          	addi	a3,a3,1924 # 2784 <idle>
    2474:	20000613          	li	a2,512
    2478:	006585b3          	add	a1,a1,t1
{
    247c:	00112e23          	sw	ra,28(sp)
	z_setup_new_thread(thread, stack,
    2480:	168000ef          	jal	ra,25e8 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    2484:	00d44783          	lbu	a5,13(s0)
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    2488:	01c12083          	lw	ra,28(sp)
    248c:	ffb7f793          	andi	a5,a5,-5
    2490:	00f406a3          	sb	a5,13(s0)
    2494:	01812403          	lw	s0,24(sp)
    2498:	02010113          	addi	sp,sp,32
    249c:	00008067          	ret

000024a0 <bg_thread_main>:
{
    24a0:	ff010113          	addi	sp,sp,-16
	z_sys_post_kernel = true;
    24a4:	000047b7          	lui	a5,0x4
    24a8:	00100713          	li	a4,1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    24ac:	00200513          	li	a0,2
{
    24b0:	00112623          	sw	ra,12(sp)
	z_sys_post_kernel = true;
    24b4:	8ee78023          	sb	a4,-1824(a5) # 38e0 <z_sys_post_kernel>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    24b8:	e21ff0ef          	jal	ra,22d8 <z_sys_init_run_level>
	boot_banner();
    24bc:	611000ef          	jal	ra,32cc <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    24c0:	00300513          	li	a0,3
    24c4:	e15ff0ef          	jal	ra,22d8 <z_sys_init_run_level>
	z_init_static_threads();
    24c8:	1a4000ef          	jal	ra,266c <z_init_static_threads>
	main();
    24cc:	e60fe0ef          	jal	ra,b2c <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    24d0:	000047b7          	lui	a5,0x4
    24d4:	96878793          	addi	a5,a5,-1688 # 3968 <z_main_thread>
    24d8:	00c7c703          	lbu	a4,12(a5)
    24dc:	ffe77713          	andi	a4,a4,-2
    24e0:	00e78623          	sb	a4,12(a5)
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    24e4:	00c12083          	lw	ra,12(sp)
    24e8:	01010113          	addi	sp,sp,16
    24ec:	00008067          	ret

000024f0 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    24f0:	00004537          	lui	a0,0x4
    24f4:	000047b7          	lui	a5,0x4
    24f8:	8b050613          	addi	a2,a0,-1872 # 38b0 <last_count>
    24fc:	a0c78793          	addi	a5,a5,-1524 # 3a0c <sched_spinlock>
    2500:	40c78633          	sub	a2,a5,a2
    2504:	00000593          	li	a1,0
    2508:	8b050513          	addi	a0,a0,-1872
    250c:	d4cff06f          	j	1a58 <memset>

00002510 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    2510:	f6010113          	addi	sp,sp,-160
    2514:	08812c23          	sw	s0,152(sp)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    2518:	10100793          	li	a5,257
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    251c:	00004437          	lui	s0,0x4
    2520:	9e840413          	addi	s0,s0,-1560 # 39e8 <_kernel>
	dummy_thread->base.user_options = K_ESSENTIAL;
    2524:	00f11e23          	sh	a5,28(sp)
	_current_cpu->current = dummy_thread;
    2528:	01010793          	addi	a5,sp,16
    252c:	08112e23          	sw	ra,156(sp)
    2530:	00f42423          	sw	a5,8(s0)
    2534:	08912a23          	sw	s1,148(sp)
    2538:	09212823          	sw	s2,144(sp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    253c:	d99ff0ef          	jal	ra,22d4 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    2540:	00000513          	li	a0,0
    2544:	d95ff0ef          	jal	ra,22d8 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    2548:	00100513          	li	a0,1
    254c:	d8dff0ef          	jal	ra,22d8 <z_sys_init_run_level>
	z_sched_init();
    2550:	7cc000ef          	jal	ra,2d1c <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    2554:	000047b7          	lui	a5,0x4
    2558:	87878793          	addi	a5,a5,-1928 # 3878 <levels.0+0x14>
	_kernel.ready_q.cache = &z_main_thread;
    255c:	000044b7          	lui	s1,0x4
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    2560:	00f12223          	sw	a5,4(sp)
    2564:	000026b7          	lui	a3,0x2
    2568:	00100793          	li	a5,1
    256c:	000045b7          	lui	a1,0x4
	_kernel.ready_q.cache = &z_main_thread;
    2570:	96848913          	addi	s2,s1,-1688 # 3968 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    2574:	00000893          	li	a7,0
    2578:	00000813          	li	a6,0
    257c:	00000713          	li	a4,0
    2580:	4a068693          	addi	a3,a3,1184 # 24a0 <bg_thread_main>
    2584:	40000613          	li	a2,1024
    2588:	a1058593          	addi	a1,a1,-1520 # 3a10 <z_main_stack>
    258c:	00f12023          	sw	a5,0(sp)
    2590:	96848513          	addi	a0,s1,-1688
    2594:	00000793          	li	a5,0
	_kernel.ready_q.cache = &z_main_thread;
    2598:	01242c23          	sw	s2,24(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    259c:	04c000ef          	jal	ra,25e8 <z_setup_new_thread>
    25a0:	00d94783          	lbu	a5,13(s2)
	z_ready_thread(&z_main_thread);
    25a4:	96848513          	addi	a0,s1,-1688
    25a8:	ffb7f793          	andi	a5,a5,-5
    25ac:	00f906a3          	sb	a5,13(s2)
    25b0:	638000ef          	jal	ra,2be8 <z_ready_thread>
		init_idle_thread(i);
    25b4:	00000513          	li	a0,0
    25b8:	e61ff0ef          	jal	ra,2418 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    25bc:	000047b7          	lui	a5,0x4
    25c0:	8e878793          	addi	a5,a5,-1816 # 38e8 <z_idle_threads>
    25c4:	00f42623          	sw	a5,12(s0)
		_kernel.cpus[i].irq_stack =
    25c8:	000057b7          	lui	a5,0x5
    25cc:	81078793          	addi	a5,a5,-2032 # 4810 <_char_out>
		_kernel.cpus[i].id = i;
    25d0:	00040a23          	sb	zero,20(s0)
		_kernel.cpus[i].irq_stack =
    25d4:	00f42223          	sw	a5,4(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    25d8:	00800513          	li	a0,8
    25dc:	30053573          	csrrc	a0,mstatus,a0
	ret = arch_swap(key);
    25e0:	00857513          	andi	a0,a0,8
    25e4:	ce9fd0ef          	jal	ra,2cc <arch_swap>

000025e8 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    25e8:	ff010113          	addi	sp,sp,-16
    25ec:	00812423          	sw	s0,8(sp)
    25f0:	00912223          	sw	s1,4(sp)
    25f4:	00112623          	sw	ra,12(sp)
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    25f8:	06850313          	addi	t1,a0,104
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    25fc:	06652423          	sw	t1,104(a0)
	list->tail = (sys_dnode_t *)list;
    2600:	06652623          	sw	t1,108(a0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    2604:	01012303          	lw	t1,16(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    2608:	00f60613          	addi	a2,a2,15
    260c:	ff067613          	andi	a2,a2,-16
	stack_ptr = (char *)stack + stack_obj_size;
    2610:	00c584b3          	add	s1,a1,a2
	thread_base->user_options = (uint8_t)options;
    2614:	00650623          	sb	t1,12(a0)
	thread_base->thread_state = (uint8_t)initial_state;
    2618:	00400313          	li	t1,4
	thread_base->pended_on = NULL;
    261c:	00052423          	sw	zero,8(a0)
	thread_base->thread_state = (uint8_t)initial_state;
    2620:	006506a3          	sb	t1,13(a0)

	thread_base->prio = priority;
    2624:	01150723          	sb	a7,14(a0)

	thread_base->sched_locked = 0U;
    2628:	000507a3          	sb	zero,15(a0)
 * @return N/A
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
    262c:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
    2630:	00052e23          	sw	zero,28(a0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    2634:	00048613          	mv	a2,s1
{
    2638:	00050413          	mv	s0,a0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    263c:	ba0ff0ef          	jal	ra,19dc <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
    2640:	000047b7          	lui	a5,0x4
    2644:	9f07a783          	lw	a5,-1552(a5) # 39f0 <_kernel+0x8>
}
    2648:	00c12083          	lw	ra,12(sp)
	new_thread->init_data = NULL;
    264c:	06042223          	sw	zero,100(s0)
	new_thread->resource_pool = _current->resource_pool;
    2650:	0747a783          	lw	a5,116(a5)
}
    2654:	00048513          	mv	a0,s1
    2658:	00412483          	lw	s1,4(sp)
	new_thread->resource_pool = _current->resource_pool;
    265c:	06f42a23          	sw	a5,116(s0)
}
    2660:	00812403          	lw	s0,8(sp)
    2664:	01010113          	addi	sp,sp,16
    2668:	00008067          	ret

0000266c <z_init_static_threads>:
{
    266c:	fd010113          	addi	sp,sp,-48
	_FOREACH_STATIC_THREAD(thread_data) {
    2670:	000057b7          	lui	a5,0x5
{
    2674:	03212023          	sw	s2,32(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
    2678:	00005937          	lui	s2,0x5
{
    267c:	02812423          	sw	s0,40(sp)
    2680:	02912223          	sw	s1,36(sp)
    2684:	02112623          	sw	ra,44(sp)
    2688:	01312e23          	sw	s3,28(sp)
    268c:	01412c23          	sw	s4,24(sp)
    2690:	01512a23          	sw	s5,20(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
    2694:	83c78413          	addi	s0,a5,-1988 # 483c <__data_region_end>
    2698:	83c78493          	addi	s1,a5,-1988
    269c:	83c90913          	addi	s2,s2,-1988 # 483c <__data_region_end>
    26a0:	05246063          	bltu	s0,s2,26e0 <z_init_static_threads+0x74>
	k_sched_lock();
    26a4:	284000ef          	jal	ra,2928 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    26a8:	00048413          	mv	s0,s1
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    26ac:	fff00993          	li	s3,-1
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
    26b0:	00900a13          	li	s4,9

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    26b4:	00003ab7          	lui	s5,0x3
	_FOREACH_STATIC_THREAD(thread_data) {
    26b8:	07246663          	bltu	s0,s2,2724 <z_init_static_threads+0xb8>
}
    26bc:	02812403          	lw	s0,40(sp)
    26c0:	02c12083          	lw	ra,44(sp)
    26c4:	02412483          	lw	s1,36(sp)
    26c8:	02012903          	lw	s2,32(sp)
    26cc:	01c12983          	lw	s3,28(sp)
    26d0:	01812a03          	lw	s4,24(sp)
    26d4:	01412a83          	lw	s5,20(sp)
    26d8:	03010113          	addi	sp,sp,48
	k_sched_unlock();
    26dc:	5f80006f          	j	2cd4 <k_sched_unlock>
		z_setup_new_thread(
    26e0:	02c42783          	lw	a5,44(s0)
    26e4:	00f12223          	sw	a5,4(sp)
    26e8:	02042783          	lw	a5,32(s0)
    26ec:	00f12023          	sw	a5,0(sp)
    26f0:	01442783          	lw	a5,20(s0)
    26f4:	01c42883          	lw	a7,28(s0)
    26f8:	01842803          	lw	a6,24(s0)
    26fc:	01042703          	lw	a4,16(s0)
    2700:	00c42683          	lw	a3,12(s0)
    2704:	00842603          	lw	a2,8(s0)
    2708:	00442583          	lw	a1,4(s0)
    270c:	00042503          	lw	a0,0(s0)
    2710:	ed9ff0ef          	jal	ra,25e8 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    2714:	00042783          	lw	a5,0(s0)
    2718:	0687a223          	sw	s0,100(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
    271c:	03040413          	addi	s0,s0,48
    2720:	f81ff06f          	j	26a0 <z_init_static_threads+0x34>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    2724:	02442783          	lw	a5,36(s0)
    2728:	03378863          	beq	a5,s3,2758 <z_init_static_threads+0xec>
			schedule_new_thread(thread_data->init_thread,
    272c:	00042483          	lw	s1,0(s0)
					    K_MSEC(thread_data->init_delay));
    2730:	0007d463          	bgez	a5,2738 <z_init_static_threads+0xcc>
    2734:	00000793          	li	a5,0
    2738:	00978513          	addi	a0,a5,9
    273c:	41f7d593          	srai	a1,a5,0x1f
    2740:	00f537b3          	sltu	a5,a0,a5
    2744:	00b785b3          	add	a1,a5,a1
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    2748:	01451c63          	bne	a0,s4,2760 <z_init_static_threads+0xf4>
    274c:	00059a63          	bnez	a1,2760 <z_init_static_threads+0xf4>
	z_sched_start(thread);
    2750:	00048513          	mv	a0,s1
    2754:	4c4000ef          	jal	ra,2c18 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    2758:	03040413          	addi	s0,s0,48
    275c:	f5dff06f          	j	26b8 <z_init_static_threads+0x4c>
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
    2760:	00a00613          	li	a2,10
    2764:	00000693          	li	a3,0
    2768:	b89fd0ef          	jal	ra,2f0 <__udivdi3>
    276c:	00050613          	mv	a2,a0
    2770:	00058693          	mv	a3,a1
    2774:	01848513          	addi	a0,s1,24
    2778:	c68a8593          	addi	a1,s5,-920 # 2c68 <z_thread_timeout>
    277c:	7c8000ef          	jal	ra,2f44 <z_add_timeout>
    2780:	fd9ff06f          	j	2758 <z_init_static_threads+0xec>

00002784 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    2784:	ff010113          	addi	sp,sp,-16
    2788:	00812423          	sw	s0,8(sp)
    278c:	00112623          	sw	ra,12(sp)
    2790:	00800413          	li	s0,8
    2794:	300437f3          	csrrc	a5,mstatus,s0
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    2798:	9b4ff0ef          	jal	ra,194c <arch_cpu_idle>
    279c:	ff9ff06f          	j	2794 <idle+0x10>

000027a0 <sys_dlist_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    27a0:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
    27a4:	00052783          	lw	a5,0(a0)

	prev->next = next;
    27a8:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
    27ac:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
    27b0:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
    27b4:	00052223          	sw	zero,4(a0)
	sys_dnode_init(node);
}
    27b8:	00008067          	ret

000027bc <unpend_thread_no_timeout>:
		pend_locked(thread, wait_q, timeout);
	}
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
    27bc:	ff010113          	addi	sp,sp,-16
    27c0:	00812423          	sw	s0,8(sp)
    27c4:	00112623          	sw	ra,12(sp)
    27c8:	00050413          	mv	s0,a0

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    27cc:	fd5ff0ef          	jal	ra,27a0 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
    27d0:	00d44783          	lbu	a5,13(s0)
}
    27d4:	00c12083          	lw	ra,12(sp)
	thread->base.pended_on = NULL;
    27d8:	00042423          	sw	zero,8(s0)
    27dc:	ffd7f793          	andi	a5,a5,-3
    27e0:	00f406a3          	sb	a5,13(s0)
}
    27e4:	00812403          	lw	s0,8(sp)
    27e8:	01010113          	addi	sp,sp,16
    27ec:	00008067          	ret

000027f0 <z_reset_time_slice>:
{
    27f0:	ff010113          	addi	sp,sp,-16
    27f4:	00812423          	sw	s0,8(sp)
	if (slice_time != 0) {
    27f8:	00004437          	lui	s0,0x4
    27fc:	8d840413          	addi	s0,s0,-1832 # 38d8 <slice_time>
    2800:	00042783          	lw	a5,0(s0)
{
    2804:	00112623          	sw	ra,12(sp)
	if (slice_time != 0) {
    2808:	02078863          	beqz	a5,2838 <z_reset_time_slice+0x48>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    280c:	ac1ff0ef          	jal	ra,22cc <sys_clock_elapsed>
    2810:	00050793          	mv	a5,a0
    2814:	00042503          	lw	a0,0(s0)
}
    2818:	00812403          	lw	s0,8(sp)
    281c:	00c12083          	lw	ra,12(sp)
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    2820:	00f507b3          	add	a5,a0,a5
    2824:	00004737          	lui	a4,0x4
    2828:	9ef72c23          	sw	a5,-1544(a4) # 39f8 <_kernel+0x10>
		z_set_timeout_expiry(slice_time, false);
    282c:	00000593          	li	a1,0
}
    2830:	01010113          	addi	sp,sp,16
		z_set_timeout_expiry(slice_time, false);
    2834:	1050006f          	j	3138 <z_set_timeout_expiry>
}
    2838:	00c12083          	lw	ra,12(sp)
    283c:	00812403          	lw	s0,8(sp)
    2840:	01010113          	addi	sp,sp,16
    2844:	00008067          	ret

00002848 <k_sched_time_slice_set>:
{
    2848:	ff010113          	addi	sp,sp,-16
    284c:	00812423          	sw	s0,8(sp)
    2850:	00912223          	sw	s1,4(sp)
    2854:	00112623          	sw	ra,12(sp)
    2858:	00050793          	mv	a5,a0
    285c:	00058493          	mv	s1,a1
    2860:	00800413          	li	s0,8
    2864:	30043473          	csrrc	s0,mstatus,s0
		_current_cpu->slice_ticks = 0;
    2868:	00004737          	lui	a4,0x4
		t += off;
    286c:	00950513          	addi	a0,a0,9
    2870:	9e072c23          	sw	zero,-1544(a4) # 39f8 <_kernel+0x10>
	key = (mstatus & MSTATUS_IEN);
    2874:	00847413          	andi	s0,s0,8
    2878:	00f535b3          	sltu	a1,a0,a5
		if (result32 && (t < BIT64(32))) {
    287c:	02f56c63          	bltu	a0,a5,28b4 <k_sched_time_slice_set+0x6c>
			return ((uint32_t)t) / (from_hz / to_hz);
    2880:	00a00793          	li	a5,10
    2884:	02f55533          	divu	a0,a0,a5
		slice_time = k_ms_to_ticks_ceil32(slice);
    2888:	000047b7          	lui	a5,0x4
    288c:	8ca7ac23          	sw	a0,-1832(a5) # 38d8 <slice_time>
		slice_max_prio = prio;
    2890:	000047b7          	lui	a5,0x4
    2894:	8c97aa23          	sw	s1,-1836(a5) # 38d4 <slice_max_prio>
		z_reset_time_slice();
    2898:	f59ff0ef          	jal	ra,27f0 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    289c:	30042473          	csrrs	s0,mstatus,s0
}
    28a0:	00c12083          	lw	ra,12(sp)
    28a4:	00812403          	lw	s0,8(sp)
    28a8:	00412483          	lw	s1,4(sp)
    28ac:	01010113          	addi	sp,sp,16
    28b0:	00008067          	ret
			return t / ((uint64_t)from_hz / to_hz);
    28b4:	00a00613          	li	a2,10
    28b8:	00000693          	li	a3,0
    28bc:	a35fd0ef          	jal	ra,2f0 <__udivdi3>
    28c0:	fc9ff06f          	j	2888 <k_sched_time_slice_set+0x40>

000028c4 <z_reschedule>:
	 * have the single bit set).  But there is a mask applied to
	 * the argument in arch_irq_unlock() that has me worried
	 * that something elseswhere might try to set a bit?  Do it
	 * the safe way for now.
	 */
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
    28c4:	0085f713          	andi	a4,a1,8
{
    28c8:	00058513          	mv	a0,a1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    28cc:	02070263          	beqz	a4,28f0 <z_reschedule+0x2c>
FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf);

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
    28d0:	000047b7          	lui	a5,0x4
    28d4:	9e878793          	addi	a5,a5,-1560 # 39e8 <_kernel>
	if (resched(key.key) && need_swap()) {
    28d8:	0007a683          	lw	a3,0(a5)
    28dc:	00069a63          	bnez	a3,28f0 <z_reschedule+0x2c>
    28e0:	0187a683          	lw	a3,24(a5)
    28e4:	0087a783          	lw	a5,8(a5)
    28e8:	00f68463          	beq	a3,a5,28f0 <z_reschedule+0x2c>
    28ec:	9e1fd06f          	j	2cc <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    28f0:	30072773          	csrrs	a4,mstatus,a4
}
    28f4:	00008067          	ret

000028f8 <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
    28f8:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    28fc:	00078a63          	beqz	a5,2910 <z_reschedule_irqlock+0x18>
	if (resched(key)) {
    2900:	00004737          	lui	a4,0x4
    2904:	9e872703          	lw	a4,-1560(a4) # 39e8 <_kernel>
    2908:	00071463          	bnez	a4,2910 <z_reschedule_irqlock+0x18>
    290c:	9c1fd06f          	j	2cc <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2910:	3007a7f3          	csrrs	a5,mstatus,a5
}
    2914:	00008067          	ret

00002918 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    2918:	00800513          	li	a0,8
    291c:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(arch_irq_lock());
    2920:	00857513          	andi	a0,a0,8
    2924:	fd5ff06f          	j	28f8 <z_reschedule_irqlock>

00002928 <k_sched_lock>:
    2928:	00800793          	li	a5,8
    292c:	3007b7f3          	csrrc	a5,mstatus,a5
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    2930:	00004737          	lui	a4,0x4
    2934:	9f072683          	lw	a3,-1552(a4) # 39f0 <_kernel+0x8>
    2938:	00f6c703          	lbu	a4,15(a3)
    293c:	fff70713          	addi	a4,a4,-1
    2940:	00e687a3          	sb	a4,15(a3)
	key = (mstatus & MSTATUS_IEN);
    2944:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2948:	3007a7f3          	csrrs	a5,mstatus,a5
}
    294c:	00008067          	ret

00002950 <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
    2950:	00050793          	mv	a5,a0
	return list->head == list;
    2954:	00052503          	lw	a0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    2958:	00a79463          	bne	a5,a0,2960 <z_priq_dumb_best+0x10>
	struct k_thread *thread = NULL;
    295c:	00000513          	li	a0,0

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    2960:	00008067          	ret

00002964 <update_cache>:
{
    2964:	ff010113          	addi	sp,sp,-16
    2968:	01212023          	sw	s2,0(sp)
    296c:	00050913          	mv	s2,a0
	thread = _priq_run_best(&_kernel.ready_q.runq);
    2970:	00004537          	lui	a0,0x4
    2974:	a0450513          	addi	a0,a0,-1532 # 3a04 <_kernel+0x1c>
{
    2978:	00812423          	sw	s0,8(sp)
    297c:	00912223          	sw	s1,4(sp)
    2980:	00112623          	sw	ra,12(sp)
    2984:	00004437          	lui	s0,0x4
	thread = _priq_run_best(&_kernel.ready_q.runq);
    2988:	fc9ff0ef          	jal	ra,2950 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    298c:	9e840413          	addi	s0,s0,-1560 # 39e8 <_kernel>
    2990:	00050493          	mv	s1,a0
    2994:	00051463          	bnez	a0,299c <update_cache+0x38>
    2998:	00c42483          	lw	s1,12(s0)
	if (z_is_thread_prevented_from_running(_current)) {
    299c:	00842783          	lw	a5,8(s0)
	if (preempt_ok != 0) {
    29a0:	02091c63          	bnez	s2,29d8 <update_cache+0x74>
	if (z_is_thread_prevented_from_running(_current)) {
    29a4:	00d7c703          	lbu	a4,13(a5)
    29a8:	01f77713          	andi	a4,a4,31
    29ac:	02071663          	bnez	a4,29d8 <update_cache+0x74>
	if (is_preempt(_current) || is_metairq(thread)) {
    29b0:	00e7d683          	lhu	a3,14(a5)
    29b4:	07f00713          	li	a4,127
    29b8:	02d77063          	bgeu	a4,a3,29d8 <update_cache+0x74>
		_kernel.ready_q.cache = _current;
    29bc:	00f42c23          	sw	a5,24(s0)
}
    29c0:	00c12083          	lw	ra,12(sp)
    29c4:	00812403          	lw	s0,8(sp)
    29c8:	00412483          	lw	s1,4(sp)
    29cc:	00012903          	lw	s2,0(sp)
    29d0:	01010113          	addi	sp,sp,16
    29d4:	00008067          	ret
		if (thread != _current) {
    29d8:	00f48463          	beq	s1,a5,29e0 <update_cache+0x7c>
			z_reset_time_slice();
    29dc:	e15ff0ef          	jal	ra,27f0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    29e0:	00942c23          	sw	s1,24(s0)
}
    29e4:	fddff06f          	j	29c0 <update_cache+0x5c>

000029e8 <move_thread_to_end_of_prio_q>:
{
    29e8:	ff010113          	addi	sp,sp,-16
    29ec:	00812423          	sw	s0,8(sp)
    29f0:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
    29f4:	00d54783          	lbu	a5,13(a0)
    29f8:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
    29fc:	01879713          	slli	a4,a5,0x18
    2a00:	41875713          	srai	a4,a4,0x18
    2a04:	00075863          	bgez	a4,2a14 <move_thread_to_end_of_prio_q+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    2a08:	07f7f793          	andi	a5,a5,127
    2a0c:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
    2a10:	d91ff0ef          	jal	ra,27a0 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    2a14:	00d44783          	lbu	a5,13(s0)
	return list->head == list;
    2a18:	00004737          	lui	a4,0x4
    2a1c:	9e870693          	addi	a3,a4,-1560 # 39e8 <_kernel>
    2a20:	f807e793          	ori	a5,a5,-128
    2a24:	00f406a3          	sb	a5,13(s0)
    2a28:	01c6a783          	lw	a5,28(a3)
	return (node == list->tail) ? NULL : node->next;
    2a2c:	0206a583          	lw	a1,32(a3)
    2a30:	000046b7          	lui	a3,0x4
    2a34:	a0468693          	addi	a3,a3,-1532 # 3a04 <_kernel+0x1c>
    2a38:	9e870713          	addi	a4,a4,-1560
	return sys_dlist_is_empty(list) ? NULL : list->head;
    2a3c:	04d78c63          	beq	a5,a3,2a94 <move_thread_to_end_of_prio_q+0xac>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    2a40:	04078a63          	beqz	a5,2a94 <move_thread_to_end_of_prio_q+0xac>
	int32_t b1 = thread_1->base.prio;
    2a44:	00e40503          	lb	a0,14(s0)
	int32_t b2 = thread_2->base.prio;
    2a48:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
    2a4c:	02c50e63          	beq	a0,a2,2a88 <move_thread_to_end_of_prio_q+0xa0>
		return b2 - b1;
    2a50:	40a60633          	sub	a2,a2,a0
		if (z_sched_prio_cmp(thread, t) > 0) {
    2a54:	02c05a63          	blez	a2,2a88 <move_thread_to_end_of_prio_q+0xa0>
	sys_dnode_t *const prev = successor->prev;
    2a58:	0047a683          	lw	a3,4(a5)
	node->next = successor;
    2a5c:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
    2a60:	00d42223          	sw	a3,4(s0)
	prev->next = node;
    2a64:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
    2a68:	0087a223          	sw	s0,4(a5)
	update_cache(thread == _current);
    2a6c:	00872503          	lw	a0,8(a4)
}
    2a70:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
    2a74:	40850533          	sub	a0,a0,s0
}
    2a78:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
    2a7c:	00153513          	seqz	a0,a0
}
    2a80:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
    2a84:	ee1ff06f          	j	2964 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    2a88:	00b78663          	beq	a5,a1,2a94 <move_thread_to_end_of_prio_q+0xac>
    2a8c:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    2a90:	fa079ce3          	bnez	a5,2a48 <move_thread_to_end_of_prio_q+0x60>
	node->next = list;
    2a94:	00d42023          	sw	a3,0(s0)
	node->prev = tail;
    2a98:	00b42223          	sw	a1,4(s0)
	tail->next = node;
    2a9c:	0085a023          	sw	s0,0(a1)
	list->tail = node;
    2aa0:	02872023          	sw	s0,32(a4)
}
    2aa4:	fc9ff06f          	j	2a6c <move_thread_to_end_of_prio_q+0x84>

00002aa8 <z_time_slice>:
{
    2aa8:	ff010113          	addi	sp,sp,-16
    2aac:	00812423          	sw	s0,8(sp)
    2ab0:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    2ab4:	00800413          	li	s0,8
    2ab8:	30043473          	csrrc	s0,mstatus,s0
	if (slice_time && sliceable(_current)) {
    2abc:	000047b7          	lui	a5,0x4
    2ac0:	8d87a703          	lw	a4,-1832(a5) # 38d8 <slice_time>
    2ac4:	000047b7          	lui	a5,0x4
	key = (mstatus & MSTATUS_IEN);
    2ac8:	00847413          	andi	s0,s0,8
    2acc:	9e878793          	addi	a5,a5,-1560 # 39e8 <_kernel>
    2ad0:	06070863          	beqz	a4,2b40 <z_time_slice+0x98>
    2ad4:	00050693          	mv	a3,a0
    2ad8:	0087a503          	lw	a0,8(a5)
		&& !z_is_idle_thread_object(thread);
    2adc:	07f00713          	li	a4,127
    2ae0:	00e55603          	lhu	a2,14(a0)
    2ae4:	04c76e63          	bltu	a4,a2,2b40 <z_time_slice+0x98>
		&& !z_is_thread_prevented_from_running(thread)
    2ae8:	00d54703          	lbu	a4,13(a0)
    2aec:	01f77713          	andi	a4,a4,31
    2af0:	04071863          	bnez	a4,2b40 <z_time_slice+0x98>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    2af4:	00004737          	lui	a4,0x4
    2af8:	00e50603          	lb	a2,14(a0)
    2afc:	8d472703          	lw	a4,-1836(a4) # 38d4 <slice_max_prio>
    2b00:	04e64063          	blt	a2,a4,2b40 <z_time_slice+0x98>
		&& !z_is_idle_thread_object(thread);
    2b04:	00004737          	lui	a4,0x4
    2b08:	8e870713          	addi	a4,a4,-1816 # 38e8 <z_idle_threads>
    2b0c:	02e50a63          	beq	a0,a4,2b40 <z_time_slice+0x98>
		if (ticks >= _current_cpu->slice_ticks) {
    2b10:	0107a703          	lw	a4,16(a5)
    2b14:	02e6c063          	blt	a3,a4,2b34 <z_time_slice+0x8c>
			move_thread_to_end_of_prio_q(_current);
    2b18:	ed1ff0ef          	jal	ra,29e8 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    2b1c:	cd5ff0ef          	jal	ra,27f0 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2b20:	30042473          	csrrs	s0,mstatus,s0
}
    2b24:	00c12083          	lw	ra,12(sp)
    2b28:	00812403          	lw	s0,8(sp)
    2b2c:	01010113          	addi	sp,sp,16
    2b30:	00008067          	ret
			_current_cpu->slice_ticks -= ticks;
    2b34:	40d70733          	sub	a4,a4,a3
    2b38:	00e7a823          	sw	a4,16(a5)
    2b3c:	fe5ff06f          	j	2b20 <z_time_slice+0x78>
		_current_cpu->slice_ticks = 0;
    2b40:	0007a823          	sw	zero,16(a5)
    2b44:	fddff06f          	j	2b20 <z_time_slice+0x78>

00002b48 <ready_thread>:
    2b48:	00d54783          	lbu	a5,13(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    2b4c:	01879713          	slli	a4,a5,0x18
    2b50:	41875713          	srai	a4,a4,0x18
    2b54:	08074863          	bltz	a4,2be4 <ready_thread+0x9c>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    2b58:	01f7f713          	andi	a4,a5,31
    2b5c:	08071463          	bnez	a4,2be4 <ready_thread+0x9c>
    2b60:	01852703          	lw	a4,24(a0)
    2b64:	08071063          	bnez	a4,2be4 <ready_thread+0x9c>
	thread->base.thread_state |= _THREAD_QUEUED;
    2b68:	f807e793          	ori	a5,a5,-128
	return list->head == list;
    2b6c:	00004737          	lui	a4,0x4
    2b70:	9e870693          	addi	a3,a4,-1560 # 39e8 <_kernel>
    2b74:	00f506a3          	sb	a5,13(a0)
    2b78:	01c6a783          	lw	a5,28(a3)
	return (node == list->tail) ? NULL : node->next;
    2b7c:	0206a583          	lw	a1,32(a3)
    2b80:	000046b7          	lui	a3,0x4
    2b84:	a0468693          	addi	a3,a3,-1532 # 3a04 <_kernel+0x1c>
    2b88:	9e870713          	addi	a4,a4,-1560
	return sys_dlist_is_empty(list) ? NULL : list->head;
    2b8c:	04d78263          	beq	a5,a3,2bd0 <ready_thread+0x88>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    2b90:	04078063          	beqz	a5,2bd0 <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
    2b94:	00e50803          	lb	a6,14(a0)
	int32_t b2 = thread_2->base.prio;
    2b98:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
    2b9c:	02c80463          	beq	a6,a2,2bc4 <ready_thread+0x7c>
		return b2 - b1;
    2ba0:	41060633          	sub	a2,a2,a6
		if (z_sched_prio_cmp(thread, t) > 0) {
    2ba4:	02c05063          	blez	a2,2bc4 <ready_thread+0x7c>
	sys_dnode_t *const prev = successor->prev;
    2ba8:	0047a703          	lw	a4,4(a5)
	node->next = successor;
    2bac:	00f52023          	sw	a5,0(a0)
	node->prev = prev;
    2bb0:	00e52223          	sw	a4,4(a0)
	prev->next = node;
    2bb4:	00a72023          	sw	a0,0(a4)
	successor->prev = node;
    2bb8:	00a7a223          	sw	a0,4(a5)
		update_cache(0);
    2bbc:	00000513          	li	a0,0
    2bc0:	da5ff06f          	j	2964 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    2bc4:	00b78663          	beq	a5,a1,2bd0 <ready_thread+0x88>
    2bc8:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    2bcc:	fc0796e3          	bnez	a5,2b98 <ready_thread+0x50>
	node->next = list;
    2bd0:	00d52023          	sw	a3,0(a0)
	node->prev = tail;
    2bd4:	00b52223          	sw	a1,4(a0)
	tail->next = node;
    2bd8:	00a5a023          	sw	a0,0(a1)
	list->tail = node;
    2bdc:	02a72023          	sw	a0,32(a4)
}
    2be0:	fddff06f          	j	2bbc <ready_thread+0x74>
}
    2be4:	00008067          	ret

00002be8 <z_ready_thread>:
{
    2be8:	ff010113          	addi	sp,sp,-16
    2bec:	00812423          	sw	s0,8(sp)
    2bf0:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    2bf4:	00800413          	li	s0,8
    2bf8:	30043473          	csrrc	s0,mstatus,s0
			ready_thread(thread);
    2bfc:	f4dff0ef          	jal	ra,2b48 <ready_thread>
	key = (mstatus & MSTATUS_IEN);
    2c00:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2c04:	30042473          	csrrs	s0,mstatus,s0
}
    2c08:	00c12083          	lw	ra,12(sp)
    2c0c:	00812403          	lw	s0,8(sp)
    2c10:	01010113          	addi	sp,sp,16
    2c14:	00008067          	ret

00002c18 <z_sched_start>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    2c18:	00800593          	li	a1,8
    2c1c:	3005b5f3          	csrrc	a1,mstatus,a1
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    2c20:	00d54703          	lbu	a4,13(a0)
	key = (mstatus & MSTATUS_IEN);
    2c24:	0085f593          	andi	a1,a1,8
	if (z_has_thread_started(thread)) {
    2c28:	00477693          	andi	a3,a4,4
    2c2c:	00069663          	bnez	a3,2c38 <z_sched_start+0x20>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2c30:	3005a5f3          	csrrs	a1,mstatus,a1
		return;
    2c34:	00008067          	ret
{
    2c38:	fe010113          	addi	sp,sp,-32
    2c3c:	00112e23          	sw	ra,28(sp)
	thread->base.thread_state &= ~_THREAD_PRESTART;
    2c40:	ffb77713          	andi	a4,a4,-5
    2c44:	00e506a3          	sb	a4,13(a0)
    2c48:	00b12623          	sw	a1,12(sp)
	ready_thread(thread);
    2c4c:	efdff0ef          	jal	ra,2b48 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    2c50:	00c12583          	lw	a1,12(sp)
}
    2c54:	01c12083          	lw	ra,28(sp)
	z_reschedule(&sched_spinlock, key);
    2c58:	00004537          	lui	a0,0x4
    2c5c:	a0c50513          	addi	a0,a0,-1524 # 3a0c <sched_spinlock>
}
    2c60:	02010113          	addi	sp,sp,32
	z_reschedule(&sched_spinlock, key);
    2c64:	c61ff06f          	j	28c4 <z_reschedule>

00002c68 <z_thread_timeout>:
{
    2c68:	fe010113          	addi	sp,sp,-32
    2c6c:	00912a23          	sw	s1,20(sp)
    2c70:	00112e23          	sw	ra,28(sp)
    2c74:	00812c23          	sw	s0,24(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    2c78:	00800493          	li	s1,8
    2c7c:	3004b4f3          	csrrc	s1,mstatus,s1
		if (!killed) {
    2c80:	ff554783          	lbu	a5,-11(a0)
	key = (mstatus & MSTATUS_IEN);
    2c84:	0084f493          	andi	s1,s1,8
    2c88:	0287f793          	andi	a5,a5,40
    2c8c:	02079863          	bnez	a5,2cbc <z_thread_timeout+0x54>
    2c90:	00050413          	mv	s0,a0
			if (thread->base.pended_on != NULL) {
    2c94:	ff042783          	lw	a5,-16(s0)
	struct k_thread *thread = CONTAINER_OF(timeout,
    2c98:	fe850513          	addi	a0,a0,-24
			if (thread->base.pended_on != NULL) {
    2c9c:	00078863          	beqz	a5,2cac <z_thread_timeout+0x44>
				unpend_thread_no_timeout(thread);
    2ca0:	00a12623          	sw	a0,12(sp)
    2ca4:	b19ff0ef          	jal	ra,27bc <unpend_thread_no_timeout>
    2ca8:	00c12503          	lw	a0,12(sp)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    2cac:	ff544783          	lbu	a5,-11(s0)
    2cb0:	feb7f793          	andi	a5,a5,-21
    2cb4:	fef40aa3          	sb	a5,-11(s0)
			ready_thread(thread);
    2cb8:	e91ff0ef          	jal	ra,2b48 <ready_thread>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2cbc:	3004a4f3          	csrrs	s1,mstatus,s1
}
    2cc0:	01c12083          	lw	ra,28(sp)
    2cc4:	01812403          	lw	s0,24(sp)
    2cc8:	01412483          	lw	s1,20(sp)
    2ccc:	02010113          	addi	sp,sp,32
    2cd0:	00008067          	ret

00002cd4 <k_sched_unlock>:
{
    2cd4:	ff010113          	addi	sp,sp,-16
    2cd8:	00812423          	sw	s0,8(sp)
    2cdc:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    2ce0:	00800413          	li	s0,8
    2ce4:	30043473          	csrrc	s0,mstatus,s0
		++_current->base.sched_locked;
    2ce8:	000047b7          	lui	a5,0x4
    2cec:	9f07a703          	lw	a4,-1552(a5) # 39f0 <_kernel+0x8>
		update_cache(0);
    2cf0:	00000513          	li	a0,0
	key = (mstatus & MSTATUS_IEN);
    2cf4:	00847413          	andi	s0,s0,8
		++_current->base.sched_locked;
    2cf8:	00f74783          	lbu	a5,15(a4)
    2cfc:	00178793          	addi	a5,a5,1
    2d00:	00f707a3          	sb	a5,15(a4)
		update_cache(0);
    2d04:	c61ff0ef          	jal	ra,2964 <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2d08:	30042473          	csrrs	s0,mstatus,s0
}
    2d0c:	00812403          	lw	s0,8(sp)
    2d10:	00c12083          	lw	ra,12(sp)
    2d14:	01010113          	addi	sp,sp,16
	z_reschedule_unlocked();
    2d18:	c01ff06f          	j	2918 <z_reschedule_unlocked>

00002d1c <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    2d1c:	000047b7          	lui	a5,0x4
    2d20:	00004737          	lui	a4,0x4
    2d24:	9e878793          	addi	a5,a5,-1560 # 39e8 <_kernel>
    2d28:	a0470713          	addi	a4,a4,-1532 # 3a04 <_kernel+0x1c>
    2d2c:	00e7ae23          	sw	a4,28(a5)
	list->tail = (sys_dnode_t *)list;
    2d30:	02e7a023          	sw	a4,32(a5)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    2d34:	00000593          	li	a1,0
    2d38:	00000513          	li	a0,0
    2d3c:	b0dff06f          	j	2848 <k_sched_time_slice_set>

00002d40 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    2d40:	000047b7          	lui	a5,0x4
    2d44:	9f07a503          	lw	a0,-1552(a5) # 39f0 <_kernel+0x8>
    2d48:	00008067          	ret

00002d4c <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    2d4c:	fe010113          	addi	sp,sp,-32
    2d50:	00912a23          	sw	s1,20(sp)
    2d54:	00112e23          	sw	ra,28(sp)
    2d58:	00812c23          	sw	s0,24(sp)
    2d5c:	01212823          	sw	s2,16(sp)
    2d60:	01312623          	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    2d64:	00800493          	li	s1,8
    2d68:	3004b4f3          	csrrc	s1,mstatus,s1
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    2d6c:	00d54783          	lbu	a5,13(a0)
	key = (mstatus & MSTATUS_IEN);
    2d70:	0084f493          	andi	s1,s1,8
    2d74:	0087f713          	andi	a4,a5,8
    2d78:	02070263          	beqz	a4,2d9c <z_thread_abort+0x50>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    2d7c:	3004a4f3          	csrrs	s1,mstatus,s1
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    2d80:	01c12083          	lw	ra,28(sp)
    2d84:	01812403          	lw	s0,24(sp)
    2d88:	01412483          	lw	s1,20(sp)
    2d8c:	01012903          	lw	s2,16(sp)
    2d90:	00c12983          	lw	s3,12(sp)
    2d94:	02010113          	addi	sp,sp,32
    2d98:	00008067          	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
    2d9c:	fdf7f713          	andi	a4,a5,-33
    2da0:	00876713          	ori	a4,a4,8
		if (z_is_thread_queued(thread)) {
    2da4:	01871693          	slli	a3,a4,0x18
    2da8:	4186d693          	srai	a3,a3,0x18
    2dac:	00050413          	mv	s0,a0
    2db0:	0406ce63          	bltz	a3,2e0c <z_thread_abort+0xc0>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    2db4:	00e506a3          	sb	a4,13(a0)
		if (thread->base.pended_on != NULL) {
    2db8:	00842783          	lw	a5,8(s0)
    2dbc:	00078663          	beqz	a5,2dc8 <z_thread_abort+0x7c>
			unpend_thread_no_timeout(thread);
    2dc0:	00040513          	mv	a0,s0
    2dc4:	9f9ff0ef          	jal	ra,27bc <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    2dc8:	01840513          	addi	a0,s0,24
    2dcc:	328000ef          	jal	ra,30f4 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    2dd0:	06840993          	addi	s3,s0,104
	return list->head == list;
    2dd4:	06842903          	lw	s2,104(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    2dd8:	01390463          	beq	s2,s3,2de0 <z_thread_abort+0x94>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    2ddc:	04091263          	bnez	s2,2e20 <z_thread_abort+0xd4>
		update_cache(1);
    2de0:	00100513          	li	a0,1
    2de4:	b81ff0ef          	jal	ra,2964 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
    2de8:	000047b7          	lui	a5,0x4
    2dec:	9e878793          	addi	a5,a5,-1560 # 39e8 <_kernel>
    2df0:	0087a703          	lw	a4,8(a5)
    2df4:	f88714e3          	bne	a4,s0,2d7c <z_thread_abort+0x30>
    2df8:	0007a783          	lw	a5,0(a5)
    2dfc:	f80790e3          	bnez	a5,2d7c <z_thread_abort+0x30>
    2e00:	00048513          	mv	a0,s1
    2e04:	cc8fd0ef          	jal	ra,2cc <arch_swap>
	return ret;
    2e08:	f75ff06f          	j	2d7c <z_thread_abort+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    2e0c:	05f7f793          	andi	a5,a5,95
    2e10:	0087e793          	ori	a5,a5,8
    2e14:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
    2e18:	989ff0ef          	jal	ra,27a0 <sys_dlist_remove>
}
    2e1c:	f9dff06f          	j	2db8 <z_thread_abort+0x6c>
		unpend_thread_no_timeout(thread);
    2e20:	00090513          	mv	a0,s2
    2e24:	999ff0ef          	jal	ra,27bc <unpend_thread_no_timeout>
    2e28:	01890513          	addi	a0,s2,24
    2e2c:	2c8000ef          	jal	ra,30f4 <z_abort_timeout>
		ready_thread(thread);
    2e30:	00090513          	mv	a0,s2
	thread->arch.swap_return_value = value;
    2e34:	06092c23          	sw	zero,120(s2)
    2e38:	d11ff0ef          	jal	ra,2b48 <ready_thread>
    2e3c:	f99ff06f          	j	2dd4 <z_thread_abort+0x88>

00002e40 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
    2e40:	f0dff06f          	j	2d4c <z_thread_abort>

00002e44 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    2e44:	000047b7          	lui	a5,0x4
    2e48:	8dc7a783          	lw	a5,-1828(a5) # 38dc <announce_remaining>
    2e4c:	00079463          	bnez	a5,2e54 <elapsed+0x10>
    2e50:	c7cff06f          	j	22cc <sys_clock_elapsed>
}
    2e54:	00000513          	li	a0,0
    2e58:	00008067          	ret

00002e5c <next_timeout>:
	return list->head == list;
    2e5c:	000057b7          	lui	a5,0x5

static int32_t next_timeout(void)
{
    2e60:	ff010113          	addi	sp,sp,-16
    2e64:	82078793          	addi	a5,a5,-2016 # 4820 <timeout_list>
    2e68:	00812423          	sw	s0,8(sp)
    2e6c:	0007a403          	lw	s0,0(a5)
    2e70:	00112623          	sw	ra,12(sp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    2e74:	00f41463          	bne	s0,a5,2e7c <next_timeout+0x20>
    2e78:	00000413          	li	s0,0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    2e7c:	fc9ff0ef          	jal	ra,2e44 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    2e80:	02040c63          	beqz	s0,2eb8 <next_timeout+0x5c>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    2e84:	01042703          	lw	a4,16(s0)
    2e88:	01442783          	lw	a5,20(s0)
    2e8c:	41f55693          	srai	a3,a0,0x1f
    2e90:	40a70533          	sub	a0,a4,a0
    2e94:	00a73733          	sltu	a4,a4,a0
    2e98:	40d787b3          	sub	a5,a5,a3
    2e9c:	40e787b3          	sub	a5,a5,a4
	int32_t ret = to == NULL ? MAX_WAIT
    2ea0:	00f04663          	bgtz	a5,2eac <next_timeout+0x50>
    2ea4:	04079063          	bnez	a5,2ee4 <next_timeout+0x88>
    2ea8:	02050e63          	beqz	a0,2ee4 <next_timeout+0x88>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    2eac:	00f04663          	bgtz	a5,2eb8 <next_timeout+0x5c>
    2eb0:	00079863          	bnez	a5,2ec0 <next_timeout+0x64>
    2eb4:	00055663          	bgez	a0,2ec0 <next_timeout+0x64>
	int32_t ret = to == NULL ? MAX_WAIT
    2eb8:	80000537          	lui	a0,0x80000
    2ebc:	fff54513          	not	a0,a0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    2ec0:	000047b7          	lui	a5,0x4
    2ec4:	9f87a783          	lw	a5,-1544(a5) # 39f8 <_kernel+0x10>
    2ec8:	00078663          	beqz	a5,2ed4 <next_timeout+0x78>
    2ecc:	00a7d463          	bge	a5,a0,2ed4 <next_timeout+0x78>
    2ed0:	00078513          	mv	a0,a5
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    2ed4:	00c12083          	lw	ra,12(sp)
    2ed8:	00812403          	lw	s0,8(sp)
    2edc:	01010113          	addi	sp,sp,16
    2ee0:	00008067          	ret
	int32_t ret = to == NULL ? MAX_WAIT
    2ee4:	00000513          	li	a0,0
    2ee8:	fd9ff06f          	j	2ec0 <next_timeout+0x64>

00002eec <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
    2eec:	00052783          	lw	a5,0(a0) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    2ef0:	02050e63          	beqz	a0,2f2c <remove_timeout+0x40>
	return (node == list->tail) ? NULL : node->next;
    2ef4:	00005737          	lui	a4,0x5
    2ef8:	82472703          	lw	a4,-2012(a4) # 4824 <timeout_list+0x4>
    2efc:	02e50863          	beq	a0,a4,2f2c <remove_timeout+0x40>
	if (next(t) != NULL) {
    2f00:	02078663          	beqz	a5,2f2c <remove_timeout+0x40>
		next(t)->dticks += t->dticks;
    2f04:	0107a703          	lw	a4,16(a5)
    2f08:	01052683          	lw	a3,16(a0)
    2f0c:	01452583          	lw	a1,20(a0)
    2f10:	0147a603          	lw	a2,20(a5)
    2f14:	00d706b3          	add	a3,a4,a3
    2f18:	00e6b733          	sltu	a4,a3,a4
    2f1c:	00b60633          	add	a2,a2,a1
    2f20:	00c70733          	add	a4,a4,a2
    2f24:	00d7a823          	sw	a3,16(a5)
    2f28:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = node->prev;
    2f2c:	00452703          	lw	a4,4(a0)
	prev->next = next;
    2f30:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
    2f34:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
    2f38:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
    2f3c:	00052223          	sw	zero,4(a0)
}
    2f40:	00008067          	ret

00002f44 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    2f44:	fe010113          	addi	sp,sp,-32
    2f48:	00812c23          	sw	s0,24(sp)
    2f4c:	00912a23          	sw	s1,20(sp)
    2f50:	01312623          	sw	s3,12(sp)
    2f54:	00112e23          	sw	ra,28(sp)
    2f58:	00068993          	mv	s3,a3
    2f5c:	01212823          	sw	s2,16(sp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    2f60:	fff00693          	li	a3,-1
{
    2f64:	00050413          	mv	s0,a0
    2f68:	00060493          	mv	s1,a2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    2f6c:	00d61463          	bne	a2,a3,2f74 <z_add_timeout+0x30>
    2f70:	16c98463          	beq	s3,a2,30d8 <z_add_timeout+0x194>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    2f74:	00b42423          	sw	a1,8(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    2f78:	00800913          	li	s2,8
    2f7c:	30093973          	csrrc	s2,mstatus,s2

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    2f80:	ffe00693          	li	a3,-2
    2f84:	409687b3          	sub	a5,a3,s1
    2f88:	00f6b733          	sltu	a4,a3,a5
    2f8c:	fff9c793          	not	a5,s3
    2f90:	40e787b3          	sub	a5,a5,a4
	key = (mstatus & MSTATUS_IEN);
    2f94:	00897913          	andi	s2,s2,8
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    2f98:	0607ce63          	bltz	a5,3014 <z_add_timeout+0xd0>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    2f9c:	000047b7          	lui	a5,0x4
    2fa0:	8b878793          	addi	a5,a5,-1864 # 38b8 <curr_tick>
    2fa4:	0007a703          	lw	a4,0(a5)
    2fa8:	0047a783          	lw	a5,4(a5)
    2fac:	40e68733          	sub	a4,a3,a4
    2fb0:	00e6b6b3          	sltu	a3,a3,a4
    2fb4:	fff7c793          	not	a5,a5
    2fb8:	40d787b3          	sub	a5,a5,a3
    2fbc:	409704b3          	sub	s1,a4,s1
    2fc0:	00973733          	sltu	a4,a4,s1
    2fc4:	413786b3          	sub	a3,a5,s3

			to->dticks = MAX(1, ticks);
    2fc8:	40e686b3          	sub	a3,a3,a4
    2fcc:	00d04a63          	bgtz	a3,2fe0 <z_add_timeout+0x9c>
    2fd0:	00069463          	bnez	a3,2fd8 <z_add_timeout+0x94>
    2fd4:	00049663          	bnez	s1,2fe0 <z_add_timeout+0x9c>
    2fd8:	00100493          	li	s1,1
    2fdc:	00000693          	li	a3,0
    2fe0:	00942823          	sw	s1,16(s0)
	return list->head == list;
    2fe4:	00005637          	lui	a2,0x5
    2fe8:	82060713          	addi	a4,a2,-2016 # 4820 <timeout_list>
    2fec:	00072783          	lw	a5,0(a4)
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    2ff0:	00d42a23          	sw	a3,20(s0)
    2ff4:	82060613          	addi	a2,a2,-2016
	sys_dnode_t *const tail = list->tail;
    2ff8:	00472803          	lw	a6,4(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    2ffc:	06c79263          	bne	a5,a2,3060 <z_add_timeout+0x11c>
	node->next = list;
    3000:	00c42023          	sw	a2,0(s0)
	node->prev = tail;
    3004:	01042223          	sw	a6,4(s0)
	tail->next = node;
    3008:	00882023          	sw	s0,0(a6)
	list->tail = node;
    300c:	00862223          	sw	s0,4(a2)
}
    3010:	09c0006f          	j	30ac <z_add_timeout+0x168>
    3014:	e31ff0ef          	jal	ra,2e44 <elapsed>
    3018:	00148793          	addi	a5,s1,1
    301c:	0097b4b3          	sltu	s1,a5,s1
    3020:	013486b3          	add	a3,s1,s3
    3024:	41f55493          	srai	s1,a0,0x1f
    3028:	00a78533          	add	a0,a5,a0
    302c:	00f537b3          	sltu	a5,a0,a5
    3030:	009686b3          	add	a3,a3,s1
    3034:	00d786b3          	add	a3,a5,a3
    3038:	00a42823          	sw	a0,16(s0)
    303c:	fa9ff06f          	j	2fe4 <z_add_timeout+0xa0>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    3040:	40e68733          	sub	a4,a3,a4
    3044:	00e6b6b3          	sltu	a3,a3,a4
    3048:	40a585b3          	sub	a1,a1,a0
    304c:	40d586b3          	sub	a3,a1,a3
    3050:	00e42823          	sw	a4,16(s0)
    3054:	00d42a23          	sw	a3,20(s0)
	return (node == list->tail) ? NULL : node->next;
    3058:	faf804e3          	beq	a6,a5,3000 <z_add_timeout+0xbc>
    305c:	0007a783          	lw	a5,0(a5)
		for (t = first(); t != NULL; t = next(t)) {
    3060:	fa0780e3          	beqz	a5,3000 <z_add_timeout+0xbc>
			if (t->dticks > to->dticks) {
    3064:	0147a503          	lw	a0,20(a5)
    3068:	01442583          	lw	a1,20(s0)
    306c:	0107a703          	lw	a4,16(a5)
    3070:	01042683          	lw	a3,16(s0)
    3074:	00a5c663          	blt	a1,a0,3080 <z_add_timeout+0x13c>
    3078:	fcb514e3          	bne	a0,a1,3040 <z_add_timeout+0xfc>
    307c:	fce6f2e3          	bgeu	a3,a4,3040 <z_add_timeout+0xfc>
				t->dticks -= to->dticks;
    3080:	40d706b3          	sub	a3,a4,a3
    3084:	00d73733          	sltu	a4,a4,a3
    3088:	40b505b3          	sub	a1,a0,a1
    308c:	40e58733          	sub	a4,a1,a4
    3090:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = successor->prev;
    3094:	0047a703          	lw	a4,4(a5)
    3098:	00d7a823          	sw	a3,16(a5)
	node->next = successor;
    309c:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
    30a0:	00e42223          	sw	a4,4(s0)
	prev->next = node;
    30a4:	00872023          	sw	s0,0(a4)
	successor->prev = node;
    30a8:	0087a223          	sw	s0,4(a5)
	return list->head == list;
    30ac:	00062783          	lw	a5,0(a2)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    30b0:	02c78263          	beq	a5,a2,30d4 <z_add_timeout+0x190>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    30b4:	02f41063          	bne	s0,a5,30d4 <z_add_timeout+0x190>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    30b8:	da5ff0ef          	jal	ra,2e5c <next_timeout>

			if (next_time == 0 ||
    30bc:	00050863          	beqz	a0,30cc <z_add_timeout+0x188>
			    _current_cpu->slice_ticks != next_time) {
    30c0:	000047b7          	lui	a5,0x4
			if (next_time == 0 ||
    30c4:	9f87a783          	lw	a5,-1544(a5) # 39f8 <_kernel+0x10>
    30c8:	00a78663          	beq	a5,a0,30d4 <z_add_timeout+0x190>
				sys_clock_set_timeout(next_time, false);
    30cc:	00000593          	li	a1,0
    30d0:	9f8ff0ef          	jal	ra,22c8 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    30d4:	30092973          	csrrs	s2,mstatus,s2
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    30d8:	01c12083          	lw	ra,28(sp)
    30dc:	01812403          	lw	s0,24(sp)
    30e0:	01412483          	lw	s1,20(sp)
    30e4:	01012903          	lw	s2,16(sp)
    30e8:	00c12983          	lw	s3,12(sp)
    30ec:	02010113          	addi	sp,sp,32
    30f0:	00008067          	ret

000030f4 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    30f4:	ff010113          	addi	sp,sp,-16
    30f8:	00812423          	sw	s0,8(sp)
    30fc:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3100:	00800413          	li	s0,8
    3104:	30043473          	csrrc	s0,mstatus,s0
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    3108:	00052783          	lw	a5,0(a0)
	key = (mstatus & MSTATUS_IEN);
    310c:	00847413          	andi	s0,s0,8
    3110:	02078063          	beqz	a5,3130 <z_abort_timeout+0x3c>
			remove_timeout(to);
    3114:	dd9ff0ef          	jal	ra,2eec <remove_timeout>
			ret = 0;
    3118:	00000513          	li	a0,0
	__asm__ volatile ("csrrs %0, mstatus, %1"
    311c:	30042473          	csrrs	s0,mstatus,s0
		}
	}

	return ret;
}
    3120:	00c12083          	lw	ra,12(sp)
    3124:	00812403          	lw	s0,8(sp)
    3128:	01010113          	addi	sp,sp,16
    312c:	00008067          	ret
	int ret = -EINVAL;
    3130:	fea00513          	li	a0,-22
    3134:	fe9ff06f          	j	311c <z_abort_timeout+0x28>

00003138 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    3138:	fe010113          	addi	sp,sp,-32
    313c:	00812c23          	sw	s0,24(sp)
    3140:	00912a23          	sw	s1,20(sp)
    3144:	00112e23          	sw	ra,28(sp)
    3148:	00050493          	mv	s1,a0
    314c:	00b12623          	sw	a1,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    3150:	00800413          	li	s0,8
    3154:	30043473          	csrrc	s0,mstatus,s0
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    3158:	d05ff0ef          	jal	ra,2e5c <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    315c:	00100793          	li	a5,1
	key = (mstatus & MSTATUS_IEN);
    3160:	00847413          	andi	s0,s0,8
    3164:	00a7da63          	bge	a5,a0,3178 <z_set_timeout_expiry+0x40>
    3168:	00c12583          	lw	a1,12(sp)
    316c:	00954663          	blt	a0,s1,3178 <z_set_timeout_expiry+0x40>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    3170:	00048513          	mv	a0,s1
    3174:	954ff0ef          	jal	ra,22c8 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    3178:	30042473          	csrrs	s0,mstatus,s0
		}
	}
}
    317c:	01c12083          	lw	ra,28(sp)
    3180:	01812403          	lw	s0,24(sp)
    3184:	01412483          	lw	s1,20(sp)
    3188:	02010113          	addi	sp,sp,32
    318c:	00008067          	ret

00003190 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    3190:	fd010113          	addi	sp,sp,-48
    3194:	02812423          	sw	s0,40(sp)
    3198:	02912223          	sw	s1,36(sp)
    319c:	02112623          	sw	ra,44(sp)
    31a0:	03212023          	sw	s2,32(sp)
    31a4:	01312e23          	sw	s3,28(sp)
    31a8:	01412c23          	sw	s4,24(sp)
    31ac:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
    31b0:	00800413          	li	s0,8
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    31b4:	8f5ff0ef          	jal	ra,2aa8 <z_time_slice>
    31b8:	30043473          	csrrc	s0,mstatus,s0
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    31bc:	00004937          	lui	s2,0x4
    31c0:	8c992e23          	sw	s1,-1828(s2) # 38dc <announce_remaining>
	return list->head == list;
    31c4:	000059b7          	lui	s3,0x5

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    31c8:	000044b7          	lui	s1,0x4
	key = (mstatus & MSTATUS_IEN);
    31cc:	00847413          	andi	s0,s0,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
    31d0:	8dc90913          	addi	s2,s2,-1828
    31d4:	82098993          	addi	s3,s3,-2016 # 4820 <timeout_list>
		curr_tick += dt;
    31d8:	8b848493          	addi	s1,s1,-1864 # 38b8 <curr_tick>
	__asm__ volatile ("csrrc %0, mstatus, %1"
    31dc:	00800a13          	li	s4,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
    31e0:	00092783          	lw	a5,0(s2)
    31e4:	0009a503          	lw	a0,0(s3)
		curr_tick += dt;
    31e8:	0004a683          	lw	a3,0(s1)
    31ec:	0044a883          	lw	a7,4(s1)
    31f0:	41f7d593          	srai	a1,a5,0x1f
	return sys_dlist_is_empty(list) ? NULL : list->head;
    31f4:	03350a63          	beq	a0,s3,3228 <sys_clock_announce+0x98>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    31f8:	02050863          	beqz	a0,3228 <sys_clock_announce+0x98>
    31fc:	01452603          	lw	a2,20(a0)
    3200:	01052703          	lw	a4,16(a0)
    3204:	00c5c663          	blt	a1,a2,3210 <sys_clock_announce+0x80>
    3208:	06b61663          	bne	a2,a1,3274 <sys_clock_announce+0xe4>
    320c:	06e7f463          	bgeu	a5,a4,3274 <sys_clock_announce+0xe4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    3210:	40f70833          	sub	a6,a4,a5
    3214:	01073733          	sltu	a4,a4,a6
    3218:	40b60633          	sub	a2,a2,a1
    321c:	40e60733          	sub	a4,a2,a4
    3220:	01052823          	sw	a6,16(a0)
    3224:	00e52a23          	sw	a4,20(a0)
	}

	curr_tick += announce_remaining;
    3228:	00d786b3          	add	a3,a5,a3
    322c:	011585b3          	add	a1,a1,a7
    3230:	00f6b7b3          	sltu	a5,a3,a5
    3234:	00b787b3          	add	a5,a5,a1
    3238:	00d4a023          	sw	a3,0(s1)
    323c:	00f4a223          	sw	a5,4(s1)
	announce_remaining = 0;
    3240:	00092023          	sw	zero,0(s2)

	sys_clock_set_timeout(next_timeout(), false);
    3244:	c19ff0ef          	jal	ra,2e5c <next_timeout>
    3248:	00000593          	li	a1,0
    324c:	87cff0ef          	jal	ra,22c8 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    3250:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
    3254:	02c12083          	lw	ra,44(sp)
    3258:	02812403          	lw	s0,40(sp)
    325c:	02412483          	lw	s1,36(sp)
    3260:	02012903          	lw	s2,32(sp)
    3264:	01c12983          	lw	s3,28(sp)
    3268:	01812a03          	lw	s4,24(sp)
    326c:	03010113          	addi	sp,sp,48
    3270:	00008067          	ret
		curr_tick += dt;
    3274:	00d706b3          	add	a3,a4,a3
		announce_remaining -= dt;
    3278:	40e787b3          	sub	a5,a5,a4
		curr_tick += dt;
    327c:	41f75593          	srai	a1,a4,0x1f
    3280:	00e6b633          	sltu	a2,a3,a4
    3284:	011585b3          	add	a1,a1,a7
		announce_remaining -= dt;
    3288:	00f92023          	sw	a5,0(s2)
		t->dticks = 0;
    328c:	00000813          	li	a6,0
    3290:	00000793          	li	a5,0
		curr_tick += dt;
    3294:	00b605b3          	add	a1,a2,a1
		t->dticks = 0;
    3298:	00f52823          	sw	a5,16(a0)
    329c:	01052a23          	sw	a6,20(a0)
		curr_tick += dt;
    32a0:	00d4a023          	sw	a3,0(s1)
    32a4:	00b4a223          	sw	a1,4(s1)
		remove_timeout(t);
    32a8:	00a12623          	sw	a0,12(sp)
    32ac:	c41ff0ef          	jal	ra,2eec <remove_timeout>
    32b0:	30042473          	csrrs	s0,mstatus,s0
		t->fn(t);
    32b4:	00c12503          	lw	a0,12(sp)
    32b8:	00852783          	lw	a5,8(a0)
    32bc:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
    32c0:	300a3473          	csrrc	s0,mstatus,s4
	key = (mstatus & MSTATUS_IEN);
    32c4:	00847413          	andi	s0,s0,8
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    32c8:	f19ff06f          	j	31e0 <sys_clock_announce+0x50>

000032cc <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    32cc:	00003637          	lui	a2,0x3
    32d0:	000045b7          	lui	a1,0x4
    32d4:	00004537          	lui	a0,0x4
    32d8:	6c460613          	addi	a2,a2,1732 # 36c4 <__clz_tab+0x120>
    32dc:	88058593          	addi	a1,a1,-1920 # 3880 <levels.0+0x1c>
    32e0:	88850513          	addi	a0,a0,-1912 # 3888 <levels.0+0x24>
    32e4:	8b9fd06f          	j	b9c <printk>
